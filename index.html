
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8" />
    <title>normal-pcer&#39;s blog</title>
    <meta name="author" content="normal-pcer" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/blogs/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/blogs/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/blogs/js/lib/math.js"></script>


<script src="/blogs/js/lib/preview.js"></script>





<script src="/blogs/js/lib/home.js"></script>

<link rel="stylesheet" href="/blogs/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/blogs/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/blogs/">
            <span>NORMAL-PCER&#39;S BLOG</span>
        </a>
        
        <a href="/blogs/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/blogs/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/blogs/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/blogs/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/blogs/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;NORMAL-PCER&#39;S BLOG</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/blogs/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/blogs/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/blogs/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/blogs/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/blogs/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div id="home-head">
    <div
        id="home-background"
        ref="homeBackground"
        data-images="/blogs/images/background.jpg"
    ></div>
    <div id="home-info" @click="homeClick">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>normal-pcer&#39;s blog</h1>
                <h3></h3>
                <h5></h5>
            </div>
        </span>
    </div>
</div>
<div
    id="home-posts-wrap"
    ref="homePostsWrap"
    true
>
    <div id="home-posts">
        

<div class="post">
    <a href="/blogs/uncategorized/2025/07/b5da511d8bf6/">
        <h2 class="post-title">C++ 基础知识指南</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/7/20
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>这篇专栏是写给 OIer（信息学竞赛生）的。但是，如果你已经了解了一些 C++
的基本语法，这篇专栏或许也能帮助到你。</p>
<p>C++
是许多信息学竞赛选手最熟悉的编程语言。日常训练中，我们可能只用到循环、数组这些基础功能，但这位朝夕相处的”老朋友”，其实藏着更多值得探索的奥秘。</p>
<p>也许你曾见过题解中神奇的语法”黑科技”，也许你被未定义行为导致的”玄学问题”困扰过，也许你面对突如其来的编译错误百思不得其解…</p>
<p>掌握这些知识，不会让你在赛场多拿几分，但能让你更加了解这个朝夕相处的代码伙伴。它们或许能帮你理解那些精妙的语言特性，或许能让你接触更现代的编程思维，又或许，只是满足你对技术世界的好奇心。</p>
<p>这个专栏并不是“语法大师课”，而是一次共同探索的旅程。我也只是一个 C++
初学者，尝试分享自己理解中的一些点滴。</p>
<p>我们将从基础出发，逐步走进 C++
的深处。虽然我的理解有限，无法覆盖那些艰深的内容。无论如何，都希望这些分享能为你打开一扇窗，了解一些可能平时了解不到的小知识，让你对这门语言多一分理解，这便是这篇专栏的最大意义。</p>
<h1 id="前置知识">前置知识</h1>
<p>在正式开始之前，先来了解一些相关的概念。</p>
<h2 id="编程工具">编程工具</h2>
<h3 id="编译器">编译器</h3>
<p>编译器是一种软件，负责将源代码编译成可执行文件。可执行文件（例如
Windows 系统的 exe 文件）可以被操作系统直接执行。</p>
<p>GCC（GNU Compiler Collection）是算法竞赛中最常用的 C++ 编译器。</p>
<p>代码编辑器负责帮助程序员编写代码。从定义上讲，记事本就可以算作编辑器。编辑器不负责代码的运行。</p>
<p>Sublime Text、Visual Studio Code 等都是常见的代码编辑器。</p>
<h3 id="集成开发环境">集成开发环境</h3>
<p>集成开发环境（IDE）是一种集成了多种功能的工具，通常包含代码编写、编译运行、调试等功能。现代的代码编辑器，通过插件通常也能实现类似
IDE 的功能。</p>
<h3 id="调试器">调试器</h3>
<p>调试器可以帮助开发人员调试代码，通常包含断点（在程序运行到某处时停止运行）、逐行调试、查看变量值、检查运行时错误位置等功能。</p>
<p>gdb 是一个常用的调试器，并且<strong>在 NOI Linux
的考试环境下可用</strong>。</p>
<h2 id="c-标准">C++ 标准</h2>
<p>C++ 语言一直在发布新的标准，从 2011 年开始，每 3
年都会发布一个新标准。</p>
<p>当前的 C++
标准有：C++98（C++03）、C++11、C++14、C++17、C++20、C++23，下一个标准是
C++26。</p>
<p>其中 C++03 只是在 C++98
的基础上做了简单的修订，并没有大幅度的更改。</p>
<p>本文讲述的内容，如果没有标注，默认是 C++98
就存在的。由于内容繁多，这部分标注可能存在遗漏，但是我会尽力保证所有
C++17 及以后的特性都标注出来（即不能在 NOI 系列考试中使用的）。</p>
<h2 id="编译器优化o2-优化">编译器优化（O2 优化）</h2>
<p>大多数的现代编译器都提供了优化选项。在代码不存在未定义行为的情况下，编译器优化选项可以保证程序行为正确，并且优化代码的运行速度。</p>
<p>常见的优化选项有
<code>-O0</code>（无优化）、<code>-O1</code>、<code>-O2</code>、<code>-O3</code>、<code>-Ofast</code>
等，优化效果通常是递增的。</p>
<p>很多情况下，一些简单的优化在开启优化选项 <code>-O2</code>
之后，都会被编译器自动完成（例如简单函数调用造成的开销，绝大多数情况下都会被内联）。</p>
<p>开启编译器优化后，可能让存在问题的代码行为变得奇怪，同时会影响调试器的使用。所以在调试时建议禁用优化。</p>
<p><strong>目前，在 CCF 组织的比赛中，均使用 C++14 标准，开启 O2
优化。</strong></p>
<h1 id="基础语法">基础语法</h1>
<h2 id="输入输出">输入输出</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">"Hello World!"</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>C++ 标准库中，主要有这几类输入输出方式：</p>
<ul>
<li>C
风格的输入输出：<code>scanf</code>，<code>printf</code>，<code>getchar</code>，<code>putchar</code>，<code>puts</code>
等。</li>
<li>C++ iostream：<code>cin</code>，<code>cout</code> 等。</li>
<li>C++23 print：<code>print</code>，<code>println</code> 等。</li>
</ul>
<p>在这些标准库提供的工具中，我最常用的是
iostream。它较为简单，并且可以保证类型安全，无需考虑占位符和实际类型的配套问题。而
C++23 的 print 尚未受到广泛支持。</p>
<p>iostream
采用重载的右移（有时又称“流输入”）和左移（“流输出”）运算符进行输入输出。代码如下：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x<span class="op">;</span>  <span class="co">// 输入</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x<span class="op">;</span>  <span class="co">// 输出</span></span></code></pre></div>
<p><code>cout</code>
可以通过输出一些操纵符，来进行一定程度的格式化输出。大多数操纵符在头文件
<code>iomanip</code> 中定义。例如，如下代码可以保留 2 位小数输出：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>fixed <span class="op">&lt;&lt;</span> <span class="bu">std::</span>setprecision<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="fl">3.1415</span><span class="op">;</span>  <span class="co">// 3.14</span></span></code></pre></div>
<p>执行以上代码以后，接下来所有的浮点数输出都会维持这样的格式。</p>
<p>iostream
最大的问题可能就是它在默认情况下效率很低。<strong>可以通过以下代码来加速</strong>：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ios::sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cin<span class="op">.</span>tie<span class="op">(</span><span class="kw">nullptr</span><span class="op">);</span></span></code></pre></div>
<p>这种方法通常叫做“关闭同步流”，可以大幅度提升 cin 和 cout 的速度。</p>
<p>第一行的原理是，默认情况下 C
风格的输入输出会维护一个缓冲区来加速（即内容不会立即输出到屏幕，而是存到缓冲区中，缓冲区满或者手动刷新再一次性输出）。而
iostream 为了和 C
兼容，会在每一次输入输出时都刷新缓冲区，导致额外开销。调用了
<code>ios::sync_with_stdio(false)</code> 之后就不会每次刷新了。</p>
<p>第二行的原理是，默认情况下 cin 会和 cout 互相绑定，在每次使用 cin
输入时都刷新 cout
的缓冲区。这样可以避免交替使用输入输出时的额外刷新开销。</p>
<p>由于 <code>endl</code> 会刷新缓冲区，使用 <code>'\n'</code> 而不是
<code>endl</code> 换行也会加速输出。</p>
<p>经过这样优化的 <code>cin</code> 和 <code>cout</code>，速度会略快于
<code>scanf</code> 和 <code>printf</code>。</p>
<p><strong>关闭同步流的情况下，iostream 和 C
风格输入输出不能混用</strong>。否则可能会导致多次输出的结果乱序。</p>
<p>有些时候，一些题目会要求输入不定量的信息。这种输入之所以可行，是因为从控制台输入信息，本质上是从一个虚拟的文件
<code>stdin</code> 输入。文件是有边界的，读到文件结尾就会获得 EOF
信息（End Of File），无法继续读入。</p>
<p><code>cin</code> 可以通过 <code>cin.good()</code>（返回
<code>true</code>/<code>false</code>）来判断是否处于正常状态。同时
<code>cin.eof()</code> 可以判断是否到达文件末尾，<code>cin.fail()</code>
和 <code>cin.bad()</code>
可以判断是否出现其他的问题，例如读入的整数超过类型上限，或者期望读入整数实际读到字母，将会使得
<code>cin.fail()</code> 返回 <code>true</code>。</p>
<p>如果 <code>cin.good()</code> 返回
<code>false</code>，此时将会拒绝接下来的读取操作（变量将会保持原值不被修改）。</p>
<p>在条件判断中，<code>cin</code> 对象可以隐式转换为布尔值，即
<code>cin.good()</code>。可以通过以下代码来持续读入整数直到文件末尾。在控制台中运行时，可以按下快捷键
Ctrl+Z（Windows）或者 Ctrl+D（Linux）并换行，来手动输入一个 EOF。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>cin <span class="op">&gt;&gt;</span> x<span class="op">)</span> <span class="op">{</span>  <span class="co">// cin/cout 输入输出之后返回自己</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="ch">' '</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="未定义行为和错误程序">未定义行为和错误程序</h2>
<p>接下来的代码中，将会涉及“未定义行为”及相关概念。可以参考 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/ub.html">cppreference</a>
页面。</p>
<p>C++ 的代码可能出现以下类型的错误：</p>
<ul>
<li><strong>非良构</strong>（ill-formed）。程序存在语法错误，或者可以诊断的语义错误。标准要求编译器对这种行为给出诊断信息，通常会导致编译错误。</li>
<li>非良构，但是不要求诊断（no diagnostic
required）。有些情况下，程序存在语义错误，但是错误可能在链接时才能发现，或者进行诊断需要的代价过大。这类程序被执行，行为是未定义的。</li>
<li><strong>实现定义行为</strong>（implementation-defined
behavior）。程序在不同的实现中（包括编译器、标准库实现、运行时环境等），可能会有不同的行为。但是符合标准的实现需要在文档中说明每种行为的实际效果。
<ul>
<li>例如，<code>long</code>
类型的大小是实现定义的。在常见的实现中，有些是 4 字节，有些是 8
字节。</li>
</ul></li>
<li><strong>未指定行为</strong>（unspecified
behavior）。程序行为在不同的实现中有所不同，并且实现不需要说明这些行为的效果。
<ul>
<li>例如，一些情况下的求值顺序，相同的字符串字面量是否指向不同地址。</li>
<li>不应该依赖未指定行为。</li>
</ul></li>
<li><strong>未定义行为</strong>（undefined behavior，简称
ub）。程序的行为将不受任何限制。
<ul>
<li>例如，数组的越界访问，有符号整数溢出，空指针解引用。</li>
<li>实现无需对未定义行为进行诊断（因为有些只能在运行时被发现）。</li>
<li><strong>未定义行为可能导致任何问题</strong>，编译器也可以基于“程序不存在未定义行为”的假设进行优化。</li>
<li>通常情况下，代码开启编译器优化前后行为不一致，就是由于存在未定义行为。</li>
</ul></li>
</ul>
<p>简单来讲，程序非良构通常会导致编译失败；未定义行为十分危险，必须避免；不应该依赖未指定行为；可以适当依赖实现定义行为。</p>
<p>以下是几个编译器依赖“不会出现未定义行为”，进行优化的例子：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span> <span class="op">&gt;</span> x<span class="op">;</span>  <span class="co">// 不溢出的情况下，整数 +1 一定大于自身</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 可能优化成：</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> <span class="va">f_</span><span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> g<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value <span class="op">=</span> <span class="op">*</span>ptr<span class="op">;</span>  <span class="co">// 已经进行解引用，基于 UB 假设一定不是空指针</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>ptr <span class="op">==</span> <span class="kw">nullptr</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> value<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="co">// 可能优化成：</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="va">g_</span><span class="op">(</span><span class="dt">int</span> <span class="op">*</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span>ptr<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="变量">变量</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> a <span class="op">&gt;&gt;</span> b<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> a <span class="op">+</span> b <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>C++
的“变量”（Variable）是通过标识符引用的对象（Object），指向一个内存中的存储单元，持有的值可以改变。变量几乎是一切数值计算的基础。这个最简单的“两数和问题”中，我们就使用了变量进行计算。</p>
<h3 id="变量名">变量名</h3>
<p>变量名必须是一个合法的“标识符”（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/identifiers.html">Identifier</a>）。即有以下的要求：</p>
<ul>
<li>首字符必须为英文字母 <code>A-Za-z</code> 或下划线
<code>_</code>，或其他具有 XID_Start 属性的 Unicode 字符。</li>
<li>其余字符必须为英文字母 <code>A-Za-z</code> 、数字
<code>0-9</code>或下划线 <code>_</code>，或其他具有 XID_Continue 属性的
Unicode 字符。</li>
</ul>
<p>值得注意的是，自 C++11
起，绝大多数语言中的字母（例如中文汉字），甚至表情符号，都是合法的标识符（即上文提到的
Unicode 字符）。GCC 编译器对该功能支持较晚，在 GCC10
以上的版本才可以使用。</p>
<p>除此以外，用户定义的标识符（变量、函数、类型等）不能与<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/keyword.html">关键字</a>完全相同。以双下划线开头（如
<code>__reserved</code>），或者单下划线紧跟大写字母开头（如
<code>_Reserved</code>），行为是未定义的。</p>
<h3 id="变量作用域">变量作用域</h3>
<p>变量的作用域主要分为局部作用域和命名空间作用域等。</p>
<p>在函数等花括号（<code>{}</code>）包裹的代码块中定义的变量，具有局部作用域。局部作用域的变量，自声明后开始可见，直到代码块结束。</p>
<p>在命名空间中声明的变量，具有命名空间作用域。这类变量自声明后开始，在命名空间内始终可见，或者通过命名空间名来访问（<code>ns::name</code>）。全局作用域可以看作一个特殊的命名空间作用域，它自声明后开始，在全局内始终可见。</p>
<p>不同作用域的同名变量存在“遮蔽”原则，<strong>内层作用域的同名变量会隐藏外层作用域的变量</strong>。</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// 全局变量</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span> <span class="co">// 输出 0</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// 局部变量将会遮蔽全局的 x</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span> <span class="co">// 输出 1</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="op">::</span>x <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span> <span class="co">// 可以通过 ::x 强制指定全局作用域的 x，输出 0</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>可以根据以上代码理解这些原则。</p>
<p>类型、函数等的作用域规则，也和变量相同。</p>
<h4 id="命名空间">命名空间</h4>
<p>命名空间（namespace）是 C++
中用来避免命名冲突的机制，不同命名空间内的变量可以重名。变量、函数、类型等，都可以通过命名空间来组织。</p>
<p>访问一个命名空间内的内容，需要使用作用域解析运算符
<code>::</code>。例如上文的 <code>std::cout</code> 就是在访问
<code>std</code> 命名空间的 <code>cout</code> 对象。</p>
<p>可以使用 <code>using</code> 语句，引入一个命名空间中的名字。使用
<code>using namespace</code> 引入所有名字。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> A <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value<span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> test<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> B <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value<span class="op">;</span>  <span class="co">// 不会发生重名</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> number<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> example<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> A<span class="op">::</span>test<span class="op">;</span>  <span class="co">// 接下来使用 test 可以不指定命名空间</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> B<span class="op">;</span>  <span class="co">// 同时引入 B::value, B::number, B::example</span></span></code></pre></div>
<p>命名空间可以嵌套，使用 <code>std::ranges::sort</code>
这样的方式访问。可以用以下方式创建命名空间别名。</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> rg <span class="op">=</span> <span class="bu">std::</span>ranges<span class="op">;</span></span></code></pre></div>
<p>C++ 的所有标准库对象，都存在于 <code>std::</code> 命名空间中。C
标准库函数（如 <code>printf</code>）在全局和 <code>std</code>
命名空间中均存在，但是部分函数（尤其是 cmath
中的）会存在少量差异。所以在没有 <code>using namespace std;</code>
的情况下，<strong>建议始终使用 <code>std::</code>
版本来保证安全</strong>。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;cmath&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> x <span class="op">=</span> <span class="op">-</span><span class="dv">5</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> x1 <span class="op">=</span> abs<span class="op">(</span>x<span class="op">);</span>  <span class="co">// int</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> x2 <span class="op">=</span> <span class="bu">std::</span>abs<span class="op">(</span>x<span class="op">);</span>  <span class="co">// long long</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="存储期">存储期</h3>
<p>存储期（Storage
duration）指定了一个对象的生命周期，即在何时被销毁并回收资源。变量的存储期由定义的方式决定。</p>
<p>C++ 有以下的几种存储期：</p>
<ul>
<li>自动存储期。这是局部变量的默认存储期，会在离开自己的作用域后自动销毁。</li>
<li>静态存储期。这是命名空间作用域（包括全局作用域）变量的默认存储期，在程序结束后销毁。</li>
<li>动态存储期。通过 <code>new</code>、<code>malloc</code>
等方式在堆空间动态分配对象的属于动态存储期，需要通过配对的解分配函数来销毁。</li>
<li>线程存储期。对于多线程程序，这类对象对每一个线程都会有一个独立的值，生命周期与这个线程相同。</li>
</ul>
<p>简单来讲，只需要记住以下规则：</p>
<ul>
<li>自动存储期（局部变量），在离开作用域的时候（对应的右花括号）立即销毁，不占用更多内存。</li>
<li>静态存储期（全局/命名空间变量，或显式声明
static），在程序结束时统一销毁。</li>
<li>还有动态存储期、线程存储期，分别有各自的用途。</li>
<li>默认情况下下，自动存储期的变量大小有限（栈空间），但是竞赛场景通常会主动放开限制，不需要在意。</li>
</ul>
<p>有对应的说明符可以指定存储期。</p>
<ul>
<li><code>auto</code>：<strong>C++11
起含义改变</strong>。此前表示自动存储期。</li>
<li><code>register</code>：<strong>在 C++14 起被弃用、C++17
起被移除</strong>。此前用于请求编译器把这个值存储在寄存器中，这个请求可以被忽略。</li>
<li><code>static</code>：静态存储期。</li>
<li><code>thread_local</code>：线程存储期。</li>
<li><code>extern</code>：用于声明一个变量（而不是定义），链接到一个外部的来源。</li>
</ul>
<p><code>mutable</code> 关键字在 cppreference
中被归类为存储说明符，但是实际不会影响存储期，所以不在此讲述。</p>
<p>尽管 <code>register</code> 关键字直到 C++17
才被移除，但是即使在更早的标准中，编译器通常也会忽略它。不要试图使用这个关键字优化性能，这不会有任何作用。</p>
<p>自动存储期的对象将会存储在“栈空间”中，栈空间的容量有限（通常为
8MB），所以定义一些较大的数组，或者递归层数过深，都可能会出现“爆栈”的问题。但是<strong>大部分
OJ 和比赛环境</strong>，包括 CCF
组织的比赛中，<strong>允许程序使用无限的栈空间</strong>（即与程序总体内存限制相等），这些情况下可以放心使用局部数组和递归（局部数组需要手动初始化，推荐直接使用值初始化形式
<code>int a[maxN]{}</code>）。</p>
<p>如果想要设置无限栈空间，可以通过如下方式：</p>
<ul>
<li>对于 Windows 系统，编译选项（GCC 为例）添加
<code>-Wl,-stack=2147483647</code>。</li>
<li>对于 Linux 系统，运行程序前在终端执行
<code>ulimit -s unlimited</code>。</li>
</ul>
<p>全局或命名空间作用域的静态变量，将会在调用主函数之前进行初始化。</p>
<p>可以在局部作用域中通过 <code>static</code>
关键字来定义一个静态变量，这个变量将仅会在第一次运行到定义处的时候进行一次初始化，接下来<strong>每次使用都会保有一个相同的值</strong>。可以结合以下代码理解。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    count<span class="op">++;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> count <span class="op">&lt;&lt;</span> <span class="ch">' '</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 静态变量的值不会被清除</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    f<span class="op">();</span> f<span class="op">();</span> f<span class="op">();</span> <span class="co">// 输出 1 2 3</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="变量初始化">变量初始化</h3>
<p>定义一个变量的同时会进行初始化，赋予其一个初始值。C++
的变量初始化规则十分复杂，接下来我们将会进行一些简单的讲解。</p>
<p>本章节中可能会涉及一些后续章节才出现的知识。如果出现了你不理解的内容，可以暂时忽略。</p>
<h4 id="核心规则概括">核心规则概括</h4>
<p>核心规则可以大致概括为：</p>
<ul>
<li>零初始化：逐位赋值为 0，全局/静态变量自动执行。</li>
<li>默认初始化 <code>int x</code>：
<ul>
<li>类类型（<code>string</code>、<code>set</code>、<code>vector</code>
等），调用默认构造函数。</li>
<li>基本类型，<strong>局部变量的值不确定</strong>，全局/静态变量预先零初始化为
0。</li>
<li>自定义结构体，如果没有提供默认值，默认初始化也是不安全的。</li>
</ul></li>
<li>值初始化 <code>int x{}</code>：
<ul>
<li>基本类型，初始化为 0。</li>
<li>类类型，调用默认构造。</li>
<li>通常是最安全的初始化方式。</li>
</ul></li>
<li>直接初始化 <code>int x(5)</code>：
<ul>
<li>直接调用匹配的构造函数。</li>
</ul></li>
<li>复制初始化 <code>int x = 5</code>：
<ul>
<li>实际行为通常与直接初始化一致。</li>
<li>禁用 <code>explicit</code> 构造函数。</li>
<li>经过编译器优化，不会有额外的复制。</li>
</ul></li>
<li>列表初始化 <code>int x{5}</code>：
<ul>
<li>优先匹配接受 <code>std::initializer_list</code> 的构造函数。</li>
<li>禁止窄化转换。</li>
</ul></li>
</ul>
<h4 id="零初始化">零初始化</h4>
<p>零初始化（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/zero_initialization.html">Zero-Initialization</a>）是将对象逐位赋值为
0 的初始化方式。C++
中没有专用的零初始化语法，但是其他初始化方式可能包含零初始化。</p>
<p><strong>所有具有静态存储期的变量</strong>，将会在进行其他初始化之前，先进行一次零初始化。平时常见的结论“全局变量会自动赋值为
0”就是来自这条规则。</p>
<h4 id="默认初始化">默认初始化</h4>
<p>默认初始化（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/default_initialization.html">Default-Initialization</a>）是在没有指定初始化器时的初始化方式。例如以下场景将会执行默认初始化：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">*</span>ptr <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">;</span></span></code></pre></div>
<p>另外，在类的构造函数中，没有在初始化列表中提及的成员，也会执行默认初始化。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>A p<span class="op">;</span>  <span class="co">// p.data 将会执行默认初始化</span></span></code></pre></div>
<p>对类型 <code>T</code> 进行默认初始化的效果如下：</p>
<ul>
<li>如果 <code>T</code> 是类类型（Class Type，由
<code>class</code>、<code>struct</code> 或 <code>union</code>
关键字定义的类型），则调用默认构造函数（空参数列表），为对象提供初始值。</li>
<li>如果 <code>T</code>
是数组类型，对数组的每个元素进行默认初始化。</li>
<li>否则，<strong>不额外执行初始化</strong>。</li>
</ul>
<p><strong>对象在未执行初始化的情况下，将会持有一个不确定的值</strong>，直到这个值被替换。使用这个不确定的值进行任何求值操作，都是未定义行为。</p>
<p>但是由于静态存储期的对象会预先进行一次零初始化，所以这种写法对它们是安全的。</p>
<p>C++26 起规定，对于一个自动存储期的变量，并且没有被标识
<code>[[indeterminate]]</code>，将会有以下行为：</p>
<ul>
<li>构成该对象存储的所有字节，填充一个错误值。这个错误值由实现定义，但是与程序状态无关。</li>
<li>如果使用错误值进行求值操作，则行为是错误行为（Erroneous
Behavior）。错误行为仍然应该被视作不正确的结果，但是标准建议实现对错误行为进行诊断，而非像未定义行为一样假设不会存在并促进优化。</li>
</ul>
<p>C++26
引入的错误填充值，往往会导致未初始化的对象拥有一个异常值（例如无效指针，或者绝对值很大的整数和浮点数），避免由于“不确定值”有时恰好符合期望，而产生偶发性的错误。</p>
<p><code>const</code> 对象不允许默认初始化。</p>
<h4 id="值初始化">值初始化</h4>
<p>值初始化（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_initialization.html">Value-Initialization</a>）在使用空初始化器构造对象时执行，以下是几种常见的场景：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">{};</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">*</span>ptr <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">();</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="dt">float</span><span class="op">()</span> <span class="co">/*构造临时对象*/</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> arr<span class="op">[</span><span class="dv">100</span><span class="op">]{};</span></span></code></pre></div>
<p>下文中用 <code>T</code> 代指对象类型。</p>
<p>有以下特例：</p>
<ul>
<li>如果 <code>T</code>
是聚合类型（见下文“聚合初始化”），那么执行聚合初始化。但是这种情况下聚合初始化的行为与值初始化的效果是一致的。</li>
<li>如果 <code>T</code> 没有默认构造函数，但是有一个接收
<code>std::initializer_list</code> 的构造函数，那么执行列表初始化。</li>
</ul>
<p>值初始化的效果如下：</p>
<ul>
<li>如果 <code>T</code> 是类类型，那么：
<ul>
<li>如果它的默认构造函数不是用户提供的（即自动生成），先执行零初始化。</li>
<li>接下来，执行默认初始化。</li>
</ul></li>
<li>否则，如果 <code>T</code> 是数组类型，值初始化每个元素。</li>
<li>否则，对象将会被零初始化。</li>
</ul>
<p>值初始化在大多数情况下可以保证所有元素被正确初始化（一个反例为上文“默认初始化”章节的
<code>p.data</code>）。</p>
<h4 id="聚合初始化">聚合初始化</h4>
<p>聚合初始化（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/aggregate_initialization.html">Aggregate-Initialization</a>）是通过初始化列表来初始化聚合类型的过程。这是一种特殊的列表初始化。</p>
<h5 id="聚合类型">聚合类型</h5>
<p>聚合类型（Aggregate）是以下类型之一：</p>
<ul>
<li>数组类型</li>
<li>符合以下要求的类类型
<ul>
<li>没有用户声明或继承的构造函数。（C++20
起，此前的要求类似，但是略有不同）</li>
<li>没有私有（private）或受保护（protected）的非静态数据成员。</li>
<li>没有虚基类（virtual），没有私有或受保护的基类。（C++17
起，此前要求没有任何基类）</li>
<li>没有虚成员函数。</li>
<li>C++11 及以前的版本，还要求没有默认成员初始化器（Default Member
Initializers，即在声明成员的同时赋默认值）。</li>
</ul></li>
</ul>
<h5 id="指派初始化器">指派初始化器</h5>
<p>C++20 引入了指派初始化器（Designated
Initializers），可以通过成员名称和目标值之间的键值对来进行聚合初始化。</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span> <span class="dt">int</span> a<span class="op">;</span> <span class="dt">double</span> b<span class="op">;</span> <span class="op">};</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>A a<span class="op">{.</span>a <span class="op">=</span> <span class="dv">5</span><span class="op">,</span> <span class="op">.</span>b <span class="op">=</span> <span class="fl">9.0</span><span class="op">};</span>  <span class="co">// 指派初始化器</span></span></code></pre></div>
<h5 id="窄化转换">窄化转换</h5>
<p>窄化转换是有潜在精度丢失的转换方式。目标类型不能存储源类型的所有值时，视为窄化转换（例如
<code>double</code> 到 <code>int</code>，<code>long long</code> 到
<code>int</code>）。</p>
<p>在标准禁止窄化转换的操作中，部分编译器可能实现为仅视为警告，不拒绝编译。</p>
<h5 id="初始化流程">初始化流程</h5>
<p>聚合初始化可以分为显式初始化（explicit）和隐式初始化（implicit）。</p>
<p>首先，确定需要显式初始化的元素：</p>
<ul>
<li>如果初始化列表是指派初始化器，则包含对应的所有成员。</li>
<li>否则，按照声明顺序包含最靠前的若干个元素。如果一个成员
<code>x</code> 也是聚合体，并且实际传入的值不是聚合体，将会进一步匹配
<code>x</code> 的全体成员，再对 <code>x</code>
进行聚合初始化，减少一层花括号嵌套。</li>
</ul>
<div class="sourceCode" id="cb18"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> z <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>A arr<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span>  <span class="co">// 相当于 {{0, 1, 2}, {3, 4, 5}}</span></span></code></pre></div>
<p>如果 <code>T</code>
为联合体（union），包含超过一个显式初始化的元素，程序非良构；若是使用指派初始化器，则只能指定一个成员。</p>
<p>接下来，按照声明顺序初始化这些选中的元素。初始化每个成员时相当于使用复制初始化。</p>
<p>接下来，如果 <code>T</code>
不是联合体，每个未显式初始化的成员按照以下方式隐式初始化：</p>
<ul>
<li>如果这个元素有默认成员初始化器，从初始化器初始化它。</li>
<li>否则，如果元素不是引用，从空的初始化列表对它进行拷贝初始化（多数情况下等价于值初始化）。</li>
<li>否则，程序非良构。</li>
</ul>
<p>特别地，通过字符串字面量初始化一个字符数组，也属于聚合初始化。允许的字符类型有：<code>char</code>（或
<code>signed</code> 和 <code>unsigned</code>
变种）、<code>wchar_t</code>、<code>char16_t</code>（C++11
起）、<code>char32_t</code>（C++11 起）和 <code>char8_t</code>（C++20
起）。数组过长的部分将用 0 填充。</p>
<p>聚合初始化的过程中，不允许对参数进行窄化转换。</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> s<span class="op">[</span><span class="dv">30</span><span class="op">]{</span><span class="st">"This is a C-style string."</span><span class="op">};</span></span></code></pre></div>
<h4 id="列表初始化">列表初始化</h4>
<p>通过花括号包裹的初始化列表初始化对象的方式，叫做列表初始化（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/list_initialization.html">List-Initialization</a>）。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> p <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span></code></pre></div>
<p>类似以上方式的初始化，属于列表初始化。</p>
<p>上下两种方式，以语义上是否需要紧跟一次复制为分别，又称为“复制列表初始化”和“直接列表初始化”。例如，向函数参数传递一个初始化列表，或者将初始化列表作为返回值，都属于“复制列表初始化”。经过编译器优化，这种方式通常不会有额外的复制开销，</p>
<p>复制列表初始化，不会调用标记为 <code>explicit</code> 的构造函数。</p>
<p>列表初始化有以下的流程：</p>
<ul>
<li>如果初始化列表是指派初始化器，执行聚合初始化。</li>
<li>如果 <code>T</code>
为聚合类型，并且初始化列表提供了一个同类型的对象，则从这个对象初始化。（依据自身类别进行复制初始化/直接初始化）</li>
<li>如果 <code>T</code>
为字符数组，且用花括号括起来一个对应的字符串字面量，则由这个字符串进行聚合初始化。</li>
<li>如果 <code>T</code> 为聚合类型，执行聚合初始化。</li>
<li>如果初始化列表为空，且 <code>T</code>
为存在默认构造函数的类类型，执行值初始化。</li>
<li>如果 <code>T</code> 为 <code>std::initializer_list</code>
的特化，逐个成员复制初始化。</li>
<li>如果 <code>T</code> 为类类型，考虑其构造函数：
<ul>
<li>接受单个 <code>std::initializer_list</code>
参数的构造函数，优先调用。</li>
<li>对于初始化列表中指定的参数执行重载决议，寻找最佳匹配的构造函数。</li>
</ul></li>
<li>否则（<code>T</code> 不是类类型），并且初始化列表中只有一项，并且
<code>T</code> 不是引用，或者 <code>T</code>
是兼容的引用（同类型或是其基类），则从这个对象初始化，但是不允许窄化转换。</li>
<li>否则，如果 <code>T</code>
是不兼容的引用类型，将会通过复制列表初始化创建一个 <code>T</code>
所引用类型的临时量，然后引用绑定到这个临时对象。如果 <code>T</code> 是非
<code>const</code> 的左值引用，那么操作失败。</li>
<li>否则，如果初始化列表为空，执行值初始化。</li>
</ul>
<p>初始化列表中，求值顺序是固定的从前到后。相对地，<strong>函数调用的参数求值顺序是不固定的</strong>。</p>
<h5 id="stdinitializer_list">std::initializer_list</h5>
<p><code>std::initializer_list</code>
可以存储若干个类型相同的对象。列表初始化中，将会优先使用接受
<code>std::initializer_list</code> 的构造函数。</p>
<p>例如，通过花括号初始化存在若干个初始元素的
<code>std::vector</code>，就是通过
<code>std::initializer_list</code>。</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span></code></pre></div>
<h4 id="复制初始化">复制初始化</h4>
<p>复制初始化（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/copy_initialization.html">Copy-Initialization</a>）指从另一个对象初始化一个对象，在语义上应该发生复制。</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>x<span class="op">);</span>  <span class="co">// 函数调用时也是复制初始化</span></span></code></pre></div>
<ul>
<li>如果初始化器的类型为 <code>T</code>，调用 <code>T</code>
的构造函数。</li>
<li>初始化器类型与 <code>T</code> 无关，则尝试调用：
<ul>
<li>初始化器类型的转换函数，转换为 <code>T</code> 或派生类。</li>
<li><code>T</code> 的构造函数，接受初始化器类型。</li>
</ul></li>
<li>尝试应用标准转换。</li>
</ul>
<p>复制初始化中，不会使用任何标记为 <code>explicit</code>
的构造函数。有些情况下的复制往往可以被编译器优化掉，转换成直接在目标位置构造对象。</p>
<p>C++17
起，标准强制要求进行复制消除，即初始化器为函数返回值这样的纯右值时，一定不会进行额外的复制。此前的编译器往往也会做这样的优化。</p>
<h4 id="直接初始化">直接初始化</h4>
<p>直接初始化（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/direct_initialization.html">Direct-Initialization</a>）通过指定的参数调用构造函数，初始化对象。</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">(</span><span class="co">/*n:*/</span><span class="dv">10</span><span class="op">,</span> <span class="co">/*default:*/</span><span class="dv">2</span><span class="op">);</span></span></code></pre></div>
<p>直接初始化的效果如下：</p>
<ul>
<li>如果 <code>T</code> 是数组类型：
<ul>
<li>C++20
起，数组按照聚合初始化的方式进行初始化，但允许进行窄化转换，并且任何没有初始化器的元素将进行值初始化。</li>
</ul></li>
<li>如果 <code>T</code> 是类类型：
<ul>
<li>C++17 起，标准规定实现类似复制初始化的“复制省略”机制，如果参数是
<code>T</code> 的纯右值，直接使用初始化器本身初始化目标对象。</li>
<li>检查 <code>T</code> 的构造函数，通过重载决议决定最佳匹配项。</li>
<li>C++20 起，如果 <code>T</code>
是聚合类型，使用类似聚合初始化的方式进行初始化。但是存在以下区别：允许窄化转换，不存在花括号省略机制，没有初始化器的元素将会执行值初始化。</li>
</ul></li>
<li>否则（<code>T</code>
不是类类型），源类型是一个类类型，则会检查其转换函数。</li>
<li>否则，如果 <code>T</code> 为 <code>bool</code> 且源类型为
<code>std::nullptr_t</code>，初始化对象为 <code>false</code>。</li>
<li>尝试应用标准转换。</li>
</ul>
<p>以下的写法是错误的，因为会和函数声明混淆。这通常可以使用空的花括号代替。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector vec<span class="op">(</span><span class="co">/*参数列表为空*/</span><span class="op">);</span></span></code></pre></div>
<h3 id="cv-限定符常量性易变性">cv 限定符（常量性、易变性）</h3>
<p>类型可以通过 <code>const</code> 和 <code>volatile</code>
修饰，获得常量性或者易变性。修饰符不会影响对象的底层表示、对齐要求等。</p>
<p>数组类型与它的元素拥有相同的 cv 限定符。</p>
<p>对象具有的 cv 限定符，也会给予它的成员。被声明为 <code>mutable</code>
的成员除外，它不会继承对象的常量性。</p>
<h4 id="常量性const">常量性（const）</h4>
<p><strong>具有常量性的对象不能被修改</strong>。直接修改会导致编译错误，而间接修改（例如通过
<code>const_cast</code>
获得非常量指针，或者直接修改底层内存）<strong>会导致未定义行为</strong>。</p>
<p>以下代码定义了一个 const 的整数变量。</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 可以正常读取</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span>  <span class="co">// 编译错误，不能修改 const 变量</span></span></code></pre></div>
<h4 id="易变性volatile">易变性（volatile）</h4>
<p>具有易变性的对象，每次读写都要求立即和内存同步，禁止编译器进行缓存、指令重排等优化。在涉及信号处理、系统中断、直接操作内存等情况下需要用到。编译器会假设代码始终单线程执行，从而在一些情况下，可能导致意料之外的优化。</p>
<h2 id="类型">类型</h2>
<h3 id="基本类型">基本类型</h3>
<p>C++ 的基本类型，主要有整数类型、浮点数类型等数值类型。</p>
<h4 id="整数类型">整数类型</h4>
<p>有以下对于整数类型的长度修饰符。长度修饰符的效果由实现定义，但是需要满足一定要求。</p>
<table>
<thead>
<tr>
<th>长度修饰符</th>
<th>要求</th>
</tr>
</thead>
<tbody>
<tr>
<td>short</td>
<td>不小于 16 位</td>
</tr>
<tr>
<td>(无)</td>
<td>不小于 16 位</td>
</tr>
<tr>
<td>long</td>
<td>不小于 32 位</td>
</tr>
<tr>
<td>long long</td>
<td>不小于 64 位</td>
</tr>
</tbody>
</table>
<p>完整的整数类型包含以下部分：</p>
<table>
<colgroup>
<col style="width: 14%">
<col style="width: 85%">
</colgroup>
<thead>
<tr>
<th>组成部分</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>长度修饰符</td>
<td>指定数字位数要求</td>
</tr>
<tr>
<td>符号标识符</td>
<td>指定数字有符号（<code>signed</code>）/无符号（<code>unsigned</code>），不填为有符号</td>
</tr>
<tr>
<td><code>int</code></td>
<td>如有其他的单词描述，可以省略</td>
</tr>
</tbody>
</table>
<p>这几个部分的顺序可以交换，<code>signed short int</code>、<code>long long unsigned int</code>、<code>long int signed</code>
都是合法的。</p>
<p>除了以上的标准整数类型，还有以下的整数类型：</p>
<ul>
<li>布尔类型 <code>bool</code>。</li>
<li>字符类型。
<ul>
<li><code>signed char</code>，<code>unsigned char</code>。</li>
<li><code>char</code>。以上三个类型的长度相同，但是始终是三个不同类型。<code>char</code>
是否有符号由实现定义。</li>
<li><code>wchar_t</code>，<code>char16_t</code>（C++11
起），<code>char32_t</code>（C++11 起），<code>char8_t</code>（C++20
起）。</li>
</ul></li>
<li>扩展整数类型。
<ul>
<li>GCC 扩展的 <code>__int128</code> 就是扩展整数类型。</li>
</ul></li>
</ul>
<p>此外，标准保证 <code>sizeof(char)</code> 为 1，且
<code>sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)</code>。<code>sizeof</code>
返回值的单位为字节，字节的位数由实现定义，但是绝大多数情况下都是 8
位。</p>
<h4 id="浮点数类型">浮点数类型</h4>
<ul>
<li><code>float</code>。单精度浮点数，通常为 IEEE-754 binary32
格式。</li>
<li><code>double</code>。双精度浮点数，通常为 IEEE-754 binary64
格式。</li>
<li><code>long double</code>。扩展精度浮点数。</li>
<li>由实现定义的扩展浮点数类型。</li>
</ul>
<p>浮点数不一定映射到 IEEE-754
规定类型。它的精度和占用空间都是实现定义的。大多数实现下，<code>float</code>
和 <code>double</code> 都是遵循 IEEE-754 的规定，而
<code>long double</code> 的实现则更加多样。</p>
<p>一种典型的情况下，<code>long double</code> 占用 16
字节的空间，但是有效数据只有 80bit（二进制位）。</p>
<h3 id="类型转换">类型转换</h3>
<p>C++ 的类型转换分为隐式（implicit）和显式（explicit）两种。</p>
<h4 id="隐式类型转换">隐式类型转换</h4>
<p>当一个类型在上下文中不适用，但是可以转化为一种合适的类型时，就会发生隐式类型转换。</p>
<p>例如希望给一个 <code>bool</code> 类型的变量赋值，但是传入了一个
<code>int</code>，就会出现一次隐式转换（0 变为 <code>false</code>，非 0
值变为 <code>true</code>）。</p>
<p>隐式类型转换可以由以下的步骤组成：</p>
<ul>
<li>零个或一个标准转换序列。</li>
<li>零个或一个用户定义的转换。</li>
<li>如果使用了用户定义的转换，还可以接受零个或一个标准转换序列。</li>
</ul>
<p>不允许连续两次标准转换序列，例如 <code>nullptr</code> 不能通过 0
作为中转，转换为 <code>bool</code> 类型。</p>
<p>传递给构造函数的参数，或者在两个非类类型之间转换，只允许标准转换。</p>
<p>一个标准转换序列，包括以下组成部分：</p>
<ul>
<li>从以下集合中选择零个或一个转换：
<ul>
<li>左值到右值转换。</li>
<li>数组到指针转换。</li>
<li>函数到指针转换。</li>
</ul></li>
<li>零次或一次数值提升或数值转换。</li>
<li>零次或一次函数指针转换。</li>
<li>零次或一次限定符转换。</li>
</ul>
<p>用户定义的转换，包含接受单个参数的构造函数，或者转换函数。但是二者都不能标记为
<code>explicit</code>。例如以下代码可以支持 <code>int</code> 到
<code>A</code>、<code>A</code> 到 <code>bool</code> 的隐式类型转换。</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value<span class="op">{};</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> x<span class="op">):</span> value<span class="op">(</span>x<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">operator</span> <span class="dt">bool</span><span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> value <span class="op">!=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>A a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> flag <span class="op">=</span> a<span class="op">;</span></span></code></pre></div>
<h5 id="值类别">值类别</h5>
<p>在上文中提到了左值和右值的概念，我们在此处先简单地介绍一下。</p>
<p>C++
的表达式分为<strong>纯右值</strong>（prvalue）、<strong>将亡值</strong>（xvalue）和<strong>左值</strong>（lvalue）这三大类。这里只介绍纯右值和左值，将亡值和“右值引用”章节有关。</p>
<p>左值和右值，这个名称最初的意味是“左值可以出现在赋值运算符的左侧”。尽管现在不是这样，在某些情况下，左值有可能无法赋值，右值有可能允许赋值。</p>
<p>左值用于确定一个已经被存储的特定对象。例如变量
<code>a</code>，数组访问 <code>arr[0]</code> 都是左值。</p>
<p>纯右值是没有持久存储的临时值，例如：</p>
<ul>
<li>字面量，如
<code>1</code>，<code>3.4</code>，<code>'c'</code>。（字符串字面量除外）</li>
<li>算术表达式结果，如 <code>a + b</code>。</li>
<li>函数调用结果（不返回引用），如 <code>std::sqrt(4)</code>。</li>
</ul>
<h5 id="实例">实例</h5>
<p>例如以下代码：</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> value<span class="op">{};</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>        A<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>        A<span class="op">(</span><span class="dt">int</span> value<span class="op">):</span> value<span class="op">(</span>value<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">operator</span> <span class="dt">int</span> <span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> value <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    A a<span class="op">{</span><span class="dv">5</span><span class="op">};</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> flag <span class="op">=</span> a<span class="op">;</span></span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>以上代码 <code>bool flag = a</code> 一句，通过以下途径转换：</p>
<ul>
<li>一个标准转换序列。包含左值到右值的转换。</li>
<li>一个用户定义的转换。调用转换函数 <code>operator int</code>。</li>
<li>一个标准转换序列。包含 <code>int</code> 到 <code>bool</code>
的数值转换。</li>
</ul>
<h5 id="上下文相关转换">上下文相关转换</h5>
<p>一些语境下期望的类型为
<code>bool</code>，此时进行隐式类型转换，效果相当于显式类型转换
<code>static_cast&lt;bool&gt;(x)</code>。</p>
<ul>
<li><code>if</code>、<code>while</code>、<code>for</code>
的条件表达式。</li>
<li><strong>内置运算符</strong>
<code>!</code>、<code>&amp;&amp;</code>、<code>||</code> 的操作数。</li>
<li>条件运算符 <code>?:</code> 的第一个操作数。</li>
<li><code>static_assert</code>、<code>noexcept</code>、<code>explicit</code>
的条件表达式。</li>
</ul>
<p>一个典型的案例是，<code>if (cin &gt;&gt; x)</code>
这个语句可以成立，此处 <code>cin</code> 被转换为了 <code>bool</code>
类型，属于上下文相关转换。在一般的语境下，这个隐式转换是无法达成的（使用了
<code>explicit</code> 转换函数）。</p>
<h4 id="显式类型转换">显式类型转换</h4>
<p>C++ 中的显式类型转换，通过以下几类关键字进行。将 <code>x</code>
转换为 <code>T</code> 类型的方法是
<code>static_cast&lt;T&gt;(x)</code>（或使用其他关键字）。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/static_cast.html">static_cast</a>，适用于一些较为安全的转换，例如：
<ul>
<li>基础类型间的数值转换。</li>
<li>基类、派生类指针之间互相转化。</li>
<li><code>static_cast&lt;void&gt;</code> 用来丢弃一个值。</li>
<li>调用构造函数、转换函数。（允许使用 <code>explicit</code>）</li>
</ul></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/reinterpret_cast.html">reinterpret_cast</a>，根据底层内存重新解释对象，例如：
<ul>
<li>指针和整数互相转换。</li>
<li>无关类型的指针之间互相转化（不能移除
<code>const</code>/<code>volatile</code>）。</li>
</ul></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/const_cast.html">const_cast</a>，适用范围：
<ul>
<li>对于带有 <code>const</code>/<code>volatile</code>
修饰类型的指针，可以移除修饰符。</li>
</ul></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dynamic_cast.html">dynamic_cast</a>，适用于多态类型带有运行时检查的转换。此处不做提及。</li>
</ul>
<p>滥用 <code>reinterpret_cast</code> 和 <code>const_cast</code>
极易引起未定义行为。原对象为 <code>const</code> 时，通过
<code>const_cast</code> 去除 const
修饰符之后再修改，<strong>仍然属于未定义行为</strong>。它通常只能用于和接受非常量指针的函数交互，并且可以保证不会真的修改传入内容。</p>
<p><code>reinterpret_cast</code>
可以获得任意类型的指针，但是对这个指针进行解引用，必须保证<strong>目标类型有合适的可访问性</strong>，否则<strong>仍然属于未定义行为</strong>。<code>T</code>
只能通过以下的类型被访问：</p>
<ul>
<li><code>T</code> 本身。</li>
<li>如果 <code>T</code> 为整数类型，<code>T</code>
对应的有符号/无符号版本。</li>
<li><code>char</code>、<code>unsigned char</code>、<code>std::byte</code>。这允许通过字符数组来观察对象在内存中的表示。</li>
</ul>
<p>例如：</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> u64 <span class="op">=</span> <span class="bu">std::</span>uint64_t<span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>u64 x1 <span class="op">=</span> <span class="op">*</span><span class="kw">reinterpret_cast</span><span class="op">&lt;</span>u64 <span class="op">*&gt;(&amp;</span>x<span class="op">);</span>  <span class="co">// UB</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>u64 x2<span class="op">;</span> <span class="bu">std::</span>memcpy<span class="op">(&amp;</span>x2<span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>u64<span class="op">));</span>  <span class="co">// memcpy 逐字节复制是安全的</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>u64 x3 <span class="op">=</span> <span class="bu">std::</span>bit_cast<span class="op">&lt;</span>u64<span class="op">&gt;(</span>x<span class="op">);</span>  <span class="co">// std::bit_cast 是 C++20 引入的安全转换方式</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="kw">union</span> <span class="op">{</span> u64 <span class="va">int_</span><span class="op">;</span> <span class="dt">double</span> <span class="va">double_</span><span class="op">;</span> <span class="op">}</span> tmp<span class="op">;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>tmp<span class="op">.</span><span class="va">double_</span> <span class="op">=</span> x<span class="op">;</span> u64 x4 <span class="op">=</span> tmp<span class="op">.</span><span class="va">int_</span><span class="op">;</span> <span class="co">// UB；union 不可以访问错误成员</span></span></code></pre></div>
<p>使用括号包裹一个类型名，随后接一个表达式，叫做 C 风格类型转换。C
风格转换支持上述所有的转换方式。现在 C++
中，出于安全性考虑，<strong>不推荐使用这种类型转换</strong>。例如
<code>(int)3.0</code>、<code>(double)(a + b)</code>。</p>
<p>一些类型后可以接一个括号，传入参数进行类型转换。这种转换方式本质上是对象的直接初始化，但有时会被称为“函数式转换”。例如
<code>char(32)</code>，<code>std::string("test")</code>。</p>
<h3 id="类型别名">类型别名</h3>
<p>C++
中，可以为类型声明别名，用于简化代码。类型别名和原类型在各种方面都是完全相同的，不会创建新的类型。</p>
<h4 id="using-类型别名"><code>using</code> 类型别名</h4>
<p>C++11 引入了 <code>using</code>
关键字作为声明类型别名的含义，这也是现在 C++
推荐的声明方式。用法如下：</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> i64 <span class="op">=</span> <span class="dt">long</span> <span class="dt">long</span><span class="op">;</span></span></code></pre></div>
<p>这个语句为 <code>long long</code> 声明了一个类型别名
<code>i64</code>。</p>
<p>类型别名也适用和变量相同的作用域规则。</p>
<p><code>using</code> 声明别名最大的特点是它可以支持模板。</p>
<h4 id="typedef-类型别名"><code>typedef</code> 类型别名</h4>
<p><code>typedef</code>
声明类型别名的方式与变量相似，源类型在前，别名在后。</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">typedef</span> <span class="dt">long</span> <span class="dt">long</span> i64<span class="op">;</span></span></code></pre></div>
<h3 id="字面量类型">字面量类型</h3>
<p>C++ 中，所有字面量的类型都是确定的。</p>
<h4 id="整数字面量">整数字面量</h4>
<p>通常情况下，一个整数类型字面量的类型通过如下简化规则确定（完整表格见
<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/integer_literal.html">cppreference</a>）。</p>
<ul>
<li>默认情况下为 <code>int</code>。如果数字过大，超过 <code>int</code>
存储范围，向上依次尝试 <code>long</code> 和 <code>long long</code>
类型。</li>
<li>如果使用了 <code>U</code> 后缀，则选定数字的无符号版本。</li>
<li>如果使用了 <code>L</code> 后缀，则从 <code>long</code>
开始尝试。如果使用了 <code>LL</code> 后缀，则从 <code>long long</code>
开始尝试。</li>
</ul>
<p><code>U</code> 后缀可以和其他的后缀组成 <code>UL</code> 或者
<code>ULL</code>。后缀大小写不敏感，但是 <code>LL</code>
的两个字母形式必须相同。</p>
<p>特别地，二进制、八进制或者十六进制表达，即使没有指定
<code>U</code>，也会尝试选定无符号类型。</p>
<p>例如以下的整数字面量（假设 <code>int</code> 和 <code>long</code> 为
32 位，<code>long long</code> 为 64 位）：</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span><span class="op">;</span> <span class="co">// 默认为 int</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2'147'483'648</span><span class="op">;</span> <span class="co">// 超过 int 和 long 最大值，为 long long</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="dv">100</span><span class="bu">LL</span><span class="op">;</span> <span class="co">// 手动指定为 long long</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="dv">24</span><span class="bu">llU</span><span class="op">;</span> <span class="co">// 与大小写、顺序无关，为 unsigned long long</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="bn">0x80000000</span><span class="op">;</span>  <span class="co">// unsigned int</span></span></code></pre></div>
<p>简单来讲，不指定后缀的整数类型通常为
<code>int</code>。如果希望是更大的类型，需要显式指定
<code>0L</code>（<code>long</code>）或
<code>0LL</code>（<code>long long</code>）。</p>
<h4 id="浮点数字面量">浮点数字面量</h4>
<p>浮点数字面量的类型由后缀决定。</p>
<ul>
<li>无后缀，表示 <code>double</code>。</li>
<li><code>f</code> 后缀，表示 <code>float</code>。</li>
<li><code>l</code> 后缀，表示 <code>long double</code>。</li>
</ul>
<p>同样对大小写不敏感。</p>
<h3 id="字符串字面量">字符串字面量</h3>
<p>字符串字面量的类型是对应的常量字符数组。例如 <code>"Hello"</code>
的类型是 <code>const char[6]</code>（包含结尾的空字符）。</p>
<h4 id="原始字符串">原始字符串</h4>
<p>C++11 引入了原始字符串语法。类似 <code>R"$(content)$"</code>
的形式为一个原始字符串，其实际值和 content
相同，并且<strong>无视转义字符，可以换行</strong>。其中的美元符号可以换为任意字符串（也可以为空），它不会出现在真正的内容中。例如：</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">R"raw-str(</span><span class="vs">\\\\ ()() """"</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="vs">\n\n\n\n</span><span class="st">)raw-str"</span><span class="op">;</span></span></code></pre></div>
<p>得到如下输出：</p>
<pre><code>\\\\ ()() """"
\n\n\n\n</code></pre>
<p>原始字符串的行为和普通的字符串相同。</p>
<h3 id="自动类型推导">自动类型推导</h3>
<h4 id="auto"><code>auto</code></h4>
<p>C++11 起，<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/auto.html">auto</a>
关键字用作自动类型推导。</p>
<p>变量初始化时，可以使用 <code>auto</code>
来代替实际类型。推导类型时有以下规则：</p>
<ul>
<li>忽略初始化表达式的引用性。</li>
<li>如果类型说明符不带引用，忽略初始化表达式的 cv 限定符。</li>
<li>如果类型说明符是
<code>auto &amp;&amp;</code>，根据初始化表达式的类别，推导为左值引用或右值引用（见相关章节）。</li>
</ul>
<p>例如以下代码：</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> x1 <span class="op">=</span> x<span class="op">;</span> <span class="co">// x1 的类型为 int，不带 const</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="at">volatile</span> <span class="kw">auto</span> x2 <span class="op">=</span> x<span class="op">;</span> <span class="co">// x2 的类型为 volatile int，也不带 const</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">&amp;</span>x3 <span class="op">=</span> x<span class="op">;</span> <span class="co">// x3 的类型为 const int &amp;，引用类型保留 const</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> x4<span class="op">{</span>x<span class="op">};</span> <span class="co">// 各种初始化方式都可以使用 auto</span></span></code></pre></div>
<p>C++20 起，<code>auto</code>
也可以用于函数参数类型。例如以下代码：</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> add<span class="op">(</span><span class="kw">auto</span> a<span class="op">,</span> <span class="kw">auto</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span> <span class="op">}</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 等价于</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> Ta<span class="op">,</span> <span class="kw">typename</span> Tb<span class="op">&gt;</span>  <span class="co">// 详见模板章节</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="va">add_</span><span class="op">(</span>Ta a<span class="op">,</span> Tb b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>lambda 函数自 C++14 起就有类似特性。</p>
<h4 id="decltype"><code>decltype</code></h4>
<p>C++11 起，可以用 <code>decltype</code> 推断表达式的类型。</p>
<p>如果参数是一个实体（Entity，如没有括号包裹的变量名、函数名、成员访问表达式），<code>decltype(entity)</code>
返回它的类型。</p>
<p>否则，如果参数是类型为 <code>T</code>
的其他表达式，基于其值类别：</p>
<ul>
<li><code>prvalue</code>，产生 <code>T</code> 类型。</li>
<li><code>lvalue</code>，产生 <code>T &amp;</code> 类型。</li>
<li><code>xvalue</code>，产生 <code>T &amp;&amp;</code> 类型。</li>
</ul>
<p>被 <code>decltype</code> 包裹的表达式不会被真正执行。</p>
<p>例如：</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">;</span>  <span class="co">// 未初始化</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> T1 <span class="op">=</span> <span class="kw">decltype</span><span class="op">(</span>x<span class="op">);</span>  <span class="co">// int</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> T2 <span class="op">=</span> <span class="kw">decltype</span><span class="op">((</span>x<span class="op">));</span>  <span class="co">// 此时为表达式，int &amp;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> T3 <span class="op">=</span> <span class="kw">decltype</span><span class="op">(</span>x <span class="op">+</span> <span class="fl">1.0</span><span class="op">);</span>  <span class="co">// double</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">// 没有真正使用 x 的值，所以不是 UB。</span></span></code></pre></div>
<h2 id="数值计算">数值计算</h2>
<p>算术运算等数值计算，算是最常用的操作了。接下来，我将会介绍一些和数值计算相关，可能被忽视的小细节。</p>
<h3 id="类型转换-1">类型转换</h3>
<p>在进行数值计算之前，需要把两个操作数转换为相同类型。</p>
<p>对于整数运算，将会从下表中选定第一个可以同时表示两个操作数的类型，将二者同时转换为这一类型。</p>
<ul>
<li><code>int</code></li>
<li><code>unsigned int</code></li>
<li><code>long</code></li>
<li><code>unsigned long</code></li>
<li><code>long long</code></li>
<li><code>unsigned long long</code></li>
</ul>
<p>算术运算的结果类型，和这个转换后的类型相同。例如：</p>
<ul>
<li><code>int + long long</code> -&gt; <code>long long</code></li>
<li><code>char + char</code> -&gt; <code>int</code></li>
</ul>
<p>关于浮点数的运算具有相似的规则，将会把整数转换为浮点数、浮点数转换为精度较高的。例如：</p>
<ul>
<li><code>int + float</code> -&gt; <code>float</code></li>
<li><code>float + double</code> -&gt; <code>double</code></li>
</ul>
<p>一个常见的错误是，STL 容器的 <code>.size()</code> 方法返回
<code>std::size_t</code>，通常为 64
位无符号整数。于是会出现这样的问题：</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> v<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 如果 v.size() = 0，相减之后得到的其实是 2^64 - 1</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 导致循环无法结束</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>另一个常见的错误，左移运算符的返回值仍然满足这个规律。所以
<code>1 &lt;&lt; 33</code> 这样的代码会导致未定义行为。可以写作
<code>1LL &lt;&lt; 33</code>。</p>
<h3 id="数值溢出">数值溢出</h3>
<p>所有的数据类型（如整数 <code>int</code>，浮点数
<code>double</code>）都会有自己的取值范围。当运算结果超过这个范围的时候，就会出现“溢出”，导致意料之外的结果。</p>
<p>不同类型的溢出行为也有所不同。</p>
<ul>
<li>有符号整数：<strong>未定义行为（UB）</strong>。</li>
<li>无符号整数：自然溢出。（例如 32 位无符号整数，相当于结果对 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.919ex" height="2ex" role="img" focusable="false" viewBox="0 -883.9 1290.1 883.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path></g></g></g></g></g></svg></mjx-container></span> 取模）</li>
<li>浮点数：实现定义，可能是产生 <code>inf</code> 等 IEEE-754
特殊值。</li>
</ul>
<p>另外，数值转换的过程中，如果原值不能被目标类型储存，会有以下行为：</p>
<ul>
<li>目标为有符号整数：实现定义，并在 C++20 起良好定义。（对 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.74ex" height="2.027ex" role="img" focusable="false" viewBox="0 -896 1210.9 896"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g></g></svg></mjx-container></span> 取模）</li>
<li>目标为无符号整数：始终良好定义。（对 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.74ex" height="2.027ex" role="img" focusable="false" viewBox="0 -896 1210.9 896"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,413) scale(0.707)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g></g></svg></mjx-container></span> 取模）</li>
<li>目标为浮点数：相关精度问题由实现定义。</li>
</ul>
<p>在哈希等场景下，我们会期望发生“自然溢出”，这种情况下，必须使用无符号整数。</p>
<h3 id="求值顺序">求值顺序</h3>
<p>C++
中，很多求值顺序都是未指定或无序的（为了描述简单，我们暂时不辨析这两个概念）。例如
<code>f() + g()</code>，标准允许先调用 <code>f()</code> 再调用
<code>g()</code>，也允许与其相反的顺序。</p>
<p>简单地讲，一个表达式最好需要满足以下规则，否则很容易出现未定义行为：</p>
<ul>
<li>避免多次修改同一变量。单个表达式，只应该对一个变量修改至多一次。</li>
<li>避免同时读写变量。单个表达式，如果对变量进行了修改，就不要再读取它。</li>
</ul>
<p>特别地，使用逗号分隔两个子表达式通常是安全的，它有良好的定序规则。</p>
<h4 id="详细规则">详细规则</h4>
<p>具体见 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/eval_order.html">求值顺序
- cppreference</a>。</p>
<p>一次完整的表达式求值，包含值计算和副作用两个操作。在同一个线程中，表达式的所有求值操作通过“先序”规则判定顺序。如果操作
A 先序于（sequenced before，也被翻译为“按顺序早于”）操作
B，那么在完成操作 A 以后才会开始执行操作 B。先序关系具有传递性。</p>
<p>如果表达式 A 先序于表达式 B，只有完成了 A
的值计算和副作用，才会开始进行 B 的值计算和副作用。</p>
<p>C++ 标准说明了几个确定的先序关系，详情可以参考上述链接。</p>
<p>绝大多数运算符，对左右操作数都是没有定序的。函数调用时，参数的求值顺序也是无序的（C++17
开始变为未指定行为）。</p>
<p>未定序的情况下，多次修改或者同时读写同一变量属于未定义行为。</p>
<p>例如这样的一个表达式
<code>i++ &amp;&amp; ++i</code>，可以按照下文的方式来分析。（个人理解）</p>
<p>把表达式分为如下几个部分：</p>
<ul>
<li><code>i++</code>：求值 <code>A0</code>，副作用
<code>A1</code>。</li>
<li><code>++i</code>：求值 <code>B0</code>，副作用
<code>B1</code>。</li>
<li>逻辑与：求值 <code>C0</code>。</li>
</ul>
<p>用 <code>-&gt;</code> 表示先序关系，应用相关标准规则可知：</p>
<ul>
<li><code>A0 -&gt; A1</code>。</li>
<li><code>B1 -&gt; B0</code>。</li>
<li><code>A -&gt; B</code>，<code>A0 -&gt; C</code>，<code>B0 -&gt; C</code>。</li>
</ul>
<p>所以这个表达式可以完全定序，<code>A0 -&gt; A1 -&gt; B1 -&gt; B0 -&gt; C</code>，不存在未定义行为。</p>
<p>相对地，<code>i++ + i</code>
这样的表达式也可以分析出是未定义行为。</p>
<h3 id="杂项">杂项</h3>
<h4 id="运算符优先级">运算符优先级</h4>
<p>见 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_precedence.html">C++
运算符优先级 - cppreference</a>。</p>
<h4 id="表达式和语句">“表达式”和“语句”</h4>
<p>表达式（Expression）和语句（Statement）是两个可能被混淆的概念。</p>
<p>表达式用于计算并一个值，例如以下的几个表达式：</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">+</span> b  <span class="co">// 简单表达式</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>a <span class="op">-</span> b<span class="op">)</span> <span class="op">*</span> <span class="op">((</span>a <span class="op">+</span> b <span class="op">*</span> c<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="dv">2</span><span class="op">)</span>  <span class="co">// 表达式可以嵌套和组合</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">*</span> sqrt<span class="op">(</span><span class="dv">2</span><span class="op">)</span>  <span class="co">// 函数调用也是表达式</span></span></code></pre></div>
<p>语句用于执行操作、控制程序运行等。它没有返回值。例如以下的几个语句：</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">{</span><span class="dv">100</span><span class="op">};</span>  <span class="co">// 定义变量</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">100</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span>  <span class="co">// 循环语句</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">%</span> <span class="dv">9</span> <span class="op">==</span> <span class="dv">2</span><span class="op">)</span>  <span class="co">// 条件语句</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">continue</span><span class="op">;</span>  <span class="co">// 控制语句</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    x<span class="op">++;</span>  <span class="co">// 执行表达式的语句</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="短路机制">“短路”机制</h4>
<p>逻辑与 <code>&amp;&amp;</code>、逻辑或 <code>||</code>
运算符有特殊的“短路”机制。它会先计算左侧的表达式，如果此时已经可以确定答案（<code>&amp;&amp;</code>
遇到 <code>false</code>，<code>||</code> 遇到
<code>true</code>），就不再计算右侧的表达式。</p>
<p>这个特性主要是用来方便这样的代码：</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> flag <span class="op">=</span> <span class="op">(</span>index <span class="op">&lt;</span> n<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>a<span class="op">[</span>index<span class="op">]</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// 如果 index &gt;= n，不会执行右侧导致未定义行为</span></span></code></pre></div>
<h4 id="逗号运算符">逗号运算符</h4>
<p>可以使用逗号连接两个子表达式，其行为是依次执行这两个表达式，然后返回第二个表达式的值。</p>
<p>这在一些情况下可以方便书写。例如：</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 尽管 for 循环的这个位置只能执行一条语句，但是可以用逗号表达式依次执行多个逻辑。</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++,</span> cnt<span class="op">++)</span> <span class="op">{}</span></span></code></pre></div>
<h4 id="三目运算符">三目运算符</h4>
<p>三目运算符可以执行条件判断，在一些情况下可以方便书写。</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="op">(</span>n <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">5</span> <span class="op">:</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 等价于</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>n <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{</span> x <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<h4 id="除法优化">除法优化</h4>
<p>对于计算机而言，取模和除法是极其耗时的操作。幸运的是，编译器可以对固定模数除法、取模进行大幅度优化。将除数声明为
<code>constexpr</code> 或者 <code>const</code>，开启编译器 O2
优化，可以大幅提升除法效率。对于浮点数除以固定值，可以先计算出来这个数的倒数，然后化为乘法计算。</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> mod <span class="op">=</span> <span class="dv">998244353</span><span class="op">;</span>  <span class="co">// constexpr 也可以换成 const</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">%</span> mod<span class="op">;</span>  <span class="co">// 编译器可以进行优化</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 浮点数</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">/=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">*=</span> <span class="fl">0.1</span><span class="op">;</span>  <span class="co">// 更快</span></span></code></pre></div>
<h2 id="指针和引用">指针和引用</h2>
<p>C++
对象在内存上的存储，位于一个连续的地址空间。“指针”就是用于描述一个对象的地址。</p>
<p>可以把内存理解成一个大型的数组，“指针”存储的数据就是这个数组的下标（显然这是不严谨的，因为内存中可以存储不同类型的对象）。可以通过指针来读写对象。</p>
<h3 id="指针基础">指针基础</h3>
<p><code>T *p</code> 标识一个指向 <code>T</code> 类型对象的指针，名称为
<code>p</code>。接下来，通过 <code>*p</code> 可以访问 <code>p</code>
指向的元素（可以进行读写）。</p>
<p><code>&amp;x</code> 表示对 <code>x</code> 取地址，即获取一个指向 x
的指针。</p>
<p>例如以下示例：</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">{</span><span class="dv">100</span><span class="op">};</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span> <span class="co">// p 现在指向 x</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">24</span><span class="op">;</span> <span class="co">// 通过指针间接修改</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span> <span class="co">// 输出 24</span></span></code></pre></div>
<p>类型 <code>T</code> 的部分可以包含 <code>const</code>
这样的修饰符，可以避免通过这个指针修改对象。</p>
<p>可以在星号后面添加
<code>const</code>，表示不可以修改“这个指针指向谁”。</p>
<p>例如：</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x<span class="op">{</span><span class="dv">10</span><span class="op">},</span> y<span class="op">{</span><span class="dv">10</span><span class="op">};</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="at">const</span> <span class="op">*</span>p1 <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span> <span class="co">// 等价于 const int *p1_</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span> <span class="at">const</span> p2 <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p1 <span class="op">=</span> <span class="dv">100</span><span class="op">;</span> <span class="co">// 错误！不能通过指针修改 const int</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>p1 <span class="op">=</span> <span class="op">&amp;</span>y<span class="op">;</span> <span class="co">// 现在 p1 指向 y</span></span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p2 <span class="op">=</span> <span class="dv">100</span><span class="op">;</span> <span class="co">// 修改 x 的值</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>p2 <span class="op">=</span> <span class="op">&amp;</span>y<span class="op">;</span> <span class="co">// 错误！不能修改 p2 表示的地址。</span></span></code></pre></div>
<p>指针必须指向一个合法的对象，并且是兼容的类型，否则对它解引用（<code>*p</code>）是未定义的。</p>
<h3 id="常见的不可解引用指针">常见的不可解引用指针</h3>
<h4 id="nullptr">nullptr</h4>
<p>C++ 使用 <code>nullptr</code>
作为空指针常量，语义上表示指针不指向任何元素。等于 <code>nullptr</code>
的指针不可解引用。</p>
<h4 id="悬空指针">悬空指针</h4>
<p>当一个对象被销毁之后，指向它的指针就会变成悬空指针。一类典型的悬空指针是通过函数返回局部变量的指针。例如：</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> tmp <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">&amp;</span>tmp<span class="op">;</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> f<span class="op">();</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="co">// 此时对 p 解引用，指向一个被销毁的局部变量，是未定义行为。</span></span></code></pre></div>
<h4 id="无效指针">无效指针</h4>
<p>当一个指针指向无效的地址（通常是由于未初始化），对它解引用也是未定义的。</p>
<h3 id="指针算术">指针算术</h3>
<p>指针可以进行一些简单的算术运算，如下：</p>
<ul>
<li>指针加/减整数：将指针向前或者向后移动若干个元素。</li>
<li>指针减指针：计算它们间隔几个元素。</li>
<li>下标访问：<code>p[n]</code> 等价于 <code>*(p + n)</code>。</li>
</ul>
<p>指针算术的单位始终是完整元素，而非字节。指针算术必须在同一个数组上进行（运算数的指针、结果的指针等），否则行为未定义。特别地，对于大小为
n 的数组，指向 a[n] 的指针也合法（尾后指针），但是不可解引用。</p>
<p>示例：</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> arr<span class="op">[</span><span class="dv">100</span><span class="op">]{};</span> <span class="co">// 创建一片连续内存</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p <span class="op">=</span> <span class="op">&amp;</span>arr<span class="op">[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p1 <span class="op">=</span> p <span class="op">+</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// 指向 a[10]</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">*</span>p2 <span class="op">=</span> p <span class="op">-</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// 指向 a[2]</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dis <span class="op">=</span> p1 <span class="op">-</span> p2<span class="op">;</span> <span class="co">// 等于 8</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> item <span class="op">=</span> p<span class="op">[</span><span class="dv">9</span><span class="op">];</span> <span class="co">// a[14] 对应的值为 0</span></span></code></pre></div>
<p>指针算术过程，涉及的指针必须处于同一个数组中，否则行为未定义。</p>
<h3 id="左值引用">（左值）引用</h3>
<p>“引用”在本质上和指针类似，也是通过记录内存地址来关联到另一个对象。不同的是，引用：</p>
<ul>
<li>无需显式解引用。</li>
<li>无法修改绑定到哪个对象。</li>
<li>必须在初始化时绑定。</li>
</ul>
<p>例如以下代码：</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="op">&amp;</span>y <span class="op">=</span> x<span class="op">;</span> <span class="co">// 定义一个 x 的引用，名为 y</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> y<span class="op">;</span> <span class="co">// 可以像一个整数一样直接使用 y</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> <span class="co">// x 也被修改为 10</span></span></code></pre></div>
<p>引用的类型也可以带有 <code>const</code>
修饰，和对应的指针相同，不能通过这个引用来修改原对象。特别地，<code>const T &amp;</code>
可以绑定到一个右值（如字面量等）。</p>
<p>很多情况下，对于比较大的对象，我们会使用常量引用来传递参数，减少一次复制的开销。</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>string <span class="op">&amp;</span>s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> s <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>通常认为，当按值传递对象会发生大于等于 32
字节的拷贝时，就应当考虑通过常量引用传递。但是整数、很小的结构体，按值传递会更快一些。</p>
<h3 id="动态内存分配">动态内存分配</h3>
<p>在之前，我们提到了“动态存储期”这一概念。这类对象不同于自动存储期，可以有很长的生命周期，不会自动释放，直到被用户显式销毁。</p>
<p>在 C++ 中，可以使用 <code>new</code> 创建动态对象，使用
<code>delete</code> 释放。具体用法如下：</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">*</span> <span class="op">{</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">{</span><span class="dv">5</span><span class="op">};</span>  <span class="co">// 创建动态对象，返回一个指针</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> ptr <span class="op">=</span> f<span class="op">();</span>  <span class="co">// 动态对象的指针可以跨函数传递</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="op">*</span>ptr <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> ptr<span class="op">;</span>  <span class="co">// 必须释放，否则会导致内存泄漏</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>一个动态对象，必须在将来的某个时刻进行释放，并且仅能释放恰好一次。如果没有释放，将会导致内存泄漏，浪费大量内存。如果释放多次，则行为未定义。释放内存后再次访问，行为未定义。</p>
<p>这个对象将会按照特定方式初始化：</p>
<ul>
<li><code>new int</code>：默认初始化，<strong>将会持有不确定值</strong>。</li>
<li><code>new int{5}</code>：列表初始化。如果花括号为空则是值初始化，均为安全的。</li>
<li><code>new int(5)</code>：直接初始化。</li>
</ul>
<p>可以使用 <code>new[]</code> 和 <code>delete[]</code>
来动态分配数组。动态分配的数组，大小可以是一个变量。</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span><span class="dt">int</span> size<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">*</span> <span class="op">{</span></span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>size<span class="op">];</span>  <span class="co">// 动态分配内存</span></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 此时的数组包含不确定值！</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 如果希望自动清零，可以使用 new int[100]{}</span></span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> arr <span class="op">=</span> f<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a>    arr<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb51-14"><a href="#cb51-14" aria-hidden="true" tabindex="-1"></a>        arr<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">])</span> <span class="op">%</span> <span class="dv">998'244'353</span><span class="op">;</span></span>
<span id="cb51-15"><a href="#cb51-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb51-16"><a href="#cb51-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> arr<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb51-17"><a href="#cb51-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-18"><a href="#cb51-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 动态分配数组，必须使用 delete[] 释放</span></span>
<span id="cb51-19"><a href="#cb51-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span><span class="op">[]</span> arr<span class="op">;</span></span>
<span id="cb51-20"><a href="#cb51-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>使用 <code>new</code> 动态分配的内存，会保证对齐到
<code>std::max_align_t</code>，能够满足全部标准对象的对齐要求。</p>
<h3 id="底层内存操作">底层内存操作</h3>
<h4 id="operator-new">operator new</h4>
<p>C++ 中，<code>operator new</code>
可以用来动态分配特定大小的内存块，但是不进行对象初始化。</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> ptr <span class="op">=</span> <span class="op">::</span><span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">*</span> <span class="dv">100</span><span class="op">);</span>  <span class="co">// 分配 100 个 int 的内存</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co">// ptr 的类型为 void *</span></span></code></pre></div>
<p>其中，括号内传入的参数是字节数。</p>
<p><code>operator new</code> 分配的内存，必须通过
<code>operator delete</code> 释放。</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="op">::</span><span class="kw">operator</span> <span class="kw">delete</span><span class="op">(</span>ptr<span class="op">);</span></span></code></pre></div>
<p>C++17 起，可以通过 <code>std::align_val_t</code>
来指定内存对齐的大小，处理更高对齐要求的特殊对象（如 SIMD 对象）。</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> ptr <span class="op">=</span> <span class="op">::</span><span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">),</span> <span class="bu">std::</span>align_val_t<span class="op">{</span><span class="kw">alignof</span><span class="op">(</span>T<span class="op">)});</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="op">::</span><span class="kw">operator</span> <span class="kw">delete</span><span class="op">(</span>ptr<span class="op">,</span> <span class="kw">alignof</span><span class="op">(</span>T<span class="op">));</span></span></code></pre></div>
<h4 id="手动构造析构">手动构造、析构</h4>
<p>在未初始化的内存上，我们可以手动调用对象的构造函数和析构函数。对于需要延迟构造的对象，需要经历以下四个步骤：</p>
<ol type="1">
<li>分配内存</li>
<li>构造对象</li>
<li>析构对象</li>
<li>释放内存</li>
</ol>
<p>手动构造对象，需要使用 <code>placement new</code>。其语法如下：</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>T <span class="op">*</span>new_ptr <span class="op">=</span> <span class="kw">new</span> <span class="op">(</span>void_ptr<span class="op">)</span> T<span class="op">(</span><span class="co">/*构造参数*/</span><span class="op">);</span></span></code></pre></div>
<p>这将会在 <code>void_ptr</code>
指向的内存空间上，使用指定的参数构造对象，返回新的指针。</p>
<p>手动析构对象，可以通过指针调用它的析构函数。但是需要注意，跟在波浪线之后的，只能有一个标识符，要么是一个该类型的类型别名，要么是原始类名。</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string <span class="op">*</span>ptr <span class="op">=</span> <span class="co">/*...*/</span><span class="op">;</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> str <span class="op">=</span> <span class="bu">std::</span>string<span class="op">;</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">-&gt;~</span>str<span class="op">();</span>  <span class="co">// 合法</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">-&gt;~</span>basic_string<span class="op">();</span>  <span class="co">// 合法，std::string 的原始类名叫 std::basic_string&lt;char&gt;</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">-&gt;~</span><span class="bu">std::</span>string<span class="op">();</span>  <span class="co">// 不合法，不能包含作用域解析运算</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> destruct<span class="op">(</span>T <span class="op">*</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>    ptr<span class="op">-&gt;~</span>T<span class="op">();</span>  <span class="co">// 合法</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>在一个位置已经存在对象的情况下再次构造，或者在不存在对象的情况下再次析构，是未定义行为。</p>
<p>C++20 起，提供函数 <code>std::construct_at</code> 和
<code>std::destroy_at</code> 用于手动构造和析构对象。</p>
<h2 id="数组">数组</h2>
<p>数组用于存储多个相同类型、在内存上连续排布的对象。</p>
<p>使用如下方式定义一个数组。</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="kw">constexpr</span> size <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> arr<span class="op">[</span>size<span class="op">]{};</span>  <span class="co">// 自动清零</span></span></code></pre></div>
<p>数组的大小必须是一个正整数，且是编译期常量。通常情况下，如果希望使用变量作为数组大小，这个变量必须标记为
<code>constexpr</code>（常量表达式），或者含有常量值的
<code>const</code> 变量。</p>
<p>尽管标准不允许，很多编译器还是提供了扩展，允许变量值作为数组大小，称为变长数组（VLA）。</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span> <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> n<span class="op">;</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> vla<span class="op">[</span>n<span class="op">];</span>  <span class="co">// 非标准行为！</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// VLA 只能拥有自动存储期</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>    vla<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a>        vla<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> vla<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> vla<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span>  <span class="co">// 输入 100，输出 100</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>这个代码在 GCC 中是允许的。如果希望观察标准行为，请使用
<code>-pedantic</code> 编译选项，对这类编译器扩展给出警告。</p>
<p>很多情况下，数组都会隐式转换为指针。转换后的指针指向数组的首个元素，即
<code>&amp;a[0]</code>。</p>
<p>这种转换的出现频率很高，除非正在在作为一个“实体”（例如
<code>sizeof</code>，<code>decltype</code>
的操作数），或者作为一个左值（例如正在进行取地址）。甚至就连数组的下标访问，本质上也是指针算术。</p>
<p>例如，这些很常用的操作，就涉及数组到指针的转换。</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>sort<span class="op">(</span>a<span class="op">,</span> a <span class="op">+</span> n<span class="op">);</span>  <span class="co">// 均转换成指针类型</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 第一个参数转换为指针，但是最后一个参数取的是数组的大小</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>memset<span class="op">(</span>a<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>a<span class="op">));</span></span></code></pre></div>
<p>另一个问题是，数组通过函数参数传递，往往实际上传递的也是指针。</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span><span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">])</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span><span class="dt">int</span> <span class="op">*,</span> <span class="kw">decltype</span><span class="op">(</span>a<span class="op">)&gt;);</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>在这里，我们期望的可能是，数组的元素被逐一复制并传递，但是实际上，这是在传递一个指针，在函数内部的修改会影响到外部数组。这很不符合直觉，所以不推荐使用数组作为函数参数。</p>
<p>数组不能作为函数返回值。以下代码不能通过编译。</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span> <span class="op">}</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">(</span>g<span class="op">())[</span><span class="dv">3</span><span class="op">]</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span> <span class="op">}</span>  <span class="co">// 前置类型、后置类型都不行</span></span></code></pre></div>
<p>数组不能进行复制（赋值/初始化另一个数组），只能使用
<code>memcpy</code> 和 <code>std::copy</code>
这些函数操作。但特别地，这不会影响到包含数组的结构体。</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">]{};</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> a<span class="op">;</span>  <span class="co">// 错误！</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span> <span class="dt">int</span> a<span class="op">[</span><span class="dv">3</span><span class="op">];</span> <span class="op">};</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>S s1<span class="op">{};</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>S s2 <span class="op">=</span> s1<span class="op">;</span>  <span class="co">// 正确</span></span></code></pre></div>
<p>由于数组存在这些缺陷，在这些场景下，建议使用 <code>std::array</code>
来替代。使用以下方式，可以定义一个 int 类型的数组，包含 20 个元素：</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">20</span><span class="op">&gt;</span> a<span class="op">;</span></span></code></pre></div>
<p><code>std::array</code>
可以进行传参、返回、赋值等操作，都是通过逐个元素复制。如果不希望复制，可以通过显式传递引用来避免。</p>
<p>多维数组可以通过嵌套 <code>std::array</code> 代替。</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array<span class="op">&lt;</span><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">20</span><span class="op">&gt;,</span> <span class="dv">10</span><span class="op">&gt;</span> a<span class="op">;</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 相当于</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span><span class="dv">10</span><span class="op">][</span><span class="dv">20</span><span class="op">];</span></span></code></pre></div>
<p><code>std::array</code> 不能隐式转换为指针，可以使用
<code>arr.data()</code> 或者 <code>&amp;arr[0]</code> 获取指针。</p>
<h2 id="函数">函数</h2>
<p>C++
使用函数，可以把一段代码封装在一起，共同实现一个功能，进行一个计算。</p>
<h3 id="基础知识">基础知识</h3>
<p>函数的基本用法，大家都已经很熟悉了，在这里不做讲述。</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> square<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x<span class="op">;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>square<span class="op">(</span><span class="dv">5</span><span class="op">);</span> <span class="co">// 25</span></span></code></pre></div>
<p>C++11
起，可以后置标注函数的返回值。这在编写一些使用模板的代码时会有帮助，并且可能更加美观。</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> square<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x<span class="op">;</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>C++14 起，返回值类型可以省略（仅使用 <code>auto</code>）。</p>
<p>很多情况下，在传递函数参数的过程中，可以使用聚合初始化来简化代码，无需具体写出类型。</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> AVeryLongClassName <span class="op">{</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>AVeryLongClassName x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x<span class="op">.</span>a <span class="op">&lt;&lt;</span> <span class="ch">' '</span> <span class="op">&lt;&lt;</span> x<span class="op">.</span>b <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>使用时，可以直接传入一个花括号包裹的初始化列表，不需显式写出类型。在这个场景下，可以自动推导出正确类型
<code>AVeryLongClassName</code>。</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>f<span class="op">({</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">});</span>  <span class="co">// 输出 2 3</span></span></code></pre></div>
<p>如果函数中的某个参数没有被使用，可以只写类型、不写参数名，来抑制编译器警告。</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span><span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 使用：</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span>  <span class="co">// 3</span></span></code></pre></div>
<p>函数可以先声明，再在后面进行定义。</p>
<div class="sourceCode" id="cb70"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">);</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>函数体之前可以添加 <code>noexcept</code>
声明，表示这个函数不会抛出异常，用于在一些场景下保证异常安全。建议为移动构造、移动赋值函数添加
<code>noexcept</code>。</p>
<div class="sourceCode" id="cb71"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="函数重载">函数重载</h3>
<p>有些时候，我们可能会希望对多个类型实现类似功能，这种情况下就可以使用函数重载来实现，即允许多个函数拥有同一个名字。</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> square<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">*</span> x<span class="op">;</span> <span class="op">}</span>  <span class="co">// (1)</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a><span class="dt">double</span> square<span class="op">(</span><span class="dt">double</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">*</span> x<span class="op">;</span> <span class="op">}</span>  <span class="co">// (2)</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a>square<span class="op">(</span><span class="dv">3</span><span class="op">);</span>  <span class="co">// 调用重载 (1)</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>square<span class="op">(</span><span class="fl">5.0</span><span class="op">);</span>  <span class="co">// 调用重载 (2)</span></span></code></pre></div>
<p>当调用存在重载的函数时，会通过重载决议判断实际调用哪一项。具体规则十分复杂，可以参考
<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/overload_resolution.html">cppreference</a>。</p>
<p>简单来讲，需要满足以下要求：</p>
<ul>
<li>首先，保证参数个数正确，并且模板推导成功、每个参数都可以隐式转换为相应类型。</li>
<li>对于这些可行项，按照以下优先级选择：
<ol type="1">
<li>参数精确匹配。（允许左值到右值转换、限定符转换等简单转换）</li>
<li>只需使用标准转换，其中提升（如 <code>int</code> -&gt;
<code>long long</code>）优于其他转换（如 <code>double</code> -&gt;
<code>int</code>）。</li>
<li>需要用户定义的转换。（这允许从花括号包裹的初始化列表，转换为类类型）</li>
</ol></li>
</ul>
<p>对于相同优先级的，不带模板的函数优于带有模板的，函数模板之间按照特化程度比较。</p>
<p>如果无法判断两个重载的优先级，则编译错误。</p>
<h4 id="实参依赖查找">实参依赖查找</h4>
<p>实参依赖查找（ADL）允许程序访问其他命名空间中的函数，而无需显式指定命名空间名。在参数包含类类型时，编译器会额外在参数所处的命名空间查找这个函数重载项。</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> A <span class="op">{</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> S <span class="op">{};</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">(</span>S<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">::</span>S x<span class="op">;</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span>x<span class="op">);</span>  <span class="co">// 通过实参依赖查找调用 A::f</span></span>
<span id="cb73-9"><a href="#cb73-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>实参依赖查找主要是为了方便运算符重载，在命名空间内定义的重载运算符，也能通过
ADL 成功调用。</p>
<p>也有其他函数经常使用 ADL 查找。最经典的是
<code>swap</code>，通常情况下约定使用 <code>swap(x, y)</code>
来交换两个自定义类型的对象对象，它对这个类型可能有比
<code>std::swap</code> 更优的实现。所以标准的交换两个元素的方式是：</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>swap<span class="op">;</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>swap<span class="op">(</span>x<span class="op">,</span> y<span class="op">);</span></span></code></pre></div>
<p>C++20 起，提供了 <code>std::ranges::swap</code>。不同于
<code>std::swap</code>，它的效果相当于这两步操作。</p>
<h3 id="默认参数">默认参数</h3>
<p>在函数声明中，可以为参数指定默认值，使得调用时可以省略部分参数。默认参数必须从参数列表的右侧开始连续指定。</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print<span class="op">(</span><span class="dt">int</span> value<span class="op">,</span> <span class="dt">int</span> base <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> <span class="dt">int</span> width <span class="op">=</span> <span class="dv">8</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="dv">42</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="dv">42</span><span class="op">,</span> <span class="dv">16</span><span class="op">);</span>    <span class="co">// 等价于 print(42, 16, 8)</span></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>print<span class="op">(</span><span class="dv">42</span><span class="op">);</span>        <span class="co">// 等价于 print(42, 10, 8)</span></span></code></pre></div>
<p>存在默认参数的函数，会向重载决议添加多个重载项，例如上文的
<code>print</code> 会包括
<code>print(int)</code>、<code>print(int, int)</code> 和
<code>print(int, int, int)</code>。需要小心处理它和其他函数重载的潜在冲突。</p>
<h3 id="重载运算符">重载运算符</h3>
<p>C++
允许重载运算符，允许自定义类型之间使用运算符进行操作，调用指定的函数。</p>
<p>定义一个重载运算符，可以使用 <code>operator</code>
关键字，形式大概相当于定义了一个叫做 <code>operator@</code>
的函数（<code>@</code> 是对应运算符）。</p>
<p>绝大多数运算符都可以被重载，以下是一个 <code>std::string</code>
乘以整数的重载。</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="kw">operator</span><span class="op">*</span> <span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span> <span class="op">&amp;</span>s<span class="op">,</span> <span class="dt">int</span> count<span class="op">)</span> <span class="op">-&gt;</span> <span class="bu">std::</span>string <span class="op">{</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string res<span class="op">{};</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> count<span class="op">;</span> i<span class="op">++)</span> res <span class="op">+=</span> s<span class="op">;</span></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a><span class="co">// 使用</span></span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s<span class="op">{</span><span class="st">"Hello"</span><span class="op">};</span>  <span class="co">// 必须先转为 std::string</span></span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> s <span class="op">*</span> <span class="dv">5</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span></code></pre></div>
<p>但是需要注意，重载运算符的操作数，不能全为内置类型，（例如这里包含一个
<code>std::string</code> 就是合法的）。</p>
<p>也可以在类的定义中，通过成员函数重载运算符（见相关章节）。</p>
<h3 id="回调函数">回调函数</h3>
<p>有些时候，函数可以作为另一个函数的参数。这允许代码表达更加丰富的逻辑。</p>
<p>例如，我们有以下的两个需求：</p>
<ul>
<li>找到 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.753ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2100.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1222.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1822.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container></span>
的所有偶数，输出到控制台。</li>
<li>找到 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.753ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2100.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1222.7,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1822.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></svg></mjx-container></span>
的所有偶数，存储到一个列表中。</li>
</ul>
<p>这两个需求很明显十分接近，但是想要使用一个函数来实现，还是有一定的困难。事实上，我们可以提取一个共用的逻辑：找到该范围的所有偶数，通过某种方式提交结果。</p>
<p>那么我们便可以通过这种方式实现：传入整数 <code>n</code> 和另一个函数
<code>f</code>，每遇到一个偶数 <code>x</code>，通过调用
<code>f(x)</code> 提交这个答案。</p>
<p>我们使用 Python 语言来表达这个逻辑，因为 C++
的类型系统可能比较复杂。如果你不了解
Python，可以看成伪代码结合注释理解。</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_even(n, f):  <span class="co"># 实现函数</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># 遍历 [1, n] 区间</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>            f(i)  <span class="co"># 偶数，提交答案</span></span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> to_console(x):  <span class="co"># 输出到控制台</span></span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(x)</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>res <span class="op">=</span> []  <span class="co"># 结果列表</span></span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> to_list(x):  <span class="co"># 输出到 res 列表</span></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a>    res.append(x)</span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>find_even(<span class="dv">20</span>, to_console)  <span class="co"># 使用</span></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a>find_even(<span class="dv">20</span>, to_list)</span></code></pre></div>
<p>想要在 C++ 中使用函数作为参数，可以考虑以下的方案。</p>
<h4 id="模板">模板</h4>
<p><strong>这是最推荐的方式</strong>，通过模板，可以让函数接收任意类型的参数，自然包括函数。</p>
<p>这种方式不会有任何运行时的开销，并且可以完美支持下文提到的仿函数。</p>
<p>模板的相关知识会在后续章节讲解。</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> find_even<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> T f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> f<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="函数指针">函数指针</h4>
<p>在 C++
中，可以让一个指针指向函数，称为函数指针。可以通过函数指针来调用这个函数。以下代码展现了函数指针的使用。</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;random&gt;</span></span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> square<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x<span class="op">;</span></span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-8"><a href="#cb79-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> cube<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb79-9"><a href="#cb79-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x <span class="op">*</span> x<span class="op">;</span></span>
<span id="cb79-10"><a href="#cb79-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb79-11"><a href="#cb79-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-12"><a href="#cb79-12" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb79-13"><a href="#cb79-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>mt19937 random<span class="op">{</span><span class="bu">std::</span>random_device<span class="op">{}()};</span></span>
<span id="cb79-14"><a href="#cb79-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-15"><a href="#cb79-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> FuncPointer <span class="op">=</span> <span class="dt">int</span> <span class="op">(*)(</span><span class="dt">int</span><span class="op">);</span>  <span class="co">// 类型表示法：返回值 (*)(参数列表)</span></span>
<span id="cb79-16"><a href="#cb79-16" aria-hidden="true" tabindex="-1"></a>    FuncPointer ptr<span class="op">{};</span></span>
<span id="cb79-17"><a href="#cb79-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>random<span class="op">()</span> <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span>  <span class="co">// 随机选择一个</span></span>
<span id="cb79-18"><a href="#cb79-18" aria-hidden="true" tabindex="-1"></a>        ptr <span class="op">=</span> <span class="op">&amp;</span>cube<span class="op">;</span></span>
<span id="cb79-19"><a href="#cb79-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb79-20"><a href="#cb79-20" aria-hidden="true" tabindex="-1"></a>        ptr <span class="op">=</span> square<span class="op">;</span>  <span class="co">// 即使不使用取地址符号，函数名也会自动转换为函数指针</span></span>
<span id="cb79-21"><a href="#cb79-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb79-22"><a href="#cb79-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb79-23"><a href="#cb79-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> ptr<span class="op">(</span><span class="dv">6</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span>  <span class="co">// 函数指针可以直接使用括号调用，也可以先 (*ptr) 解引用再调用</span></span>
<span id="cb79-24"><a href="#cb79-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 随机输出 36 或者 216</span></span>
<span id="cb79-25"><a href="#cb79-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>于是可以按照如下方式实现 <code>find_even</code> 函数。</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> FuncPtr <span class="op">=</span> <span class="dt">int</span> <span class="op">(*)(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> find_even<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> FuncPtr f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> f<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 如果不使用类型别名，参数应写作 int (*f)(int)</span></span></code></pre></div>
<p>这种方式无法支持仿函数和 lambda
函数，通常不推荐使用。但是函数指针也有其他的用途（例如上一个例子，以及与
C 函数交互等）。</p>
<h4 id="stdfunction">std::function</h4>
<p><code>std::function</code> 是 C++11
起提供的一个标准库工具，可以存储一类可调用对象（函数或仿函数等），它们有相同的调用签名，即接收同样类型的参数、返回同样类型的值。</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> square_impl<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">*</span> x<span class="op">;</span></span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">int</span><span class="op">(</span><span class="dt">int</span><span class="op">)&gt;</span> square <span class="op">=</span> square_impl<span class="op">;</span></span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// lambda 函数也可以使用同样类型的 std::function</span></span>
<span id="cb81-11"><a href="#cb81-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">int</span><span class="op">(</span><span class="dt">int</span><span class="op">)&gt;</span> cube <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">*</span> x <span class="op">*</span> x<span class="op">;</span> <span class="op">};</span></span>
<span id="cb81-12"><a href="#cb81-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> square<span class="op">(</span><span class="dv">5</span><span class="op">)</span> <span class="op">+</span> cube<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span>  <span class="co">// 直接使用括号调用</span></span>
<span id="cb81-13"><a href="#cb81-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 输出 33</span></span>
<span id="cb81-14"><a href="#cb81-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>std::function</code>
像是适用范围更广的函数指针，在类型中只包括函数的调用签名。与之相对地，函数指针无法指向一个仿函数。</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> find_even<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">int</span><span class="op">(</span><span class="dt">int</span><span class="op">)&gt;</span> f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>i <span class="op">%</span> <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> f<span class="op">(</span>i<span class="op">);</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>相比于使用模板，<code>std::function</code>
有较大的运行时开销，所以在函数传参的场景下，不建议使用这个方式。它更多用于实现运行时多态。</p>
<h3 id="仿函数lambda-函数">仿函数、lambda 函数</h3>
<p>C++
的函数无法在局部定义，这带来了很大的不便。这使得跨函数共享数据，只能通过参数传递，或者全局变量。</p>
<p>幸运的是，我们可以在局部定义域中定义一个类，并且可以通过成员函数重载函数调用运算符，即
<code>a(b)</code>。这使得我们可以通过这种方式模拟一个函数，这就是仿函数。</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Print <span class="op">{</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span><span class="co">/*函数参数列表*/</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x<span class="op">;</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> print<span class="op">;</span></span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>    print<span class="op">(</span><span class="dv">0</span><span class="op">);</span>  <span class="co">// 使用和普通函数一致</span></span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>仿函数的意义不仅在于可以在函数内部定义，它还是一种有状态的函数。</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sum<span class="op">{};</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Func <span class="op">{</span></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> <span class="op">&amp;</span>sum<span class="op">;</span></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="kw">operator</span><span class="op">()</span> <span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> x<span class="op">;</span></span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>    Func func<span class="op">{</span>sum<span class="op">};</span></span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 对 vec 的每个对象 x，调用 func(x)</span></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>for_each<span class="op">(</span>vec<span class="op">.</span>begin<span class="op">(),</span> vec<span class="op">.</span>end<span class="op">(),</span> func<span class="op">);</span></span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>我们通过这种方式，可以在封装函数的同时，读写局部变量。这解决了“只能通过全局变量交换数据”的问题。</p>
<p>但是封装仿函数还是过于麻烦，所以 C++11 引入了 lambda
函数，作为更加方便的替代。lambda 在本质上还是基于仿函数实现。</p>
<p>定义一个 lambda
函数，分为以下三个部分：捕获列表，参数列表，函数体。</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> lambda <span class="op">=</span> <span class="op">[</span><span class="co">/*捕获列表*/</span><span class="op">](</span><span class="co">/*参数列表*/</span><span class="op">)</span> <span class="op">{</span> <span class="co">/*函数体*/</span> <span class="op">};</span></span></code></pre></div>
<p>lambda 函数的类型无法表示（编译器自动生成），必须使用 auto
来接收它。此后可以使用 decltype 获取它的类型。每个 lambda
函数的类型都互不相同。</p>
<p>以上文的仿函数 <code>Func</code> 为例，它其实相当于“捕获”了局部变量
<code>sum</code>，从而可以对它进行读写。lambda
函数的捕获分为两种，按值捕获、按引用捕获。参考以下示例：</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">{},</span> b<span class="op">{};</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>a<span class="op">]()</span> <span class="op">{</span> a <span class="op">=</span> <span class="dv">4</span><span class="op">;</span>  <span class="co">/* 错误，按值捕获不能修改 */</span> <span class="op">};</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">[&amp;</span>a<span class="op">]()</span> <span class="op">{</span> a <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">/* 按引用捕获，会同步修改外部的 a */</span> <span class="op">};</span></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">[</span>b<span class="op">,</span> <span class="op">&amp;</span>a<span class="op">]()</span> <span class="op">{</span> <span class="co">/* 可以部分变量按值捕获，部分按引用捕获 */</span> <span class="op">};</span></span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">[&amp;]()</span> <span class="op">{</span> a <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> b <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">/* 当前作用域内，全部按引用捕获 */</span> <span class="op">};</span></span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">[=]()</span> <span class="op">{</span> <span class="co">/* 全部按值捕获 */</span> <span class="op">};</span></span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">[]()</span> <span class="op">{</span> global <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">/* 全局变量，不进行捕获也可以读写 */</span> <span class="op">};</span></span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>lambda 函数和普通函数的运行时开销相同，经过内联优化后均为零开销。</p>
<p>借助 lambda
函数，可以完美地解决一开始提到的问题。这使得我们可以方便地在函数内部封装子函数，无需依赖全局变量。消除全局变量，可以从根源上解决“多组测试忘记清空数组”这样的问题。</p>
<p>C++14 起，lambda 函数的参数列表可以使用 <code>auto</code>
代替参数类型，表示这个位置允许接收任意类型的参数。这个功能本质上是基于模板实现的。C++20
起，普通函数也添加了这个功能。例如 <code>sort</code>
的比较函数，现在可以这样写。</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>sort<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="kw">auto</span> x<span class="op">,</span> <span class="kw">auto</span> y<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">.</span>a <span class="op">&lt;</span> y<span class="op">.</span>a<span class="op">;</span> <span class="op">});</span></span></code></pre></div>
<p>lambda
函数的唯一问题可能是递归比较麻烦，无法直接支持递归。我常用的方法是，额外传递一个
<code>self</code> 参数，通过它进行递归调用。</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> fac <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">?</span> x <span class="op">*</span> fac<span class="op">(</span>x <span class="op">-</span> <span class="dv">1</span><span class="op">):</span> <span class="dv">1</span><span class="op">;</span> <span class="op">};</span>  <span class="co">// 编译失败</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> fac <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">int</span> x<span class="op">,</span> <span class="kw">auto</span> <span class="op">&amp;</span>self<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">?</span> x <span class="op">*</span> self<span class="op">(</span>x <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> self<span class="op">):</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// 个人常用的写法，调用的时候需要 fac(5, fac) 的形式</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">int</span><span class="op">(</span><span class="dt">int</span><span class="op">)&gt;</span> fac <span class="op">=</span> <span class="op">[&amp;](</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">?</span> x <span class="op">*</span> fac<span class="op">(</span>x <span class="op">-</span> <span class="dv">1</span><span class="op">):</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// 不推荐，有运行时开销</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> fac <span class="op">=</span> <span class="op">[&amp;](</span><span class="kw">this</span> <span class="kw">auto</span> fac<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">?</span> x <span class="op">*</span> self<span class="op">(</span>x <span class="op">-</span> <span class="dv">1</span><span class="op">):</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span>  <span class="co">// C++23 起，可以直接 fac(5) 调用</span></span></code></pre></div>
<p>经过测试，这种函数递归写法的效率和普通函数递归没有差异。</p>
<h2 id="类和结构体">类和结构体</h2>
<p>有些情况下，我们需要处理几个关联很大的数据（例如分数的分子和分母），便可以封装一个类（class），把它们组合到一起统一管理。在
C++ 中，结构体和类几乎没有区别，通常可以混用。</p>
<h3 id="类的基本使用">类的基本使用</h3>
<p>类的定义使用 <code>class</code> 或 <code>struct</code>
关键字。为了方便，我们先使用 <code>struct</code>
来定义类，后面会提到它们的区别。</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Frac <span class="op">{</span>  <span class="co">// 分数</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 数据成员</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nume<span class="op">;</span>  <span class="co">// 分子</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> deno<span class="op">;</span>  <span class="co">// 分母</span></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>接下来，便可以把这个类作为一个独立的类型来使用。通过
<code>item.member_name</code> 可以访问它的数据成员。</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>Frac x<span class="op">{};</span>  <span class="co">// 值初始化</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>x<span class="op">.</span>nume <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x<span class="op">.</span>nume<span class="op">;</span>  <span class="co">// 输出 5</span></span></code></pre></div>
<p>根据先前所讲的知识，这样的简单类属于“聚合类型”，可以直接使用聚合初始化来为它提供初始值。例如
<code>Frac{2, 3}</code>，将会使用这些参数，按照声明顺序初始化类的成员。</p>
<p>对于一个指向 <code>Frac</code> 对象的指针，可以使用
<code>-&gt;</code> 运算符来访问成员。通常 <code>ptr-&gt;member</code>
可以看作和 <code>(*ptr).member</code> 等价。</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>Frac x<span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>Frac <span class="op">*</span>ptr <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> ptr<span class="op">-&gt;</span>nume<span class="op">;</span>  <span class="co">// 相当于 x.nume</span></span></code></pre></div>
<h3 id="成员函数">成员函数</h3>
<p>有些情况下，我们可能会写出这样的函数。</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reciprocal<span class="op">(</span>Frac <span class="op">&amp;</span>f<span class="op">)</span> <span class="op">{</span>  <span class="co">// 把 f 变成它的倒数</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>swap<span class="op">(</span>f<span class="op">.</span>nume<span class="op">,</span> f<span class="op">.</span>deno<span class="op">);</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 使用：</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>Frac f<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a>reciprocal<span class="op">(</span>f<span class="op">);</span></span></code></pre></div>
<p>C++
支持“成员函数”（又称成员方法），从而可以通过另一种方式来定义和使用这个函数。</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Frac <span class="op">{</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> reciprocal<span class="op">()</span> <span class="op">{</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>nume<span class="op">,</span> deno<span class="op">);</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="co">// 使用：</span></span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>Frac f<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>f<span class="op">.</span>reciprocal<span class="op">();</span></span></code></pre></div>
<p>成员函数会在一个对象上进行操作，可以直接通过成员的名称，来访问当前对象上的成员。例如在
<code>f</code> 上调用 <code>reciprocal</code> 成员函数时，其中的
<code>nume</code> 就是 <code>f.nume</code>，<code>deno</code> 就是
<code>f.deno</code>。</p>
<p>成员函数中，还可以通过关键字 <code>this</code>
获得一个指针，指向当前对象。也可以使用 <code>this-&gt;nume</code>
这样的方式来访问成员。</p>
<p>成员函数也可以指定为
<code>const</code>，相当于普通函数传入常量引用，具体见以下的例子。</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Frac <span class="op">{</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="kw">this</span><span class="op">-&gt;</span>nume <span class="op">&lt;&lt;</span> <span class="ch">'/'</span> <span class="op">&lt;&lt;</span> <span class="kw">this</span><span class="op">-&gt;</span>deno <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="co">// 等价于</span></span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print<span class="op">(</span><span class="at">const</span> Frac <span class="op">&amp;</span>f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> f<span class="op">.</span>nume <span class="op">&lt;&lt;</span> <span class="ch">'/'</span> <span class="op">&lt;&lt;</span> f<span class="op">.</span>deno <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>成员函数也可以是重载运算符。调用时，将会以自身作为第一操作数，参数作为后续操作数。部分特殊的重载运算符只能是成员函数。</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Frac <span class="op">{</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">+</span> <span class="op">(</span>Frac <span class="at">const</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">-&gt;</span> Frac <span class="op">{</span></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>nume <span class="op">*</span> other<span class="op">.</span>deno <span class="op">+</span> deno <span class="op">*</span> other<span class="op">.</span>nume<span class="op">,</span> deno <span class="op">*</span> other<span class="op">.</span>deno<span class="op">};</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a><span class="co">// 使用</span></span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>Frac<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">}</span> <span class="op">+</span> Frac<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span>  <span class="co">// Frac{5, 6}</span></span></code></pre></div>
<p>成员函数也可以先声明再定义。通过类名访问一个成员，需要使用作用域访问运算符（<code>::</code>）。</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Frac <span class="op">{</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> print<span class="op">()</span> <span class="at">const</span><span class="op">;</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Frac<span class="op">::</span>print<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb96-6"><a href="#cb96-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Frac"</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb96-7"><a href="#cb96-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="成员可访问性">成员可访问性</h4>
<p>从本质上讲，成员函数和普通函数几乎没有区别。那么它除了看起来比较好看，还有什么意义呢？</p>
<p>一些情况下，我们不希望一个对象的数据成员被外部程序修改（例如实现一个
<code>vector</code>，需要维护存储区的指针和大小，而随意修改它会严重威胁安全性）。</p>
<p>为了解决这个问题，C++
引入了“成员可访问性”的概念。一个成员，可以指定在什么范围内可被访问。</p>
<ul>
<li><code>public</code>：公开。这个成员可以被外部代码访问。</li>
<li><code>private</code>：私有。这个成员只能在当前类的内部访问。</li>
<li><code>protected</code>：受保护。这个成员只能在当前类，或者派生类的内部访问（关于“派生类”相关知识，见下文）。</li>
</ul>
<p>通过以下方式指定成员的可访问性：</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a1<span class="op">;</span>  <span class="co">// 默认可访问性</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> a2<span class="op">;</span></span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> a3<span class="op">;</span>  <span class="co">// 接下来都是 private</span></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> <span class="op">*</span>a4<span class="op">;</span>  <span class="co">// private</span></span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a5<span class="op">[</span><span class="dv">3</span><span class="op">];</span>  <span class="co">// public</span></span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>默认可访问性取决于使用 <code>class</code> 还是 <code>struct</code>
关键字声明这个类。<code>struct</code> 则为
<code>public</code>，<code>class</code> 则为 <code>private</code>。</p>
<h3 id="构造函数">构造函数</h3>
<p>构造函数是一类特殊的函数，当一个对象通过任何方式初始化的时候，会自动调用它的构造函数。构造函数负责给各个成员提供初始值。</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Frac <span class="op">{</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>    Frac<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">:</span></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a>            nume<span class="op">(</span>x<span class="op">),</span>  <span class="co">// 成员初始化器</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>            deno<span class="op">{</span>y<span class="op">}</span> <span class="op">{</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"构造了一个 Frac 对象"</span><span class="op">;</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>声明构造函数时，函数名部分与类名相同，不能标注返回值类型。</p>
<p>构造函数分为成员初始化器和函数体两个部分。初始化器可以是任意初始化形式（直接初始化、列表初始化等）。初始化对象的时候，首先通过初始化器，<strong>按照在类中的声明顺序</strong>初始化所有成员，接下来开始执行函数体。</p>
<p>成员初始化器，其求值时的作用域和构造函数的函数体相同。简单来讲，它允许了以下操作：</p>
<div class="sourceCode" id="cb99"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">):</span></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>            x<span class="op">(</span>x<span class="op">),</span> y<span class="op">(</span>y<span class="op">)</span> <span class="co">// 括号外的 x 和 y 是成员名，里面的是参数名</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 如同在函数体中使用 x 或 y，都是指代参数名</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>除此以外，可以在声明成员的时候提供一个默认初始化器。当没有提供初始化器的时候，将会使用这个默认初始化器进行初始化。例如：</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Frac <span class="op">{</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> nume<span class="op">;</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> deno <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// 默认成员初始化器</span></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>    Frac<span class="op">(</span><span class="dt">int</span> x<span class="op">):</span> nume<span class="op">(</span>x<span class="op">)</span> <span class="op">{}</span>  <span class="co">// deno 将会初始化为 1</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>既没有没有初始化器、也没有默认初始化器的成员，会被执行默认初始化。也就是说，这可能导致部分成员<strong>持有未定义的值或错误值</strong>，或者在部分成员无法默认初始化的情况下，导致编译错误。更加致命的是，即使值初始化外层对象，这些被默认初始化的成员也不会赋值为零。</p>
<p>还有人会选择在构造函数的函数体中给数据成员赋值。这种方式可行但不推荐，提供初始化器是更加安全、便捷和高效的做法，尤其是对于复杂类型的成员。</p>
<p>通常情况下，建议给所有的成员都在声明时提供默认初始化器，例如值初始化
<code>member{}</code> 或者提供一个默认值 <code>member = 0</code>
来规避这个问题。</p>
<p>同一个类可以提供多个构造函数，通过重载决议区分。</p>
<p>有一些构造函数具有特殊的名字和语义，具体如下：</p>
<ul>
<li><code>T()</code>：默认构造函数。用在值初始化等场合。</li>
<li><code>T(const T &amp;)</code>：复制构造函数。用于复制一个对象。</li>
<li><code>T(T &amp;&amp;)</code>：移动构造函数。（涉及右值引用相关知识）</li>
</ul>
<p>而且，这些构造函数通常都会被编译器自动生成，除非有成员不支持对应操作。</p>
<p>可以通过 <code>T() = default;</code>
这种形式来显式生成这些构造函数。</p>
<p>在 OI
中，很多情况都不需要给简单的结构体定义构造函数。根据聚合初始化相关规则，只有几个公开数据成员的结构体属于“聚合体”，可以直接用花括号形式初始化。详见前文相关章节。</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span> <span class="dt">double</span> y<span class="op">;</span> <span class="dt">char</span> z<span class="op">;</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>A a1<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">,</span> <span class="ch">'c'</span><span class="op">};</span> <span class="co">// 正确</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>A a2<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="fl">2.0</span><span class="op">};</span> <span class="co">// 正确，等价于 {1, 2.0, '\0'}</span></span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a><span class="co">// 函数传参</span></span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>A a<span class="op">,</span> <span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a>f<span class="op">({</span><span class="dv">3</span><span class="op">,</span> <span class="fl">4.0</span><span class="op">,</span> <span class="ch">'.'</span><span class="op">},</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// 正确</span></span></code></pre></div>
<h4 id="显式构造函数">显式构造函数</h4>
<p>只接受一个参数的构造函数，可以用于隐式类型转换。但是我们可能并不希望这样。</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> x<span class="op">):</span> x<span class="op">(</span>x<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>A x<span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="dv">5</span><span class="op">);</span> <span class="co">// 相当于 f(A{5});</span></span></code></pre></div>
<p>这样会降低代码可读性，也会令人困惑。将构造函数声明为
<code>explicit</code> 即可避免这样的问题。标记为 <code>explicit</code>
的构造函数，不会用于函数传参、返回值、复制初始化等场景。</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> A<span class="op">(</span><span class="dt">int</span> x<span class="op">):</span> x<span class="op">(</span>x<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>A x<span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="dv">5</span><span class="op">);</span> <span class="co">// 编译错误</span></span></code></pre></div>
<p>建议单个参数的构造函数均使用 <code>explicit</code>
修饰，除非真的想要用于隐式转换。</p>
<p>以下案例可以演示 <code>explicit</code> 构造函数的重要性。</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">{},</span> y<span class="op">{};</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> x<span class="op">):</span> x<span class="op">(</span>x<span class="op">)</span> <span class="op">{}</span>  <span class="co">// 没有使用 explicit 修饰</span></span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">):</span> x<span class="op">(</span>x<span class="op">),</span> y<span class="op">(</span>y<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span>A<span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// vector 的 insert 可以接收一个 std::initializer_list 来插入多项</span></span>
<span id="cb104-14"><a href="#cb104-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 此处相当于插入 A{2} 和 A{3}</span></span>
<span id="cb104-15"><a href="#cb104-15" aria-hidden="true" tabindex="-1"></a>    v<span class="op">.</span>insert<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">});</span></span>
<span id="cb104-16"><a href="#cb104-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> v<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span>  <span class="co">// 插入了 2 个元素</span></span>
<span id="cb104-17"><a href="#cb104-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>将单参数的构造函数设定为
<code>explicit</code>，则行为正常，只插入一个元素。这种情况下，希望插入两个元素，需要这样写：</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>insert<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> <span class="op">{</span>A<span class="op">{</span><span class="dv">2</span><span class="op">},</span> A<span class="op">{</span><span class="dv">3</span><span class="op">}});</span></span></code></pre></div>
<h4 id="委托构造函数">委托构造函数</h4>
<p>C++11
开始支持“委托构造函数”语法，可以直接调用当前类的其他构造函数。</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Rectangle <span class="op">{</span></span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> width<span class="op">{};</span></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> height<span class="op">{};</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>    Rectangle<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>    Rectangle<span class="op">(</span><span class="dt">int</span> size<span class="op">):</span> Rectangle<span class="op">(</span>size<span class="op">,</span> size<span class="op">)</span> <span class="op">{}</span>  <span class="co">// 正方形</span></span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a>    Rectangle<span class="op">(</span><span class="dt">int</span> width<span class="op">,</span> <span class="dt">int</span> height<span class="op">):</span> width<span class="op">{</span>width<span class="op">},</span> height<span class="op">{</span>height<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>要求有一个初始化器为当前类名，然后传入相应的参数。此时不能再包含其他的初始化器。</p>
<h3 id="析构函数">析构函数</h3>
<p>当一个对象的生存期结束后，会自动调用它的析构函数，例如以下场景：</p>
<ul>
<li>局部变量的作用域结束时。</li>
<li>静态变量在程序结束时。</li>
<li>delete 释放动态分配的对象。</li>
</ul>
<p>析构函数按照如下方式定义：</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-3"><a href="#cb107-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb107-4"><a href="#cb107-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>A<span class="op">()</span> <span class="op">{</span>  <span class="co">// 无参数、无返回值</span></span>
<span id="cb107-5"><a href="#cb107-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"~A()"</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb107-6"><a href="#cb107-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb107-7"><a href="#cb107-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb107-8"><a href="#cb107-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb107-9"><a href="#cb107-9" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb107-10"><a href="#cb107-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb107-11"><a href="#cb107-11" aria-hidden="true" tabindex="-1"></a>        A a<span class="op">;</span></span>
<span id="cb107-12"><a href="#cb107-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb107-13"><a href="#cb107-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="co">// 此时 a 被销毁，调用析构函数</span></span>
<span id="cb107-14"><a href="#cb107-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="dv">2</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb107-15"><a href="#cb107-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>输出结果：</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="op">~</span>A<span class="op">()</span></span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span></code></pre></div>
<p>绝大多数情况下都不需要显式定义析构函数，编译器会生成一个不做任何事情的默认析构函数。在析构函数执行之后，将会依次执行所有成员的析构函数。（于生命顺序相反）</p>
<p>需要析构函数的场景，通常是这个类在“管理”某个资源的时候，这个资源在对象初始化时获取，在对象销毁时释放。</p>
<p>例如以下的场景中，就必须使用析构函数来保证内存被成功释放。</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> DynamicArray <span class="op">{</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>data <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>    DynamicArray<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>    DynamicArray<span class="op">(</span><span class="bu">std::</span>size_t size<span class="op">):</span> data<span class="op">(</span><span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>size<span class="op">]{})</span> <span class="op">{}</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>DynamicArray<span class="op">()</span> <span class="op">{</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> data<span class="op">;</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">[]</span> <span class="op">(</span><span class="bu">std::</span>size_t index<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> data<span class="op">[</span>index<span class="op">];</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h4 id="raii">RAII</h4>
<p>通过“析构函数”的设计，我们可以感受到 C++
中的一个重要设计思想——RAII（资源获取即初始化）。这种设计方式可以通过局部对象来管理资源，让动态资源的生命周期与一个局部对象绑定，通过局部变量的初始化获取资源、局部变量的析构释放资源。</p>
<p>对于一个动态资源，往往要经历获取、使用、释放这三个步骤。而“释放”往往是最容易被遗漏的。可能因为：</p>
<ul>
<li>程序员忘记释放。</li>
<li>控制流中断，导致没有执行释放语句。（例如提前
return，或者中途抛出异常）</li>
</ul>
<p>而显然，由于局部对象的析构不可绕过，RAII 完美的解决了这个问题。</p>
<p>C++ 标准库的很多工具都利用了这种设计。例如 <code>vector</code>
的动态内存，通过局部的 <code>vector</code>
对象管理，会在调用析构函数时释放。</p>
<h3 id="静态成员">静态成员</h3>
<p>静态成员是指一部分和类相关的成员，而与实际对象无关。即同一个类中，所有的静态成员共用一个值。静态成员使用
<code>static</code> 关键字声明。</p>
<p>静态成员的生命周期会持续到程序结束，存储在静态存储区中。</p>
<h4 id="数据成员">数据成员</h4>
<div class="sourceCode" id="cb110"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> count<span class="op">;</span>  <span class="co">// 声明</span></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>    S<span class="op">()</span> <span class="op">{</span> count<span class="op">++;</span> <span class="op">}</span></span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>S<span class="op">()</span> <span class="op">{</span> count<span class="op">--;</span> <span class="op">}</span></span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> S<span class="op">::</span>count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// 定义</span></span></code></pre></div>
<p>以上代码展示了静态数据成员的用法，这实现了一个计数器，记录当前存在的
<code>S</code> 类型对象个数。</p>
<p>静态数据成员需要在类外提供一个唯一的定义。但是存在特例，<code>constexpr</code>
的数据成员可以直接声明时定义。以及 C++17 起，可以使用
<code>inline</code>，允许在大多数场景下，声明的同时定义静态数据成员。</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">inline</span> <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">int</span> maxCount <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h4 id="成员函数-1">成员函数</h4>
<p>静态成员函数，是一类和具体实例无关的函数，无法使用 <code>this</code>
指针和其他非静态成员。</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="dt">int</span> pow<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">,</span> <span class="dt">int</span> mod<span class="op">)</span> <span class="co">/*不可以加 const*/</span> <span class="op">{</span></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> res <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(;</span> b <span class="op">!=</span> <span class="dv">0</span><span class="op">;</span> b <span class="op">&gt;&gt;=</span> <span class="dv">1</span><span class="op">,</span> a <span class="op">=</span> a <span class="op">*</span> a <span class="op">%</span> mod<span class="op">)</span> <span class="op">{</span></span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>b <span class="op">&amp;</span> <span class="dv">1</span><span class="op">)</span> res <span class="op">=</span> res <span class="op">*</span> a <span class="op">%</span> mod<span class="op">;</span></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>显然这个快速幂函数，并不会用到对象的状态，所以可以声明为静态的。</p>
<h3 id="嵌套类">嵌套类</h3>
<p>C++
支持嵌套类，即可以在一个类中声明其他的类。嵌套类的对象，和外层类的对象之间不发生绑定，即不可以在嵌套类中直接使用外层类的成员。</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Outer <span class="op">{</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a<span class="op">,</span> b<span class="op">;</span></span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Inner <span class="op">{</span></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> c<span class="op">,</span> d<span class="op">;</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>例如这个例子中，可以使用 <code>Outer::Inner{}</code>
来创建一个嵌套类的对象。但是这个对象中只包括 <code>c</code> 和
<code>d</code> 两个数据成员，不包括 <code>a</code> 和
<code>b</code>，自然也不能使用它。</p>
<h3 id="继承">继承</h3>
<p>继承是面向对象编程的重要概念，可以用于增强代码复用。在 C++
中，可以让一个派生类继承于一个基类，然后派生类就可以获得基类的所有成员变量和方法。</p>
<p>继承的语法如下：</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 基类</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"f()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 派生类</span></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Derived <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{</span></span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> g<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"g()</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>在 C++
中，使用冒号表示继承关系。基类名之前，紧接一个可访问性标识符，表示继承而来的所有成员，其可访问性不会高于这个权限。即对于基类的
<code>protected</code>/<code>public</code> 成员，存在如下规则。</p>
<ul>
<li><code>public</code>：保留原有访问权限。</li>
<li><code>protected</code>：访问权限变为 <code>protected</code>。</li>
<li><code>private</code>：访问权限变为 <code>private</code>。</li>
</ul>
<p>基类 <code>private</code> 的成员，无法在派生类中访问。</p>
<p>如果不填写这个访问权限，则根据类的声明方式，<code>struct</code>
默认为 <code>public</code>，<code>class</code> 默认为
<code>private</code>。</p>
<p>在以上例子中，可以从 <code>Derived</code> 类调用继承而来的成员函数
<code>f()</code>。</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>Derived d<span class="op">;</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>d<span class="op">.</span>f<span class="op">();</span>  <span class="co">// f()</span></span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>d<span class="op">.</span>g<span class="op">();</span>  <span class="co">// g()</span></span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>d<span class="op">.</span>Base<span class="op">::</span>f<span class="op">();</span>  <span class="co">// f()，显式指定继承路径</span></span></code></pre></div>
<p>以下的例子，展现了继承的更详细用法。</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ASCIIArt <span class="op">{</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> size <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>  <span class="co">// 图形大小</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> fillChar <span class="op">=</span> <span class="ch">'*'</span><span class="op">;</span>  <span class="co">// 填充字符</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>    ASCIIArt<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>    ASCIIArt<span class="op">(</span><span class="dt">int</span> size<span class="op">,</span> <span class="dt">char</span> fillChar<span class="op">)</span> <span class="op">:</span> size<span class="op">(</span>size<span class="op">),</span> fillChar<span class="op">(</span>fillChar<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> setFill<span class="op">(</span><span class="dt">char</span> ch<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>        fillChar <span class="op">=</span> ch<span class="op">;</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Square <span class="op">:</span> <span class="kw">public</span> ASCIIArt <span class="op">{</span></span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>    Square<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a>    Square<span class="op">(</span><span class="dt">int</span> size<span class="op">,</span> <span class="dt">char</span> fillChar<span class="op">)</span> <span class="op">:</span> ASCIIArt<span class="op">(</span>size<span class="op">,</span> fillChar<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> draw<span class="op">()</span> <span class="at">const</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> size<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> size<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> fillChar<span class="op">;</span></span>
<span id="cb116-23"><a href="#cb116-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb116-24"><a href="#cb116-24" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb116-25"><a href="#cb116-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb116-26"><a href="#cb116-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb116-27"><a href="#cb116-27" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>在构造派生类的时候，需要调用基类的构造函数（如果没有显式指定，则会尝试调用默认构造）。在以上的例子中，构造函数
<code>Square(int size, char fillChar)</code> 的初始化器
<code>ASCIIArt(size, fillChar)</code>
就是在初始化基类，包含基类名和初始化语句。</p>
<p>在派生类完成析构之后，也会自动调用基类的析构函数。</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>Square square<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="ch">'*'</span><span class="op">);</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>square<span class="op">.</span>setFill<span class="op">(</span><span class="ch">'#'</span><span class="op">);</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>square<span class="op">.</span>draw<span class="op">();</span></span></code></pre></div>
<p>派生类中的成员，会隐藏基类中的同名成员（如果有）。对于成员函数，这二者之间并不会发生重载。例如以下代码：</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Base</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Derived <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Derived</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>在这个情况下，在 <code>Derived</code> 对象上调用成员函数
<code>f()</code> 会直接报错，而不是调用基类的实现。</p>
<p>可以通过这样的方式，来绘制 5 行 5 列，使用 <code>#</code>
填充的正方形。</p>
<p>C++
还支持多继承，允许一个派生类继承于多个基类，获得它们的所有成员。具体方式如下：</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> C <span class="op">:</span> <span class="kw">public</span> A<span class="op">,</span> <span class="kw">public</span> B <span class="op">{};</span></span></code></pre></div>
<p>多继承可能出现“菱形继承”的问题，例如以下示意图，靠下的表示派生类：</p>
<pre><code>   A
  / \
 B   C
  \ /
   D</code></pre>
<p>这种情况下，D 会持有两份 A 中的数据（一份从 B 继承，一份从 C
继承），导致无法正常使用。这种情况下，可以使用虚继承来解决。</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{};</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> B <span class="op">:</span> <span class="kw">virtual</span> <span class="kw">public</span> A <span class="op">{};</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> C <span class="op">:</span> <span class="kw">virtual</span> <span class="kw">public</span> A <span class="op">{};</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> D <span class="op">:</span> <span class="kw">public</span> B<span class="op">,</span> <span class="kw">public</span> C <span class="op">{};</span></span></code></pre></div>
<p>这样，在一个 <code>D</code> 的对象中，只会保存一份 <code>A</code>
的数据。然而虚继承会引入运行时开销，并且降低可读性，所以要尽量避免菱形继承。</p>
<p>使用 <code>static_cast</code>
可以在派生类指针和基类指针之间互相转换。从派生类到基类指针（向上转型）总是安全的，从基类到派生类（向下转型），如果和实际的对象类型不一致，则是未定义行为。对于向下转型，更加安全的方式是下文提到的
<code>dynamic_cast</code>。对于多继承的对象，使用
<code>reinterpret_cast</code> 反而会出现问题。</p>
<h3 id="多态">多态</h3>
<p>多态（Polymorphism）是面向对象编程的另一个重要概念。多态是指，基类的成员函数，在运行时可以根据实际类型，表现出不同派生类的行为。具体来讲：</p>
<ul>
<li>派生类可以覆写基类的成员函数。</li>
<li>通过基类的<strong>指针或引用</strong>，指向派生类的对象。</li>
<li>调用某个成员函数的时候，实际调用的是被派生类覆盖的版本。</li>
<li>C++ 中，多态使用虚函数和继承机制实现。</li>
</ul>
<p>以下是一个反例，可以说明不使用虚函数的情况下，直接用同名成员隐藏基类成员，并不能真正实现多态。</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Base</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Derived <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{</span></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 反例：通常情况下，派生类函数不能真正“覆盖”（Override）基类函数</span></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Derived</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb122-15"><a href="#cb122-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-16"><a href="#cb122-16" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> caller<span class="op">(</span>Base <span class="op">&amp;</span>obj<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb122-17"><a href="#cb122-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 这里的 Base 类，和 Base::f() 函数之间静态绑定，所以输出 Base</span></span>
<span id="cb122-18"><a href="#cb122-18" aria-hidden="true" tabindex="-1"></a>    obj<span class="op">.</span>f<span class="op">();</span></span>
<span id="cb122-19"><a href="#cb122-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb122-20"><a href="#cb122-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-21"><a href="#cb122-21" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb122-22"><a href="#cb122-22" aria-hidden="true" tabindex="-1"></a>    Derived obj<span class="op">;</span></span>
<span id="cb122-23"><a href="#cb122-23" aria-hidden="true" tabindex="-1"></a>    caller<span class="op">(</span>obj<span class="op">);</span></span>
<span id="cb122-24"><a href="#cb122-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-25"><a href="#cb122-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 此时在 Derived 上调用 f()，Derived::f() 只是会“隐藏”Base::f()，输出 Derived</span></span>
<span id="cb122-26"><a href="#cb122-26" aria-hidden="true" tabindex="-1"></a>    obj<span class="op">.</span>f<span class="op">();</span></span>
<span id="cb122-27"><a href="#cb122-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>为了实现这个需求，C++
引入了虚函数。虚函数可以实现动态绑定，和真正意义上的“覆盖”基类方法。在基类中指定某个成员函数为
<code>virtual</code>，即可把它声明为虚函数，让它可以被覆盖。在派生类上，使用
<code>override</code> 声明，确保发生覆盖。</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">{};</span></span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">virtual</span> f<span class="op">()</span> <span class="at">const</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Base</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Derived <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{</span></span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> y<span class="op">{};</span></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f<span class="op">()</span> <span class="at">const</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="kw">override</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Derived</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>如果使用后置类型声明，需要注意 <code>override</code>
关键字需要紧贴函数体的花括号，和指定 <code>const</code>
的位置不同。派生类函数想要重写基类函数，需要调用签名完全相同（参数类型、返回值类型等）。</p>
<p>接下来便可以使用这种动态绑定机制了。</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> caller<span class="op">(</span>Base <span class="op">&amp;</span>b<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>    b<span class="op">.</span>f<span class="op">();</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>    Derived d<span class="op">;</span></span>
<span id="cb124-7"><a href="#cb124-7" aria-hidden="true" tabindex="-1"></a>    caller<span class="op">(</span>d<span class="op">);</span>  <span class="co">// 输出 Derived</span></span>
<span id="cb124-8"><a href="#cb124-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><code>override</code>
是可选的，但是十分推荐使用，如果覆写失败会导致编译错误，不会导致更加难以排查的逻辑错误。</p>
<p>需要注意的是，如果发生值复制（例如把 <code>caller</code>
从引用改成传值）会导致虚函数失效，全部指向 <code>Base</code>
中的实现。</p>
<h4 id="虚函数的本质">虚函数的本质</h4>
<p>每个包含虚函数的类，编译器都会为其生成虚函数表，虚函数表中会存储若干个函数指针。所有虚函数都是通过这些函数指针间接调用的，所以可能会产生一些运行时开销。对应地，非虚函数调用是直接绑定，没有额外开销。</p>
<p>包含虚函数的对象，开头会维护一个指针，指向属于它的虚函数表。</p>
<p>例如上面的例子，<code>Base</code> 对象的内存布局为：</p>
<pre><code>[ vptr1 | x ]
  ↓
f: Base::f()</code></pre>
<p><code>Derived</code> 对象的内存布局为：</p>
<pre><code>[ vptr2 | x | y ]
  ↓
f: Derived::f()</code></pre>
<p>当 <code>Derived</code> 对象的引用转换为 <code>Base</code>
类型时，不会影响已经存储的虚表指针。通过 <code>Base</code>
类型调用虚函数时，依旧会先通过虚表指针访问对应的虚函数表，然后寻找指定的函数进行调用。对应到这个例子，就是通过
<code>vptr2</code> 得到实际指向的函数是 <code>Derived::f</code>
然后调用它。</p>
<p>为什么在传值时就会失效？此时会调用
<code>Base(Base const &amp;)</code>
进行复制，而编译器生成的复制构造函数，是构造一个新的 <code>Base</code>
对象，逐个复制成员，不关心虚表指针。所以新的对象会有自己的虚表指针，指向
<code>Base</code>。这个过程又被称为“对象切片”。</p>
<h4 id="虚析构函数">虚析构函数</h4>
<p>考虑以下场景：</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> id<span class="op">{};</span></span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>    Base<span class="op">(</span><span class="dt">int</span> id<span class="op">):</span> id<span class="op">(</span>id<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">virtual</span> f<span class="op">()</span> <span class="at">const</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"User id = "</span> <span class="op">&lt;&lt;</span> id <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb127-7"><a href="#cb127-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb127-8"><a href="#cb127-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-9"><a href="#cb127-9" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Derived <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{</span></span>
<span id="cb127-10"><a href="#cb127-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string name<span class="op">;</span></span>
<span id="cb127-11"><a href="#cb127-11" aria-hidden="true" tabindex="-1"></a>    Derived<span class="op">(</span><span class="dt">int</span> id<span class="op">,</span> <span class="bu">std::</span>string <span class="at">const</span> <span class="op">&amp;</span>name<span class="op">):</span> Base<span class="op">(</span>id<span class="op">),</span> name<span class="op">(</span>name<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb127-12"><a href="#cb127-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> f<span class="op">()</span> <span class="at">const</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb127-13"><a href="#cb127-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"User id = "</span> <span class="op">&lt;&lt;</span> id <span class="op">&lt;&lt;</span> <span class="st">" name = "</span> <span class="op">&lt;&lt;</span> name <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb127-14"><a href="#cb127-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb127-15"><a href="#cb127-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb127-16"><a href="#cb127-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb127-17"><a href="#cb127-17" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb127-18"><a href="#cb127-18" aria-hidden="true" tabindex="-1"></a>    Base <span class="op">*</span>ptr <span class="op">=</span> <span class="kw">new</span> Derived<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="st">"Admin"</span><span class="op">);</span></span>
<span id="cb127-19"><a href="#cb127-19" aria-hidden="true" tabindex="-1"></a>    ptr<span class="op">-&gt;</span>f<span class="op">();</span></span>
<span id="cb127-20"><a href="#cb127-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> ptr<span class="op">;</span></span>
<span id="cb127-21"><a href="#cb127-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>它看起来运行得非常正常，但其实有严重的问题。</p>
<p>首先，要知道 <code>std::string</code>
的存储是动态分配一块内存空间，然后维护一个指针指向它。而
<code>std::string</code> 的析构函数就是用于释放这片内存。</p>
<p>在 <code>delete ptr</code> 执行时，会调用 <code>Base</code>
的析构函数。而 <code>Base</code> 的析构函数并不会释放
<code>Derived</code> 里面额外定义的
<code>name</code>，导致字符串的存储区不被释放，从而内存泄漏。</p>
<p>解决这个问题的最好办法是，把析构函数设为虚函数。这样，执行
<code>delete</code>
时就可以通过虚函数表获得正确的析构函数，然后正确释放。</p>
<h4 id="动态类型识别">动态类型识别</h4>
<p>有些时候，我们会想要把基类的指针重新转换成派生类使用。如果实际上这个对象的类型不是目标类型，则会导致未定义行为（之前说到的“向下转型”）。<code>dynamic_cast</code>
提供了一种更加安全的解决方案。</p>
<p>能够使用 <code>dynamic_cast</code>
向下转型，要求基类至少有一个虚函数（因为会利用编译器创建的虚表信息），通常会选择把析构函数声明为虚函数。</p>
<p><code>dyncmic_cast</code>
向下转型，如果转换失败，根据转换类型不同，出现以下错误：</p>
<ul>
<li>如果是指针转换，返回 <code>nullptr</code>。</li>
<li>如果是引用转换，抛出 <code>std::bad_cast</code> 异常。</li>
</ul>
<div class="sourceCode" id="cb128"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Base <span class="op">{</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">virtual</span> <span class="op">~</span>Base<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Derived <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{};</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Derived2 <span class="op">:</span> <span class="kw">public</span> Base <span class="op">{};</span></span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>Derived x<span class="op">{};</span></span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>Base <span class="op">*</span>ptr <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>Base <span class="op">&amp;</span>ref <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a><span class="kw">dynamic_cast</span><span class="op">&lt;</span>Derived <span class="op">*&gt;(</span>ptr<span class="op">);</span>  <span class="co">// 转化成功</span></span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a><span class="kw">dynamic_cast</span><span class="op">&lt;</span>Derived2 <span class="op">*&gt;(</span>ptr<span class="op">);</span>  <span class="co">// 返回 nullptr</span></span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a><span class="kw">dynamic_cast</span><span class="op">&lt;</span>Derived2 <span class="op">&amp;&gt;(</span>ref<span class="op">);</span>  <span class="co">// 抛出异常</span></span></code></pre></div>
<h4 id="纯虚函数">纯虚函数</h4>
<p>基类的虚函数，可以不提供默认实现，此时被称为“纯虚函数”。包含纯虚函数的类被称为抽象类，不能直接实例化（创建这个类型的对象）。</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">virtual</span> f<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// = 0 指定为纯虚函数</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>抽象类只能通过其派生类对象，通过指针转化来使用。</p>
<h4 id="总结">总结</h4>
<p>如果使用 C++ 的多态类型，为了安全，应该遵守以下原则：</p>
<ul>
<li>始终使用 override 重写函数。</li>
<li>使用指针/引用操作对象，避免值复制。</li>
<li>基类析构函数声明为 <code>virtual</code>。</li>
<li>向下转型优先使用 <code>dynamic_cast</code>。</li>
</ul>
<h3 id="友元和可变声明">友元和可变声明</h3>
<h4 id="友元friend">友元（friend）</h4>
<p>C++
中，可以声明一个类的友元函数，它是一个自由函数，但是特许它访问这个类的
<code>protected</code> 和 <code>private</code> 成员。</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> x<span class="op">):</span> x<span class="op">{</span>x<span class="op">}</span> <span class="op">{}</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="dt">void</span> f<span class="op">(</span>A a<span class="op">);</span></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>A a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> a<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>友元函数也可以在声明的同时定义。这种情况下，这个函数只能通过实参依赖查找（ADL）使用。</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="dt">void</span> f<span class="op">(</span>A a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> a<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>友元函数的一个常见用途是重载输入/输出运算符，因为对象需要作为第二个操作数，所以只能是自由函数的形式。通过友元允许它访问私有成员。</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="kw">auto</span> <span class="op">&amp;</span><span class="kw">operator</span><span class="op">&lt;&lt;</span> <span class="op">(</span><span class="bu">std::</span>ostream <span class="op">&amp;</span>os<span class="op">,</span> A a<span class="op">)</span> <span class="op">{</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>        os <span class="op">&lt;&lt;</span> a<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> os<span class="op">;</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>也可以声明一个友元类。按照这样的方式声明，<code>B</code>
的所有成员函数都可以访问 <code>A</code> 的私有成员。</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">friend</span> <span class="kw">class</span> B<span class="op">;</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h4 id="可变成员mutable">可变成员（mutable）</h4>
<p>C++ 可以把一个成员设置为 <code>mutable</code>，使得即使在
<code>const</code> 的对象中，也可以修改这个数据成员。</p>
<p><code>mutable</code> 通常用于特殊场景，需要小心使用。不能因为修改
<code>muable</code> 而影响对象的外部表现。</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">mutable</span> <span class="dt">int</span> callCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> f<span class="op">()</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>        callCount<span class="op">++;</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>以下是 mutable 一个典型的<strong>错误用法</strong>。</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">mutable</span> <span class="dt">int</span> value<span class="op">;</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">&lt;</span> <span class="op">(</span>A other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> value <span class="op">&lt;</span> other<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>set<span class="op">&lt;</span>A<span class="op">&gt;</span> s<span class="op">;</span></span></code></pre></div>
<p>此处的比较函数依赖一个 <code>mutable</code> 的成员。如果
<code>value</code> 被修改，可能会导致 <code>set</code>
的平衡树形态错误，出现未定义行为。<code>set</code> 返回的对象是
<code>const</code>，这本身是一种保护机制，不应该通过
<code>mutable</code> 绕过。</p>
<h3 id="重载运算符-1">重载运算符</h3>
<p>在函数章节，我们已经介绍过重载运算符相关内容。接下来我们将会介绍一些扩展内容，以及一些编程习惯。</p>
<p>首先，一些运算符只能通过成员函数重载，包括
<code>-&gt;</code>（指针访问）、<code>=</code>（赋值）、<code>()</code>（函数调用）、<code>[]</code>（下标访问）。</p>
<p>对于自增自减运算符 <code>++</code> 和
<code>--</code>，可以分别重载其前缀和后缀形式。通过以下方式：</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++</span> <span class="op">()</span> <span class="op">{}</span>  <span class="co">// 前缀形式</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span>  <span class="co">// 后缀形式</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>即对于后缀形式，相当于调用 <code>operator++(a, 0)</code> 或者
<code>a.operator++(0)</code>。</p>
<p>建议前置自增和后置自增的逻辑和内置运算符保持一致。前置自增在函数体中执行自增，然后返回当前对象的引用。后置自增先保留一个副本，执行自增之后返回这个副本。</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value<span class="op">;</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++</span> <span class="op">()</span> <span class="op">-&gt;</span> A <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>value<span class="op">;</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">++</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">-&gt;</span> A <span class="op">{</span></span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> copy <span class="op">=</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span>value<span class="op">;</span></span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> copy<span class="op">;</span></span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>对于非基础类型的迭代器，如果不需要使用返回值（例如循环中的自增），建议使用前置自增来避免复制开销。如果是整数、指针这样的简单类型则没有任何区别，根据自己习惯使用即可。</p>
<p>同样地，赋值运算符、复合赋值运算符（<code>+=</code>
等）的行为也建议和内置运算符保持一致，返回自身的引用，便于链式复制。注意，通常不需要自行重载赋值运算符，编译器会自动生成逐个元素赋值。</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>data<span class="op">;</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t size<span class="op">;</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span>A <span class="at">const</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">-&gt;</span> A <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb138-6"><a href="#cb138-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb138-7"><a href="#cb138-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> data<span class="op">;</span></span>
<span id="cb138-8"><a href="#cb138-8" aria-hidden="true" tabindex="-1"></a>        size <span class="op">=</span> other<span class="op">.</span>size<span class="op">;</span></span>
<span id="cb138-9"><a href="#cb138-9" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>size<span class="op">];</span></span>
<span id="cb138-10"><a href="#cb138-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="bu">std::</span>size_t i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">!=</span> size<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb138-11"><a href="#cb138-11" aria-hidden="true" tabindex="-1"></a>            data<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> other<span class="op">.</span>data<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb138-12"><a href="#cb138-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb138-13"><a href="#cb138-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb138-14"><a href="#cb138-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb138-15"><a href="#cb138-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>此外，如果已经实现了相应构造函数，赋值函数可以使用“先构造再交换”的方式实现。这是一个很常用的方法。</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>data<span class="op">;</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t size<span class="op">;</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span>A <span class="at">const</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">-&gt;</span> A <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> tmp<span class="op">{</span>other<span class="op">};</span></span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>data<span class="op">,</span> tmp<span class="op">.</span>data<span class="op">);</span></span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span>size<span class="op">,</span> tmp<span class="op">.</span>size<span class="op">);</span>  <span class="co">// 如果实现了交换，可以直接调用</span></span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb139-13"><a href="#cb139-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb139-14"><a href="#cb139-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>为了保证异常安全，移动赋值、移动构造都应该为
<code>noexcept</code>。</p>
<h4 id="安全地使用引用参数">安全地使用引用参数</h4>
<p>我们上面的代码中，特判了 <code>a = a</code>
这样的自赋值场景。如果没有这个判断，将会出现十分严重的后果。两个对象共用一个
<code>data</code>，开始的时候执行
<code>delete[]</code>，原始数据就已经丢失了。尽管这种场景不常见，但对于
<code>a += a</code> 等操作也可能出现类似问题。</p>
<p>这也揭示了一个问题，<code>A const &amp;</code>
虽然很多场景可以替代值传递，但它本质上还是一个引用，和传值还是会有一些差异。所以使用指针/引用作为参数需要谨慎。</p>
<p>如果把对象的 <code>this</code>
指针也看成一个引用参数，这类问题都是来源于几个引用参数出现重叠。<strong>对于函数传参涉及指针/引用的情况，建议遵循以下安全规范</strong>。对于同类型的所有引用：</p>
<ul>
<li>要么所有的引用都是只读引用。（<code>const T &amp;</code>）</li>
<li>要么仅存在一个写引用（<code>T &amp;</code>），不存在其他只读引用。</li>
</ul>
<p>如果不符合以上规范，那么必须仔细考虑潜在的引用重叠。要么进行预先判断，要么优化实现，使其能够正确处理这种情况。</p>
<p>我们可以认为，不同类型的引用不会指向同一对象。因为这种情况往往已经违反了严格别名原则，属于
UB。</p>
<p>例如，在这个赋值运算符，<code>this</code>
指针是一个写引用，<code>other</code>
是一个只读引用，所以需要额外处理二者重叠的情况。</p>
<p>这个规则不仅适用于重载运算符，对于任何参数中包含引用的函数，都应该遵守。</p>
<h2 id="右值引用和移动语义">右值引用和移动语义</h2>
<p>C++ 中，<code>std::vector</code> 的实现方式是预留一部分空间，在
<code>push_back</code>
的时候，如果预留的空间不足，就扩容一倍，然后逐个元素迁移。对于
<code>int</code>，这个扩容的过程可以参考以下代码。</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="kw">constexpr</span> n <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> from<span class="op">[</span>n<span class="op">],</span> to<span class="op">[</span>n <span class="op">*</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> moveData<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>        to<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> from<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>然而 <code>std::vector</code>
中存放的并不一定是简单类型。例如，如果这里的 <code>int</code> 换成
<code>std::string</code>，<code>to[i] = from[i]</code>
这一步操作就是字符串的赋值。而 <code>std::string</code>
的赋值逻辑，是逐个字符复制，避免影响到原字符串。所以这个过程的总时间复杂度取决于字符串长度之和。</p>
<p>有没有更加高效的解决方案？首先，<code>std::string</code>
的内部其实仅存储了一个指向存储区（动态分配）的指针。如果不考虑对原对象的修改，直接移动指针，是一个明显更优的策略。而原对象已经即将被销毁了，所以我们无需在意它的值。</p>
<p>这就是“移动”和“复制”的差异，“复制”不会修改原对象的内容，但是“移动”之后，我们不再需要原对象，所以可以直接通过移动指针，从原对象中“窃取”资源，换取更高的效率。</p>
<p>C++11 引入了移动语义，来支持这样的需求。</p>
<p>在深入讲解语法知识之前，我们不妨想一想，如果你是 C++
的设计者，会如何设计关于移动的语法？</p>
<p>首先，我们需要一个特殊的构造函数。就像 <code>T(const T &amp;)</code>
被称为“复制构造函数”，这个新的就称为“移动构造函数”。当然，为了和复制构造函数之前区分，我们需要在类型名的基础上，添加一个标记（假如叫做
<code>T(T TO_BE_MOVED)</code>）。例如 <code>std::string</code>
的移动构造函数，就可以这么写：</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> string <span class="op">{</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>    string<span class="op">(</span>string TO_BE_MOVED other<span class="op">):</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">data_</span><span class="op">(</span>other<span class="op">.</span><span class="va">data_</span><span class="op">)</span>  <span class="co">// 直接获取内部指针</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ... 处理其他数据</span></span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 把原对象变成空指针，否则可能会导致二次释放</span></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a>        other<span class="op">.</span><span class="va">data_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>接下来的一个重要的问题，如何标记一次初始化是“移动”而非“复制”？</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> res<span class="op">;</span></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-6"><a href="#cb142-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec <span class="op">=</span> f<span class="op">();</span></span></code></pre></div>
<p>首先，以上是一个绝对可以使用移动的场景。通过 <code>f()</code>
得到的函数返回值，是一个临时的 <code>vector</code>
对象，即将被销毁，再此之前要赋值给局部变量
<code>vec</code>。你会发现，这其实是极度浪费的，把原件先复制一份，手里留下复印件之后销毁原件——为什么不直接移动它呢？于是，你得出了一个结论，右值一定可以安全地被移动。（不要考虑复制消除规则，这是
C++17 的内容了）</p>
<p>于是，你得到了一些启发。移动构造和复制构造相同，都是从另一个同类型的对象构造，自然要接受一个指向另一个对象的“引用”。这种引用和普通的引用不同，它只应该指向一个临时对象，表示可以从中“窃取”数据。你决定将它称为“右值引用”，表示为
<code>T &amp;&amp;</code>；与之相对，普通的引用称为“左值引用”，表示为
<code>T &amp;</code>。</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> string <span class="op">{</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 真正的“移动构造函数”（C++11 起）</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    string<span class="op">(</span>string <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">{</span>  <span class="co">// 移动构造、移动赋值函数十分推荐加上 noexcept</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 对应地，还有“移动赋值函数”</span></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span>string <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> string <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// ...</span></span>
<span id="cb143-10"><a href="#cb143-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb143-11"><a href="#cb143-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb143-12"><a href="#cb143-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>这自然会涉及值类别的相关内容。在本篇专栏前面的章节中，我们已经介绍过了左值（lvalue）和纯右值（prvalue）。我们规定：纯右值优先绑定到右值引用（<code>T &amp;&amp;</code>），但也允许绑定到常量的左值引用（<code>T const &amp;</code>）；左值只能绑定到左值引用（<code>T &amp;</code>）。</p>
<p>但是，回头看一下，最初的问题似乎还没有解决。尽管这些规定使得纯右值可以自动调用移动构造，但是保存在原位置上的
<code>from[i]</code>
是一个左值，还是会调用复制构造。于是你想到，需要允许某种方式，来把一个左值标记为“可移动的”。你引入了一个函数叫做
<code>mark_as_movable</code>，把一个左值传入这个函数，便神奇地让它可以绑定到右值引用。这个名字实在太长了，所以实际的
C++ 标准中，将它称为
<code>std::move</code>，它不会真正移动什么，只是标记“我想要移动它”。<code>std::move</code>
的返回值，值类别属于将亡值（xvalue）。将亡值的引用绑定规则，和纯右值一致。</p>
<p>这个问题在现在得到了完美解决。</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="kw">constexpr</span> n <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string from<span class="op">[</span>n<span class="op">],</span> to<span class="op">[</span>n <span class="op">*</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> moveData<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>        to<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>from<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>那么 <code>std::move</code>
是怎么实现的呢？其实就是一个显式类型转换，通过
<code>static_cast&lt;T &amp;&amp;&gt;(x)</code>
转换为右值引用。标准规定，到右值引用的显式转换，或者返回右值引用的函数调用表达式，值类别为将亡值。</p>
<p>将一个临时对象绑定到右值引用，将会延长它的生存期，直到这个引用本身被销毁。常量左值引用也有类似的性质。但是，不要使用这种方式来优化代码，即使是在
C++17
标准要求之前，编译器也会对函数返回值等情况做优化，优化掉任何额外的复制和移动操作。使用右值引用接受返回值，反而有可能抑制编译器优化。</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> f<span class="op">()</span> <span class="op">{</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;&amp;</span>x <span class="op">=</span> f<span class="op">();</span>  <span class="co">// f() 返回临时对象，生存期延长到和 x 相同</span></span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> y <span class="op">=</span> f<span class="op">();</span>  <span class="co">// f() 直接在 y 处构造结果，无复制和移动</span></span></code></pre></div>
<p>以及还有另一个问题。目光回到移动构造函数，在其中，我们使用了一个右值引用作为函数参数。但事实上，我们做的操作，更像是把它作为一个左值看待。移动过程中，对原对象做一些操作，例如赋值成员、取地址等，都应该是合理的。所以，<strong>右值引用的值类别是一个左值</strong>。这看起来可能有些奇怪，但其实是合理且必要的。以及从另一个角度看，右值引用也是一个具名对象，它不是左值才显得有些奇怪。</p>
<h3 id="万能引用和完美转发">万能引用和完美转发</h3>
<p>理解以下的内容，可能需要模板的相关知识。为了简化内容分类，我们在右值引用章节讲解。</p>
<p>在泛型编程中，可能会出现这样的代码：</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>T <span class="op">&amp;&amp;</span>arg<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>此处的 <code>T &amp;&amp;</code> 被称为万能引用（<code>T</code>
必须是当前函数上的模板）。根据传入 arg 的值类别（假设是左值/右值的
<code>int</code> 类型），类型推导的行为如下：</p>
<table>
<thead>
<tr>
<th>值类别</th>
<th>T</th>
<th>T &amp;&amp;</th>
</tr>
</thead>
<tbody>
<tr>
<td>左值</td>
<td><code>int &amp;</code></td>
<td><code>int &amp;</code></td>
</tr>
<tr>
<td>右值</td>
<td><code>int</code></td>
<td><code>int &amp;&amp;</code></td>
</tr>
</tbody>
</table>
<p>可以发现，根据值类别的不同，这个参数始终会传入一个左值引用或者右值引用，而不会丢失原始的值类别信息。</p>
<p>然而，获取了值类别信息并没有用处，还有一个很大的问题：无论
<code>arg</code>
被推导为左值引用还是右值引用，在使用时（例如作为其他函数的参数）都会是一个左值。为了解决这个问题，需要使用
<code>std::forward</code> 函数进行完美转发。</p>
<table>
<thead>
<tr>
<th>T</th>
<th><code>std::forward&lt;T&gt;(x)</code> 的返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int</code></td>
<td><code>int &amp;&amp;</code></td>
</tr>
<tr>
<td><code>int &amp;</code></td>
<td><code>int &amp;</code></td>
</tr>
</tbody>
</table>
<p>可以发现，这能够保留 <code>x</code>
的值类别，原封不动地传递到内层函数中。这种情况下不可以使用
<code>std::move</code> 转发，可能会导致意外地移动左值参数。</p>
<p><code>auto &amp;&amp;x</code>
这样的变量定义，推导规则和万能引用相同。</p>
<h3 id="杂项-1">杂项</h3>
<p>C++ 中，不推荐传递 <code>const</code>
引用，再在函数体中复制一次。这种情况推荐直接按值传递，传入右值时可以把一次复制构造变为移动。但是在不需要额外复制时，或者想要减少心智负担，使用常量引用传参仍是很好的解决方案。</p>
<p>同理，在类的构造函数中传递大对象，有时会写出这样的代码：</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string str<span class="op">;</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>    S<span class="op">(</span><span class="bu">std::</span>string <span class="at">const</span> <span class="op">&amp;</span>s<span class="op">):</span> str<span class="op">(</span>s<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>这种情况其实也是可以优化的，更好的方式是按值传递，然后移动构造。（<code>std::array</code>
这种移动构造开销极大的除外）</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string str<span class="op">;</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a>    S<span class="op">(</span><span class="bu">std::</span>string s<span class="op">):</span> str<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">))</span> <span class="op">{}</span></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h2 id="模板和编译期计算">模板和编译期计算</h2>
<p>模板是处理多类型数据的一个重要工具，可以支持一些类型不同，但是逻辑完全相同的操作。</p>
<p>例如，我们希望自己实现一个 <code>add</code> 函数，来计算
<code>(a + b) % 998244353</code> 的值。这看起来很简单，但其实要支持
<code>int</code>、<code>long long</code>
这样的很多类型。于是我们需要编写很多个代码一模一样的函数。</p>
<div class="sourceCode" id="cb149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>x <span class="op">+</span> y<span class="op">)</span> <span class="op">%</span> <span class="dv">998244353</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> add<span class="op">(</span><span class="dt">long</span> x<span class="op">,</span> <span class="dt">long</span> y<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>x <span class="op">+</span> y<span class="op">)</span> <span class="op">%</span> <span class="dv">998244353</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> add<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> x<span class="op">,</span> <span class="dt">long</span> <span class="dt">long</span> y<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>x <span class="op">+</span> y<span class="op">)</span> <span class="op">%</span> <span class="dv">998244353</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a><span class="co">// ...</span></span></code></pre></div>
<p>C++ 引入了“模板”来解决这类问题。</p>
<h3 id="基本使用">基本使用</h3>
<div class="sourceCode" id="cb150"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span>  <span class="co">// 模板参数</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>T add<span class="op">(</span>T x<span class="op">,</span> T y<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">(</span>x <span class="op">+</span> y<span class="op">)</span> <span class="op">%</span> <span class="dv">998244353</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>这段代码就定义了一个函数模板 <code>add</code>。其含义是：任取一个类型
<code>T</code>，定义一个函数
<code>T add(T x, T y)</code>。这样，我们在上文写到的这三个重载，就分别是
<code>T</code> 取 <code>int</code>，<code>long</code> 和
<code>long long</code> 的情况。<code>T</code> 可以换成任意类型。</p>
<p>调用这个函数，使用以下方式：</p>
<div class="sourceCode" id="cb151"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ans <span class="op">=</span> add<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span>  <span class="co">// 显式指定，T 取 int</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> ans2 <span class="op">=</span> add<span class="op">(</span><span class="dv">0</span><span class="bu">LL</span><span class="op">,</span> <span class="dv">3</span><span class="bu">LL</span><span class="op">);</span>  <span class="co">// 模板参数可以自动推导，T 取 long long</span></span></code></pre></div>
<p>每次真正使用函数模板的时候，都会填充对应模板参数，然后创建一个新的函数（这个过程被称为“实例化”）。模板实例化期间，才会检查里面的语句是否合法，例如此时再写一个
<code>add(1.0, 2.0)</code>（类型推导为
<code>double</code>，浮点数不能取模），就会在这个语句处报错。</p>
<p>平时我们使用的
<code>std::swap</code>、<code>std::min</code>、<code>std::sort</code>
这类支持多种类型的函数，都是通过函数模板实现的。</p>
<p>C++ 中，有很多种实体都可以带有模板。包括：</p>
<ul>
<li>类</li>
<li>函数</li>
<li>类型别名（C++11 起）</li>
<li>变量（C++14 起）</li>
<li>概念（C++20 起）</li>
</ul>
<p>例如，我们可以通过类模板来实现一个动态大小的数组。</p>
<div class="sourceCode" id="cb152"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> DynamicArray <span class="op">{</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>    T <span class="op">*</span><span class="va">data_</span><span class="op">{};</span></span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 接下来使用 DynamicArray 这个类名，如果没有指定模板参数，默认为 &lt;T&gt;</span></span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a>    DynamicArray<span class="op">():</span> DynamicArray<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a>    DynamicArray<span class="op">(</span><span class="bu">std::</span>size_t size<span class="op">):</span> <span class="va">data_</span><span class="op">(</span><span class="kw">new</span> T<span class="op">[</span>size<span class="op">]{})</span> <span class="op">{}</span></span>
<span id="cb152-8"><a href="#cb152-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">~</span>DynamicArray<span class="op">()</span> <span class="op">{</span></span>
<span id="cb152-9"><a href="#cb152-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">delete</span><span class="op">[]</span> <span class="va">data_</span><span class="op">;</span></span>
<span id="cb152-10"><a href="#cb152-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb152-11"><a href="#cb152-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-12"><a href="#cb152-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">[]</span> <span class="op">(</span><span class="bu">std::</span>size_t index<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb152-13"><a href="#cb152-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">data_</span><span class="op">[</span>index<span class="op">];</span></span>
<span id="cb152-14"><a href="#cb152-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb152-15"><a href="#cb152-15" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>接下来，可以使用 <code>DynamicArray&lt;int&gt;</code>
这样的方式来使用它。平时我们使用的
<code>std::set</code>、<code>std::vector</code>、<code>std::pair</code>
等类型，都是通过类模板实现。</p>
<p>类模板的不同特化中（模板参数不完全相同），会拥有独自的静态成员。函数模板的不同特化中，也会拥有独自的静态变量。</p>
<h3 id="常量表达式">常量表达式</h3>
<p>在进一步讲解之前，我们需要了解
<code>constexpr</code>（常量表达式，Constant
Expression）这一概念。<code>constexpr</code> 是 C++11
引入的关键字，声明可以编译期求值的变量、函数。</p>
<h4 id="constexpr-变量">constexpr 变量</h4>
<p>很多情况下，一些值在编译期即可确定，这种变量可以使用
<code>constexpr</code> 来修饰。</p>
<p>请注意 <code>constexpr</code> 和 <code>const</code>
是不同的。<code>const</code>
只是表示这个变量的值在初始化之后不可变，但是这个值可以是运行时确定的。</p>
<p>很多情况下，我们都需要填写一个 <code>constexpr</code>
的值。（例如数组的大小，例如后文要提到的模板参数）</p>
<div class="sourceCode" id="cb153"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> size <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> array<span class="op">[</span>size<span class="op">];</span>           <span class="co">// 合法，数组大小必须是编译期常量</span></span></code></pre></div>
<h4 id="constexpr-函数">constexpr 函数</h4>
<p>constexpr
函数是可以在编译期求值的函数，即如果它的参数都是可以在编译期计算的，那么它的求值也将在编译期进行。</p>
<p>这个概念是 C++11 引入的，在接下来的每个版本，都允许 constexpr
函数执行更多的操作，使其更加可用。开始时的 constexpr
函数，除了一条返回语句外，不允许其他语句；C++20 起甚至可以使用 new 和
delete。</p>
<div class="sourceCode" id="cb154"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="kw">constexpr</span> pow10<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span>  <span class="co">// C++14 起</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> x<span class="op">;</span> i<span class="op">++)</span> result <span class="op">*=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a<span class="op">[</span>pow10<span class="op">(</span>x<span class="op">)];</span>  <span class="co">// 可以用作数组大小</span></span></code></pre></div>
<h3 id="非类型模板参数">非类型模板参数</h3>
<p>模板参数可以不是类型，可以是具体的值。</p>
<div class="sourceCode" id="cb155"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">&gt;</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Mul <span class="op">{</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">int</span> value <span class="op">=</span> x <span class="op">*</span> y<span class="op">;</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>整数、枚举和指针可以是模板参数。C++20
起，可以使用浮点数、简单的类类型。</p>
<p>非类型的模板参数，必须填入一个编译期常量。</p>
<p>模板参数和函数参数的行为十分接近，同样支持默认参数。</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T <span class="op">=</span> <span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>size_t size <span class="op">=</span> <span class="dv">3</span><span class="op">&gt;</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Array <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">};</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 使用</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a>Array a1<span class="op">{};</span>  <span class="co">// Array&lt;int, 3&gt;（C++17 起）</span></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a>Array<span class="op">&lt;&gt;</span> a1<span class="op">{};</span>  <span class="co">// Array&lt;int, 3&gt;</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a>Array<span class="op">&lt;</span><span class="dt">double</span><span class="op">&gt;</span> a2<span class="op">{};</span>  <span class="co">// Array&lt;double, 3&gt;</span></span></code></pre></div>
<h3 id="模板特化">模板特化</h3>
<p>有些情况下，我们可能会希望，为特定模板参数提供定制实现，这种情况下就可以使用模板特化。</p>
<p>模板特化分为以下两种：</p>
<ul>
<li>全特化，所有的模板参数都指定一个固定类型。</li>
<li>偏特化，只有部分模板参数指定了特定类型，仍然包含模板。</li>
</ul>
<p>类型特征（Type
traits，有时称为类型萃取）是模板特化的最常见用途。我们可以通过模板来获取关于一个类型的信息，是否为整数，是否为指针，是否为函数……以下是通过类模板特化实现的一个
<code>is_integral</code> 来判断整数类型。这个代码属于全特化。</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> is_integral <span class="op">{</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// 默认不是整数</span></span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a><span class="co">// 对于整数类型</span></span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span>  <span class="co">// 全特化语法，必须使用 template &lt;&gt; 来声明</span></span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> is_integral<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value <span class="op">=</span> <span class="kw">true</span><span class="op">;</span>  <span class="co">// 定制 int 的实现，它一定是整数</span></span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb157-11"><a href="#cb157-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-12"><a href="#cb157-12" aria-hidden="true" tabindex="-1"></a><span class="co">// ...对于所有整数类型特化</span></span></code></pre></div>
<p>在使用的时候，便可以用 <code>is_integral&lt;T&gt;::value</code>
来判断 <code>T</code> 类型是否为整数。实际可以使用标准库的
<code>std::is_integral&lt;T&gt;::value</code> 或者
<code>std::is_integral_v&lt;T&gt;</code>。</p>
<p>使用偏特化实现的类型特征，一个典型的示例是
<code>is_same&lt;T, U&gt;</code>
判断两个类型是否相同。具体实现如下：</p>
<div class="sourceCode" id="cb158"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> is_same <span class="op">{</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// 默认不相同</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a><span class="co">// 偏特化</span></span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> is_same<span class="op">&lt;</span>T<span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">bool</span> value <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-12"><a href="#cb158-12" aria-hidden="true" tabindex="-1"></a><span class="co">// 模仿标准库 is_same_v</span></span>
<span id="cb158-13"><a href="#cb158-13" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb158-14"><a href="#cb158-14" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">bool</span> is_same_v <span class="op">=</span> is_same<span class="op">&lt;</span>T<span class="op">,</span> U<span class="op">&gt;::</span>value<span class="op">;</span></span></code></pre></div>
<p>实际可以使用标准库的 <code>std::is_same&lt;T, U&gt;::value</code>
或者 <code>std::is_same_v&lt;T, U&gt;</code>。</p>
<p>模板特化也可以在数值计算中使用，例如以下是一个编译期计算阶乘的程序。</p>
<div class="sourceCode" id="cb159"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">int</span> n<span class="op">&gt;</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> fac <span class="op">{</span> <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">int</span> value <span class="op">=</span> n <span class="op">*</span> fac<span class="op">&lt;</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;::</span>value<span class="op">;</span> <span class="op">};</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;&gt;</span>  <span class="co">// 模板全特化</span></span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> fac<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;</span> <span class="op">{</span> <span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">int</span> value <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="op">};</span></span></code></pre></div>
<h3 id="sfinae">SFINAE</h3>
<p>SFINAE（Substitution Failure Is Not An Error，替换失败不是错误）是
C++ 模板元编程的一个重要概念。</p>
<p>在重载决议的过程中，如果一个函数模板，由于模板替换导致无效代码（但不是严重的语法错误），编译器不会报错，而是会静默地丢弃这个候选项，考虑其他重载。</p>
<p>举一个例子，以下的代码实现一个函数模板，如果输入的对象有 size()、
len() 方法中的任意一个就调用它。（我们假设不会二者兼有）</p>
<div class="sourceCode" id="cb160"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> size<span class="op">(</span>T <span class="at">const</span> <span class="op">&amp;</span>t<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>t<span class="op">.</span>size<span class="op">())</span> <span class="op">{</span></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> size<span class="op">(</span>T <span class="at">const</span> <span class="op">&amp;</span>t<span class="op">)</span> <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>t<span class="op">.</span>len<span class="op">())</span> <span class="op">{</span></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> t<span class="op">.</span>len<span class="op">();</span></span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>假设我们此时传入了一个 <code>std::vector</code>，它只有名为
<code>size()</code> 的方法。在第二个重载中，返回值处发生替换失败（没有
<code>len()</code>），根据 SFINAE
规则，第二个重载被忽略，只有第一个重载成为候选。</p>
<p>另一个常见的需求是，如果 <code>T</code>
满足某个条件，就启用这个重载，否则考虑其他的。标准库提供了
<code>std::enable_if</code> 模板，来实现这种“条件启用”的逻辑。</p>
<div class="sourceCode" id="cb161"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> B<span class="op">,</span> <span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> enable_if <span class="op">{</span>  <span class="op">};</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> enable_if<span class="op">&lt;</span><span class="kw">true</span><span class="op">,</span> T<span class="op">&gt;</span> <span class="op">{</span> <span class="kw">using</span> type <span class="op">=</span> T<span class="op">;</span> <span class="op">};</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">bool</span> B<span class="op">,</span> <span class="kw">typename</span> T <span class="op">=</span> <span class="dt">void</span><span class="op">&gt;</span></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="dt">enable_if_t</span> <span class="op">=</span> <span class="kw">typename</span> enable_if<span class="op">&lt;</span>B<span class="op">,</span> T<span class="op">&gt;::</span>type<span class="op">;</span></span></code></pre></div>
<p>以上是 <code>std::enable_if</code> 的实现。需要传入一个布尔值
<code>B</code> 和一个类型 <code>T</code>（默认为
<code>void</code>）。具体效果：</p>
<ul>
<li>若 <code>B</code> 为 <code>true</code>，在其中声明一个类型别名
<code>using type = T</code>。</li>
<li>若 <code>B</code> 为 <code>false</code>，则不声明任何类型别名。</li>
</ul>
<p>可以按照如下的方式使用它。</p>
<div class="sourceCode" id="cb162"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>T x<span class="op">)</span> <span class="op">-&gt;</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">%</span> <span class="dv">17</span><span class="op">;</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>其中 <code>is_integral_v&lt;T&gt;</code> 用于判断 <code>T</code>
是否为整数类型。</p>
<p>在这段代码中，如果传入一个整数类型，则返回值相当于
<code>std::enable_if_t&lt;true, T&gt;</code>，即
<code>T</code>。如果传入其他类型，返回值是
<code>std::enable_if_t&lt;false, T&gt;</code>，但是并没有声明这个类型，于是替换失败，被
SFINAE 忽略。</p>
<p>另一个常见的用法是，借助非类型模板参数。</p>
<div class="sourceCode" id="cb163"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;,</span> <span class="dt">int</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dv">0</span><span class="op">&gt;</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>T x<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">%</span> <span class="dv">17</span><span class="op">;</span></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>这种写法的优点是，可以不显式指定返回值类型，而是使用
<code>auto</code> 推导。这里的 <code>int</code>
也可以换成其他简单类型，例如 <code>bool</code>、<code>char</code>
等。</p>
<p>还有一个用法是借助默认模板参数。</p>
<div class="sourceCode" id="cb164"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="co">/*未命名的模板参数*/</span> <span class="op">=</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;,</span> <span class="dt">int</span><span class="op">&gt;&gt;</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>T x<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">%</span> <span class="dv">17</span><span class="op">;</span></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>但是这个方法其实存在重大缺陷。假如接下来需要一个对于浮点数启用的重载，那么就会出现：</p>
<div class="sourceCode" id="cb165"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="co">/*...*/</span><span class="op">&gt;</span> <span class="kw">auto</span> f<span class="op">(</span>T x<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">{}</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">=</span> <span class="co">/*...*/</span><span class="op">&gt;</span> <span class="kw">auto</span> f<span class="op">(</span>T x<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">{}</span></span></code></pre></div>
<p>所以实际上，这两个模板的签名是相同的，都需要两个
<code>typename</code>
参数，于是编译器会认为这是同一个函数模板的重定义错误，然后报错。建议换用其他方法。</p>
<p>正确的重载方式（通过返回值 <code>enable_if</code>）：</p>
<div class="sourceCode" id="cb166"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>T x<span class="op">)</span> <span class="op">-&gt;</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">%</span> <span class="dv">17</span><span class="op">;</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>T x<span class="op">)</span> <span class="op">-&gt;</span> <span class="bu">std::</span>enable_if_t<span class="op">&lt;</span><span class="bu">std::</span>is_floating_point_v<span class="op">&lt;</span>T<span class="op">&gt;,</span> T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>fmod<span class="op">(</span>x<span class="op">,</span> <span class="dv">17</span><span class="op">);</span></span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="if-constexpr">if constexpr</h3>
<p>正如上文所讲，希望通过 SFINAE
在编译期使用条件分支，其实是非常麻烦的，代码也十分晦涩难懂。于是 C++17
引入了
<code>if constexpr</code>，允许像编写常规代码一样，在编译期进行条件判断。</p>
<p>上文的取模函数，可以像这样实现：</p>
<div class="sourceCode" id="cb167"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>T x<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">{</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x <span class="op">%</span> <span class="dv">17</span><span class="op">;</span></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="bu">std::</span>is_floating_point_v<span class="op">&lt;</span>T<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb167-6"><a href="#cb167-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">std::</span>fmod<span class="op">(</span>x<span class="op">,</span> <span class="dv">17</span><span class="op">);</span></span>
<span id="cb167-7"><a href="#cb167-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb167-8"><a href="#cb167-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">static_assert</span><span class="op">(</span><span class="kw">false</span><span class="op">,</span> <span class="st">"不支持的类型"</span><span class="op">);</span></span>
<span id="cb167-9"><a href="#cb167-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb167-10"><a href="#cb167-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>请注意，<code>if constexpr</code> 和运行时的 <code>if</code>
是完全不同的，不仅仅是运行时开销的差异。如果此处使用常规的
<code>if</code>，将会由于浮点数不支持 <code>%</code> 运算符取模，以及
<code>static_assert(false)</code> 而报错。甚至可以借助
<code>if constexpr</code> 让函数返回不同的类型。</p>
<div class="sourceCode" id="cb168"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>T x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb168-3"><a href="#cb168-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb168-4"><a href="#cb168-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb168-5"><a href="#cb168-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb168-6"><a href="#cb168-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="st">"Hello!"</span><span class="op">;</span></span>
<span id="cb168-7"><a href="#cb168-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb168-8"><a href="#cb168-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="概念concept和约束requires">概念（concept）和约束（requires）</h3>
<p>C++20 引入了
concept，可以用更加现代化的方式，对函数模板的参数进行一些约束。</p>
<p>假设有一个函数 <code>f(x)</code>，我们希望它只能传入整数类型，或者是
GCC 的扩展类型
<code>__int128</code>。于是可以定义一个概念，来描述这个限制。</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> is_int <span class="op">=</span> <span class="bu">std::</span>is_same_v<span class="op">&lt;</span>T<span class="op">,</span> <span class="dt">__int128</span><span class="op">&gt;</span> <span class="op">||</span> <span class="bu">std::</span>is_integral_v<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<p>接下来我们就可以使用这个概念了。最简单的用法是直接用
<code>is_int&lt;double&gt;</code>
这样的方式判断一个类型是否符合这个概念，将会获得一个布尔值。更重要的是，概念可以直接写在模板参数中，来约束这个参数的类型。</p>
<div class="sourceCode" id="cb170"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span>is_int T<span class="op">&gt;</span>  <span class="co">// T 必须为整数</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>T x<span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span></code></pre></div>
<p>这样写，编译器会保证 <code>T</code> 类型满足 <code>is_int</code>
的概念，否则会忽略这个重载。还有一种等价的写法：</p>
<div class="sourceCode" id="cb171"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>is_int <span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span></code></pre></div>
<p>标准库也预定义了一些概念，例如 <code>std::integral&lt;T&gt;</code>
表示整数，<code>std::convertible_to&lt;T, U&gt;</code> 表示
<code>T</code> 可以转换为
<code>U</code>，<code>std::same_as&lt;T, U&gt;</code>
表示类型相同等。</p>
<h4 id="requires">requires</h4>
<p><code>requires</code>
和概念一同被引入，表达更加多样的约束方式。相关的内容，分为“requires
子句”和“requires 表达式”两种。</p>
<p>requires
子句，可以用来限制一个函数模板的模板参数。如果条件不成立，就忽略这个重载。</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a><span class="kw">requires</span> <span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">)</span> <span class="op">&gt;=</span> <span class="dv">8</span><span class="op">);</span>  <span class="co">// requires(常量 bool 值)，要求它必须求值为 true</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span></code></pre></div>
<p>requires 表达式用于表达更加复杂的约束，它本身会返回一个
<code>bool</code> 类型，表示所有的约束是否都被满足。</p>
<div class="sourceCode" id="cb173"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="co">// requires 表达式可以用来定义概念</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> MyConcept <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>T a<span class="op">,</span> T b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// requires 中可以“假设”定义若干个 T 类型的变量，然后检查操作合法性</span></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 简单要求：检查某个表达式是否有效</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>    a <span class="op">+</span> b<span class="op">;</span>  <span class="co">// 必须支持加法</span></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a>    a <span class="op">&lt;</span> b<span class="op">;</span>  <span class="co">// 必须支持小于号</span></span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-10"><a href="#cb173-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 类型要求：检查嵌套类型是否存在</span></span>
<span id="cb173-11"><a href="#cb173-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typename</span> T<span class="op">::</span><span class="dt">value_type</span><span class="op">;</span>  <span class="co">// 必须存在这个类型</span></span>
<span id="cb173-12"><a href="#cb173-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-13"><a href="#cb173-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 复合要求：检查一个表达式，对它的返回值类型进行约束</span></span>
<span id="cb173-14"><a href="#cb173-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> a <span class="op">+</span> b <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>convertible_to<span class="op">&lt;</span>T<span class="op">&gt;;</span>  <span class="co">// 加法返回值可以转化为 T</span></span>
<span id="cb173-15"><a href="#cb173-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 这里的含义是，假设 a + b 的返回值为 U，概念 std::convertible_to&lt;U, T&gt; 必须成立</span></span>
<span id="cb173-16"><a href="#cb173-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span> a<span class="op">.</span>size<span class="op">()</span> <span class="op">}</span> <span class="op">-&gt;</span> <span class="bu">std::</span>integral<span class="op">;</span>  <span class="co">// size() 返回值是整数</span></span>
<span id="cb173-17"><a href="#cb173-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-18"><a href="#cb173-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 嵌套要求：要求一个 requires 子句成立</span></span>
<span id="cb173-19"><a href="#cb173-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">)</span> <span class="op">&gt;=</span> <span class="dv">16</span><span class="op">);</span>  <span class="co">// 大小足够大</span></span>
<span id="cb173-20"><a href="#cb173-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">requires</span> <span class="op">(</span><span class="kw">requires</span><span class="op">(</span>T a<span class="op">,</span> <span class="dt">char</span> b<span class="op">)</span> <span class="op">{</span> a <span class="op">+</span> b<span class="op">;</span> <span class="op">});</span>  <span class="co">// 可以加上一个字符</span></span>
<span id="cb173-21"><a href="#cb173-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-22"><a href="#cb173-22" aria-hidden="true" tabindex="-1"></a><span class="co">/*</span></span>
<span id="cb173-23"><a href="#cb173-23" aria-hidden="true" tabindex="-1"></a><span class="co">    此处的逻辑是，第一个 requires 是“子句”，括号里希望一个布尔值。</span></span>
<span id="cb173-24"><a href="#cb173-24" aria-hidden="true" tabindex="-1"></a><span class="co">    第二个 requires 是“表达式”，正好会返回一个布尔值。</span></span>
<span id="cb173-25"><a href="#cb173-25" aria-hidden="true" tabindex="-1"></a><span class="co">*/</span></span>
<span id="cb173-26"><a href="#cb173-26" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb173-27"><a href="#cb173-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-28"><a href="#cb173-28" aria-hidden="true" tabindex="-1"></a><span class="co">// 例如，传入一个 std::string 就是合法的</span></span>
<span id="cb173-29"><a href="#cb173-29" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>MyConcept <span class="kw">auto</span> <span class="at">const</span> <span class="op">&amp;</span>x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb173-30"><a href="#cb173-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb173-31"><a href="#cb173-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="概念包含">概念“包含”</h4>
<p>定义一个概念时，可能需要用到其他的概念，此时可能会确立“包含”关系，即满足概念
A 的类型一定会满足概念
B。被包含的概念会更加受限，于是会在重载决议中优先考虑。</p>
<div class="sourceCode" id="cb174"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a><span class="kw">concept</span> SmallInt <span class="op">=</span> <span class="bu">std::</span>integral<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">&amp;&amp;</span> <span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">)</span> <span class="op">&lt;=</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 显然可以保证 SmallInt 一定为 integral</span></span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>SmallInt <span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span><span class="bu">std::</span>integral <span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>此时调用 <code>f(3)</code> 将会固定调用重载 1，<code>f(4LL)</code>
将会固定调用重载 2。使用 <code>std::enable_if</code>
这样的解决方案，将不会有这个性质。</p>
<h3 id="变参模板">变参模板</h3>
<p>C++11 引入了变参模板，允许函数接受不限个数的参数。</p>
<p>模板参数的结尾，可以添加一个通过省略号声明的参数包，来包含不限数量的参数（可以包含零个）。</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span>Types<span class="op">&gt;</span></span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Tuple <span class="op">{};</span></span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">&gt;</span> t1<span class="op">;</span></span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>Tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">long</span><span class="op">,</span> <span class="dt">char</span><span class="op">,</span> <span class="dt">short</span><span class="op">&gt;</span> t2<span class="op">;</span></span></code></pre></div>
<p>参数包也可以是非类型模板参数。</p>
<div class="sourceCode" id="cb176"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">int</span> <span class="op">...</span>Nums<span class="op">&gt;</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Numbers <span class="op">{};</span></span></code></pre></div>
<p>通过参数包类型，可以声明相同数量的函数参数。</p>
<div class="sourceCode" id="cb177"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span>Ts<span class="op">&gt;</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>Ts <span class="op">...</span>args<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb177-4"><a href="#cb177-4" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span>Ts<span class="op">&gt;</span></span>
<span id="cb177-5"><a href="#cb177-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span>Ts <span class="op">&amp;&amp;...</span>args<span class="op">)</span> <span class="op">{}</span>  <span class="co">// 可以带引用、万能引用</span></span></code></pre></div>
<h4 id="参数包展开">参数包展开</h4>
<p>我们将包含参数包的类型或表达式，称为一个“模式”（pattern）。在模式后面加上一个省略号来展开一个包。</p>
<div class="sourceCode" id="cb178"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a>args<span class="op">...;</span> <span class="co">// 模式为 args</span></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span>args<span class="op">)...;</span>  <span class="co">// 模式为 f(args)</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a><span class="op">(</span>args <span class="op">*</span> <span class="dv">5</span> <span class="op">+</span> <span class="dv">2</span><span class="op">)...;</span> <span class="co">// 模式为 (args * 5 + 2)</span></span></code></pre></div>
<p>展开包的过程，相当于给这个参数包的每一项都按照相应模式进行一些处理，然后通过逗号连接。</p>
<div class="sourceCode" id="cb179"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span></span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>sum<span class="op">((</span>args <span class="op">*</span> <span class="dv">2</span><span class="op">)...)</span></span>
<span id="cb179-3"><a href="#cb179-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 展开成：</span></span>
<span id="cb179-4"><a href="#cb179-4" aria-hidden="true" tabindex="-1"></a>sum<span class="op">((</span><span class="dv">1</span> <span class="op">*</span> <span class="dv">2</span><span class="op">),</span> <span class="op">(</span><span class="dv">2</span> <span class="op">*</span> <span class="dv">2</span><span class="op">),</span> <span class="op">(</span><span class="dv">3</span> <span class="op">*</span> <span class="dv">2</span><span class="op">),</span> <span class="op">(</span><span class="dv">4</span> <span class="op">*</span> <span class="dv">2</span><span class="op">))</span></span>
<span id="cb179-5"><a href="#cb179-5" aria-hidden="true" tabindex="-1"></a><span class="co">// --------</span></span>
<span id="cb179-6"><a href="#cb179-6" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">char</span></span>
<span id="cb179-7"><a href="#cb179-7" aria-hidden="true" tabindex="-1"></a>tuple<span class="op">&lt;</span>pair<span class="op">&lt;</span>args<span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;...&gt;</span></span>
<span id="cb179-8"><a href="#cb179-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 展开成：</span></span>
<span id="cb179-9"><a href="#cb179-9" aria-hidden="true" tabindex="-1"></a>tuple<span class="op">&lt;</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;,</span> pair<span class="op">&lt;</span><span class="dt">double</span><span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;,</span> pair<span class="op">&lt;</span><span class="dt">char</span><span class="op">,</span> <span class="dt">bool</span><span class="op">&gt;&gt;</span></span></code></pre></div>
<p>多个长度相同的包也可以同步展开，多用于多个函数参数及其类型。</p>
<div class="sourceCode" id="cb180"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a>Ts <span class="op">=</span> <span class="dt">int</span><span class="op">,</span> <span class="dt">double</span> <span class="op">&amp;,</span> <span class="dt">char</span> <span class="op">&amp;</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a>args <span class="op">=</span> <span class="dv">5</span><span class="op">,</span> <span class="fl">7.2</span><span class="op">,</span> <span class="ch">'x'</span></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>Ts<span class="op">&gt;(</span>args<span class="op">)...)</span></span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a><span class="co">// 展开成：</span></span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a>f<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">5</span><span class="op">),</span> <span class="bu">std::</span>forward<span class="op">&lt;</span><span class="dt">double</span> <span class="op">&amp;&gt;(</span><span class="fl">7.2</span><span class="op">),</span> <span class="bu">std::</span>forward<span class="op">&lt;</span><span class="dt">char</span> <span class="op">&amp;&gt;(</span><span class="ch">'x'</span><span class="op">))</span></span></code></pre></div>
<h4 id="使用方法">使用方法</h4>
<p>C++17
起，支持“折叠表达式”，可以通过二元运算符连接整个参数包进行处理。对于连加、连乘这种常见操作十分好用。</p>
<div class="sourceCode" id="cb181"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span>Ts<span class="op">&gt;</span></span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>Ts <span class="at">const</span> <span class="op">&amp;...</span>args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>args <span class="op">+</span> <span class="op">...);</span>  <span class="co">// (a1 + (a2 + (a3 + a4)))</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">(...</span> <span class="op">+</span> args<span class="op">);</span>  <span class="co">// (((a1 + a2) + a3) + a4)</span></span>
<span id="cb181-5"><a href="#cb181-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span><span class="dv">5</span> <span class="op">+</span> <span class="op">...</span> <span class="op">+</span> args<span class="op">);</span>  <span class="co">// (((5 + a1) + a2) + a3)</span></span>
<span id="cb181-6"><a href="#cb181-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>args <span class="op">+</span> <span class="op">...</span> <span class="op">+</span> <span class="dv">5</span><span class="op">);</span>  <span class="co">// (((a1 + a2) + a3) + 5)</span></span>
<span id="cb181-7"><a href="#cb181-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>此处的展开也可以使用上文说的“模式”。以下代码借助逗号运算符来输出多个数。</p>
<div class="sourceCode" id="cb182"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span>Ts<span class="op">&gt;</span></span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span>Ts <span class="at">const</span> <span class="op">&amp;...</span>args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">((</span><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> args <span class="op">&lt;&lt;</span> <span class="ch">' '</span><span class="op">),</span> <span class="op">...);</span></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/*</span></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a><span class="co">    展开成</span></span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a><span class="co">    (std::cout &lt;&lt; 1 &lt;&lt; ' '), (std::cout &lt;&lt; 2 &lt;&lt; ' '), (std::cout &lt;&lt; 3 &lt;&lt; ' ');</span></span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a><span class="co">    */</span></span>
<span id="cb182-8"><a href="#cb182-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>除此以外，使用参数包的一个经典方法是分离首个参数和后续参数，然后递归处理。例如以下代码，也可以实现依次输出几个参数。</p>
<div class="sourceCode" id="cb183"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> output<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{}</span>  <span class="co">// 递归终止条件</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">...</span>Ts<span class="op">&gt;</span></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> output<span class="op">(</span>T <span class="at">const</span> <span class="op">&amp;</span>first<span class="op">,</span> Ts <span class="at">const</span> <span class="op">&amp;...</span>args<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> first <span class="op">&lt;&lt;</span> <span class="ch">' '</span><span class="op">;</span></span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a>    output<span class="op">(</span>args<span class="op">...);</span>  <span class="co">// 递归处理后续参数</span></span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>以下代码可以获得参数包的第 <code>i</code> 个类型。</p>
<div class="sourceCode" id="cb184"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="bu">std::</span>size_t index<span class="op">,</span> <span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">...</span>Ts<span class="op">&gt;</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> index_pack <span class="op">{</span></span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> type <span class="op">=</span> index_pack<span class="op">&lt;</span>index <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> Ts<span class="op">...&gt;;</span></span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">...</span>Ts<span class="op">&gt;</span></span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> index_pack<span class="op">&lt;</span><span class="dv">0</span><span class="op">,</span> T<span class="op">,</span> Ts<span class="op">...&gt;</span> <span class="op">{</span></span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> type <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>以下是一个简易的 <code>printf</code> 实现，使用 <code>%</code>
代替任何参数，但是没有格式化功能。</p>
<div class="sourceCode" id="cb185"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> my_printf<span class="op">(</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>format<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> format<span class="op">;</span></span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> <span class="op">...</span>Ts<span class="op">&gt;</span></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> my_printf<span class="op">(</span><span class="at">const</span> <span class="dt">char</span> <span class="op">*</span>format<span class="op">,</span> T <span class="at">const</span> <span class="op">&amp;</span>val<span class="op">,</span> Ts <span class="at">const</span> <span class="op">&amp;...</span>args<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(;</span> <span class="op">*</span>format <span class="op">!=</span> <span class="ch">'</span><span class="sc">\0</span><span class="ch">'</span><span class="op">;</span> <span class="op">++</span>format<span class="op">)</span> <span class="op">{</span></span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(*</span>format <span class="op">==</span> <span class="ch">'%'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(*++</span>format <span class="op">!=</span> <span class="ch">'%'</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> val<span class="op">;</span></span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> my_printf<span class="op">(</span>format<span class="op">,</span> args<span class="op">...);</span></span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="op">*</span>format<span class="op">;</span></span>
<span id="cb185-15"><a href="#cb185-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb185-16"><a href="#cb185-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>另外，一个较为实用的功能是可以使用 <code>sizeof...(pack)</code>
获取包中的元素数量。</p>
<p>C++ 标准库还提供了 <code>std::integer_sequence</code>
用于方便地获取连续自然数组成的包，具体使用方法如下：</p>
<div class="sourceCode" id="cb186"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="dt">int</span> <span class="op">...</span>Is<span class="op">&gt;</span></span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> f<span class="op">(</span><span class="bu">std::</span>integer_sequence<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> Is<span class="op">...&gt;)</span> <span class="op">{</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 调用时，推导出 Is 为 0, 1, 2, 3, 4</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">((</span><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> Is<span class="op">),</span> <span class="op">...);</span></span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> main<span class="op">()</span> <span class="op">-&gt;</span> <span class="dt">int</span> <span class="op">{</span></span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>    f<span class="op">(</span><span class="bu">std::</span>make_integer_sequence<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">5</span><span class="op">&gt;{});</span></span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// make_integer_sequence&lt;int, 5&gt; 类型，相当于</span></span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// integer_sequence&lt;int, 0, 1, 2, 3, 4&gt;</span></span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 此外，还有 std::make_integer_sequence&lt;N&gt;，相当于 std::make_integer_sequence&lt;std::size_t, N&gt;</span></span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="杂谈">杂谈</h2>
<p>在这个章节中，我们将会讲一些不好归类，但是很有用的语法特性。</p>
<h3 id="范围-for-循环">范围 for 循环</h3>
<p>C++11 起，支持通过范围 for
循环，来更方便地遍历一个容器。具体语法如下：</p>
<div class="sourceCode" id="cb187"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> x <span class="op">:</span> vec<span class="op">)</span> <span class="op">{</span>  <span class="co">// 依次输出 vec 中的所有元素</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="ch">' '</span><span class="op">;</span></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>其中的 <code>vec</code> 是类似
<code>std::vector</code>、<code>std::set</code> 这样的容器，支持
<code>.begin()</code>、<code>.end()</code> 返回首尾迭代器。特别地，C
风格数组也可以使用范围 <code>for</code>
循环遍历，会依次遍历数组中的所有元素。</p>
<p><code>auto x</code> 可以替换成引用。包括以下允许的形式：</p>
<ul>
<li><code>auto &amp;x</code>：左值引用，允许修改容器内元素的值。</li>
<li><code>auto const &amp;</code>：常量左值引用，<strong>防止复制开销</strong>。</li>
<li><code>auto &amp;&amp;</code>：万能引用。根据元素值类别推断左值/右值引用。</li>
</ul>
<p><code>auto</code> 也可以替换成具体的类型。</p>
<p>范围 <code>for</code> 循环，等价于以下形式：</p>
<div class="sourceCode" id="cb188"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> it <span class="op">=</span> vec<span class="op">.</span>begin<span class="op">();</span></span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> end <span class="op">=</span> vec<span class="op">.</span>end<span class="op">();</span></span>
<span id="cb188-3"><a href="#cb188-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(;</span> it <span class="op">!=</span> end<span class="op">;</span> <span class="op">++</span>it<span class="op">)</span> <span class="op">{</span></span>
<span id="cb188-4"><a href="#cb188-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> x <span class="op">=</span> <span class="op">*</span>it<span class="op">;</span>  <span class="co">// 这里的变量 x 声明方式与冒号左侧部分相同</span></span>
<span id="cb188-5"><a href="#cb188-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ... 循环体</span></span>
<span id="cb188-6"><a href="#cb188-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>所以，<strong>即使使用范围 for
循环，往往也不能在循环途中修改容器</strong>。</p>
<h3 id="结构化绑定">结构化绑定</h3>
<p>C++17
起，可以通过结构化绑定，方便地将一个对象的几个成员绑定到局部变量。例如：</p>
<div class="sourceCode" id="cb189"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair pair<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">]</span> <span class="op">=</span> pair<span class="op">;</span></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 相当于</span></span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> x <span class="op">=</span> pair<span class="op">.</span>first<span class="op">;</span></span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> y <span class="op">=</span> pair<span class="op">.</span>second<span class="op">;</span></span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 也可以用其他的初始化方式</span></span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">]{</span>pair<span class="op">};</span></span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">](</span>pair<span class="op">);</span></span></code></pre></div>
<p>结构化绑定一个对象时，将会把这些局部变量，依次绑定到右侧对象的各个公开成员中（按声明顺序，例如这里就是
<code>first</code> 和 <code>second</code>）。</p>
<p>数组和 <code>std::array</code> 也支持结构化绑定。</p>
<div class="sourceCode" id="cb190"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>array<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dv">3</span><span class="op">&gt;</span> arr<span class="op">{};</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">[</span>x<span class="op">,</span> y<span class="op">,</span> z<span class="op">]</span> <span class="op">=</span> arr<span class="op">;</span></span></code></pre></div>
<p>结构化绑定也支持各种形式的引用，允许修改对象，或者免除复制。包括
<code>auto</code>、<code>const auto &amp;</code>、<code>auto &amp;</code>、<code>auto &amp;&amp;</code>
等。建议对于较大的对象使用 <code>auto const &amp;</code>
绑定来避免复制开销。</p>
<p>事实上，以下的过程可以更好地描述结构化绑定的行为：</p>
<div class="sourceCode" id="cb191"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>pair pair<span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 首先，按照给定的方式定义一个临时对象</span></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 假设使用 auto &amp;[x, y] = pair</span></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="op">&amp;</span>tmp <span class="op">=</span> pair<span class="op">;</span></span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a><span class="co">// 接下来，每次使用 x 都替换成 tmp.first，每次使用 y 都替换成 tmp.second</span></span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a><span class="co">// 例如，std::cout &lt;&lt; x; 相当于</span></span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> tmp<span class="op">.</span>first<span class="op">;</span></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a><span class="co">// 这里也可以进行修改，并且影响原对象</span></span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a><span class="co">// 例如 x = 5</span></span>
<span id="cb191-13"><a href="#cb191-13" aria-hidden="true" tabindex="-1"></a>tmp<span class="op">.</span>first <span class="op">=</span> <span class="dv">5</span><span class="op">;</span>  <span class="co">// tmp 是引用，所以会修改原对象</span></span>
<span id="cb191-14"><a href="#cb191-14" aria-hidden="true" tabindex="-1"></a><span class="co">// 相应地，如果使用 auto [x, y] = pair 声明，就和原对象无关</span></span>
<span id="cb191-15"><a href="#cb191-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-16"><a href="#cb191-16" aria-hidden="true" tabindex="-1"></a><span class="co">// 绝大多数情况下，x 的行为都和 tmp.first 相同</span></span>
<span id="cb191-17"><a href="#cb191-17" aria-hidden="true" tabindex="-1"></a><span class="co">// 例如 decltype(x), decltype((x))</span></span>
<span id="cb191-18"><a href="#cb191-18" aria-hidden="true" tabindex="-1"></a><span class="kw">decltype</span><span class="op">(</span>tmp<span class="op">.</span>first<span class="op">);</span>  <span class="co">// int（而不是可能被认为的 int &amp;，这是一个实体，会得到 std::pair&lt;int, int&gt;::first 被声明的类型）</span></span>
<span id="cb191-19"><a href="#cb191-19" aria-hidden="true" tabindex="-1"></a><span class="kw">decltype</span><span class="op">((</span>tmp<span class="op">.</span>first<span class="op">));</span>  <span class="co">// int &amp;</span></span></code></pre></div>
<p>基于范围的 <code>for</code> 循环中也可以使用结构化绑定。</p>
<div class="sourceCode" id="cb192"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="at">const</span> <span class="op">&amp;[</span>key<span class="op">,</span> value<span class="op">]:</span> map<span class="op">)</span> <span class="op">{</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="if-初始化语句">if 初始化语句</h3>
<p>C++17 起，<code>if</code>
语句，在条件之前可以添加一个初始化语句，在条件判断之前执行。在此处定义的变量，作用域会在
<code>if</code> 的右侧花括号处结束。</p>
<div class="sourceCode" id="cb193"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> res <span class="op">=</span> f<span class="op">();</span> is_prime<span class="op">(</span>res<span class="op">))</span> <span class="op">{</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 接下来可以使用 res</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 也可以使用 res</span></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a><span class="co">// 此处不再可以使用 res</span></span></code></pre></div>
<h3 id="三路比较运算符">三路比较运算符</h3>
<p>两个对象的大小关系往往分为三类：小于、等于或大于。有些情况下，我们会根据它们的比较关系进行不同的分支操作。</p>
<div class="sourceCode" id="cb194"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s1<span class="op">,</span> s2<span class="op">;</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>s1 <span class="op">&lt;</span> s2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"less"</span><span class="op">;</span></span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>s1 <span class="op">==</span> s2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"equal"</span><span class="op">;</span></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"greater"</span><span class="op">;</span></span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>注意到，这种写法最多会调用两次比较函数，非常浪费。实际上，我们完全有能力一次性判断出它是三种大小关系的哪一个。C++20
引入了“三路比较运算符”，用来表达两个对象的大小关系。</p>
<p>三路比较运算符的返回值通常为
<code>std::strong_ordering</code>。它定义了几个常量值，包括（省略
<code>std::strong_ordering::</code> 前缀）：</p>
<ul>
<li><code>less</code>，表示左侧小于右侧。</li>
<li><code>equal</code> 或
<code>equivalent</code>，表示左侧等于右侧。它们是实际上是相等的。</li>
<li><code>greater</code>，表示左侧大于右侧。</li>
</ul>
<p>可以用以下的方式使用：</p>
<div class="sourceCode" id="cb195"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> cmp <span class="op">=</span> s1 <span class="op">&lt;=&gt;</span> s2<span class="op">;</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>cmp <span class="op">==</span> <span class="bu">std::</span>strong_ordering::less<span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>cmp <span class="op">==</span> <span class="bu">std::</span>strong_ordering::equal<span class="op">)</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{</span> <span class="co">/*...*/</span> <span class="op">}</span></span></code></pre></div>
<p>可以发现，这种写法过于冗长。所以可以使用另一种较为简便的方法，让
<code>std::strong_ordering</code> 对象和 <code>0</code>
比较，返回布尔值。</p>
<ul>
<li><code>cmp &lt; 0</code>：<code>less</code>。</li>
<li><code>cmp == 0</code>：<code>equivalent</code>。</li>
<li><code>cmp &gt; 0</code>：<code>greater</code>。</li>
</ul>
<p>标准类型之间都已经定义了三路比较运算符。可以使用三路比较运算符描述很多的比较逻辑。例如依次按照
<code>a</code>、<code>b</code>、<code>c</code> 比较：</p>
<div class="sourceCode" id="cb196"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> cmp <span class="op">=</span> x<span class="op">.</span>a <span class="op">&lt;=&gt;</span> y<span class="op">.</span>a<span class="op">;</span> cmp <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> cmp<span class="op">;</span></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span><span class="kw">auto</span> cmp <span class="op">=</span> x<span class="op">.</span>b <span class="op">&lt;=&gt;</span> y<span class="op">.</span>b<span class="op">;</span> cmp <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> cmp<span class="op">;</span></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> x<span class="op">.</span>c <span class="op">&lt;=&gt;</span> y<span class="op">.</span>c<span class="op">;</span></span></code></pre></div>
<p>可以重载 <code>&lt;=&gt;</code> 运算符，在此之后，编译器会自动生成
<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>
这四个运算符。C++20 之后，重载 <code>==</code> 运算符会自动生成
<code>!=</code> 运算符。</p>
<p>C++20
之后，可以通过如下方式，让编译器自动生成全部六个比较函数。这将会基于各个成员的声明顺序，进行字典序比较。</p>
<div class="sourceCode" id="cb197"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> S <span class="op">{</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">&lt;=&gt;</span> <span class="op">(</span>S <span class="at">const</span> <span class="op">&amp;)</span> <span class="at">const</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>实际上，除了 <code>std::strong_ordering</code>
以外，还有几个类似的类型。它们之间的使用方式一致，但是语义有所不同。</p>
<ul>
<li><code>std::strong_ordering</code>：表示两个相等的对象是无法区分的，即如果
<code>a == b</code>，一定有
<code>f(a) == f(b)</code>。例如字符串比较。</li>
<li><code>std::weak_ordering</code>：表示两个相等的对象可能被区分，例如不区分大小写的字符串比较。</li>
<li><code>std::partial_ordering</code>：不在意相等对象的可区分性，但是有一个额外的状态，表示这两个对象之间“不可比较”。（例如，浮点数的
<code>NaN</code> 返回 <code>partial_ordering</code>；其他内置类型返回
<code>strong_ordering</code>）</li>
</ul>
<p>所有比较类别都有 <code>less</code>、<code>greater</code> 和
<code>equivalent</code>，<code>strong_ordering</code> 有额外的
<code>equal</code>，<code>partial_ordering</code> 有额外的
<code>unordered</code>。</p>
<p>不同的返回类型不会影响运算符的生成、标准库工具的行为，但是可以体现不同的语义，有利于编写“自解释”的代码。通常情况下使用
<code>strong_ordering</code> 即可（例如按照所有成员的字典序比较）。</p>
<h4 id="标准库的比较函数">标准库的比较函数</h4>
<p>很多标准库函数允许我们传入比较函数（例如
<code>std::sort</code>），用于替代小于号进行比较。这类比较函数需要满足一些约束。（如果是通过自定义类型的重载运算符，也需要满足相同规则）</p>
<p>小于号的语义必须是“严格弱序”，即如同三路比较的结果为
<code>std::weak_ordering::less</code>。一个常见的错误是以下代码：</p>
<div class="sourceCode" id="cb198"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>sort<span class="op">(</span>v<span class="op">.</span>begin<span class="op">(),</span> v<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="kw">auto</span> a<span class="op">,</span> <span class="kw">auto</span> b<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> a<span class="op">.</span>val <span class="op">&lt;=</span> b<span class="op">.</span>val<span class="op">;</span> <span class="op">});</span></span></code></pre></div>
<p>具体来讲，需要满足以下要求：</p>
<ul>
<li><code>!(a &lt; a)</code>。</li>
<li>如果 <code>a &lt; b</code>，则 <code>!(b &lt; a)</code>。</li>
<li>如果 <code>a &lt; b</code> 且 <code>b &lt; c</code>，则
<code>a &lt; c</code>。</li>
<li>定义
<code>equiv(a, b) = !(a &lt; b) &amp;&amp; !(b &lt; a)</code>，表示二者的等价关系；这种等价关系也可传递，即如果
<code>equiv(a, b)</code> 且 <code>equiv(b, c)</code>，则
<code>equiv(a, c)</code>。</li>
</ul>
<p>以及另外的几个要求：</p>
<ul>
<li>必须能够接受 <code>const</code>
类型的参数。（通常使用常量引用或者值传递小对象作为参数）</li>
<li>相同的输入必须得到确定的输出。</li>
</ul>
<h3 id="异常处理">异常处理</h3>
<p>异常是 C++
处理运行时错误的机制。当程序出现运行时错误时，可以跳出常规的代码执行逻辑，转到专用的错误处理代码。</p>
<p>异常处理采用以下方式：</p>
<ul>
<li>异常对象：用于描述发生了什么错误。</li>
<li>抛出异常：停止当前函数执行，沿着函数调用栈向上回溯，直到被捕获。这个过程称为“栈展开”。</li>
<li>捕获异常：当捕获到特定类型的异常对象，停止栈展开过程，执行对应的处理代码。</li>
</ul>
<p>但是需要注意，只有代码抛出的异常才能被捕获。越界访问、空指针访问等未定义行为导致的运行时错误无法被捕获。</p>
<p>例如以下代码：</p>
<div class="sourceCode" id="cb199"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> divide<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>y <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 抛出异常，类型为 std::invalid_argument</span></span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span> <span class="bu">std::</span>invalid_argument<span class="op">(</span><span class="st">"division by zero."</span><span class="op">);</span></span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb199-6"><a href="#cb199-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x <span class="op">/</span> y<span class="op">;</span></span>
<span id="cb199-7"><a href="#cb199-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb199-8"><a href="#cb199-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-9"><a href="#cb199-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb199-10"><a href="#cb199-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> <span class="op">{</span>  <span class="co">// 这个代码块中有可能抛出异常并捕获</span></span>
<span id="cb199-11"><a href="#cb199-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">{},</span> y<span class="op">{};</span></span>
<span id="cb199-12"><a href="#cb199-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x <span class="op">&gt;&gt;</span> y<span class="op">;</span></span>
<span id="cb199-13"><a href="#cb199-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> divide<span class="op">(</span>x<span class="op">,</span> y<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb199-14"><a href="#cb199-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>invalid_argument <span class="op">&amp;</span>err<span class="op">)</span> <span class="op">{</span></span>
<span id="cb199-15"><a href="#cb199-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 捕获到类型为 std::invalid_argument 的异常，执行处理代码</span></span>
<span id="cb199-16"><a href="#cb199-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// err.what() 返回构造时传递的字符串参数</span></span>
<span id="cb199-17"><a href="#cb199-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Cannot calculate. Error: "</span> <span class="op">&lt;&lt;</span> err<span class="op">.</span>what<span class="op">()</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb199-18"><a href="#cb199-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb199-19"><a href="#cb199-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 捕获所有类型的异常</span></span>
<span id="cb199-20"><a href="#cb199-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Unknown Error."</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb199-21"><a href="#cb199-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb199-22"><a href="#cb199-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>异常对象可以是任意类型（如 <code>int</code>），但是习惯使用
<code>std::exception</code>
的某个派生类。以下是若干个标准库中定义的异常，使用缩进层级表示继承关系。</p>
<div class="sourceCode" id="cb200"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>exception</span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a>├── <span class="bu">std::</span>bad_alloc                <span class="co">// 内存分配失败 (new)</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a>├── <span class="bu">std::</span>bad_cast                 <span class="co">// 动态转换失败 (dynamic_cast)</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a>├── <span class="bu">std::</span>bad_typeid               <span class="co">// typeid 操作失败</span></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a>├── <span class="bu">std::</span>bad_exception            <span class="co">// 意外异常</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a>├── <span class="bu">std::</span>logic_error              <span class="co">// 逻辑错误</span></span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a>│   ├── <span class="bu">std::</span>invalid_argument     <span class="co">// 无效参数</span></span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a>│   ├── <span class="bu">std::</span>domain_error         <span class="co">// 定义域错误</span></span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a>│   ├── <span class="bu">std::</span>length_error         <span class="co">// 长度超出限制</span></span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true" tabindex="-1"></a>│   └── <span class="bu">std::</span>out_of_range         <span class="co">// 超出有效范围</span></span>
<span id="cb200-11"><a href="#cb200-11" aria-hidden="true" tabindex="-1"></a>└── <span class="bu">std::</span>runtime_error            <span class="co">// 运行时错误</span></span>
<span id="cb200-12"><a href="#cb200-12" aria-hidden="true" tabindex="-1"></a>    ├── <span class="bu">std::</span>range_error          <span class="co">// 计算结果超出范围</span></span>
<span id="cb200-13"><a href="#cb200-13" aria-hidden="true" tabindex="-1"></a>    ├── <span class="bu">std::</span>overflow_error       <span class="co">// 算术上溢</span></span>
<span id="cb200-14"><a href="#cb200-14" aria-hidden="true" tabindex="-1"></a>    └── <span class="bu">std::</span>underflow_error      <span class="co">// 算术下溢</span></span></code></pre></div>
<p>如果想要抛出自定义类型的异常，应从某个标准异常派生。可以覆写虚函数
<code>what()</code> 返回提示信息。</p>
<div class="sourceCode" id="cb201"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> MyException <span class="op">:</span> <span class="kw">public</span> <span class="bu">std::</span>exception <span class="op">{</span></span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string message<span class="op">;</span></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>    MyException<span class="op">(</span><span class="bu">std::</span>string s<span class="op">)</span> <span class="op">:</span> message<span class="op">(</span><span class="st">"Error: "</span> <span class="op">+</span> <span class="bu">std::</span>move<span class="op">(</span>s<span class="op">))</span> <span class="op">{}</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-5"><a href="#cb201-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> what<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="dt">char</span> <span class="at">const</span> <span class="op">*</span> <span class="kw">override</span> <span class="op">{</span></span>
<span id="cb201-6"><a href="#cb201-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> message<span class="op">.</span>c_str<span class="op">();</span></span>
<span id="cb201-7"><a href="#cb201-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb201-8"><a href="#cb201-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>在发生错误时，异常处理的运行时效率非常低（但是正常运行无额外开销）。不要使用异常处理代替正常代码逻辑（例如跳出多层递归），除非异常处理的性能开销可以接受。</p>
<p>在可能抛出异常的代码中，为了保证资源被正确清理，需要使用 RAII
机制，通过对象的析构函数来清理资源。<code>std::unique_ptr</code>
可能会有一些帮助。</p>
<h4 id="异常安全">异常安全</h4>
<p>在一个操作中，如果抛出了异常，这个操作将被中断。这也意味着，一个对象可能已经被修改到了一个中间状态，但是无法进一步操作，导致操作未完成的情况下，原始数据丢失。</p>
<p>函数可以有以下几个级别的异常安全保证，是从严格到宽松的关系。</p>
<ul>
<li>不抛出保证。无论如何，该函数都不会抛出异常。可以使用
<code>noexcept</code>
显式声明这个函数是不抛出异常的。析构函数、移动构造和赋值、交换函数必须标记为
<code>noexcept</code>。</li>
<li>强异常保证。如果函数抛出异常，程序将会保持调用前的状态。</li>
<li>基本异常保证。如果函数抛出异常，相关对象可能发生数据丢失，但是程序仍然处于有效状态。不会发生资源泄露等更严重问题。</li>
<li>无异常保证。如果函数抛出异常，不对程序状态做任何保证。</li>
</ul>
<p>C++ 标准对标准库函数声明了各自的异常安全保证。</p>
<h3 id="编译器扩展">编译器扩展</h3>
<p>以下的内容均为 GCC
的编译器扩展，而非标准行为。包含编译器扩展的代码会降低可移植性，但是有很多编译器扩展在
OI 中是很方便的。若无特殊说明，这些内容在 NOI
系列考试中大概率是可以使用的，但是<strong>实际请以考试编译环境为准</strong>。</p>
<p>在主流编译器中，GCC 和 clang 有很多相似的扩展。MSVC 则大有不同。</p>
<p>如果你正在研究 C++ 标准语法，请打开 <code>-ftrapv</code>
对编译器扩展行为给出警告。</p>
<h4 id="万能头文件">万能头文件</h4>
<p>GCC 提供了头文件 <code>bits/stdc++.h</code> 包含全部 C++
标准库头文件。在 OI 中可以避免多次添加头文件，切换上下文，打断思路。</p>
<h4 id="int128">__int128</h4>
<p><code>__int128</code> 是一种扩展整数类型，能够存储 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.713ex" height="2.581ex" role="img" focusable="false" viewBox="0 -891 5177 1141"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mo" transform="translate(278,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msup" transform="translate(1056,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(2699.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msup" transform="translate(3144.3,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z" transform="translate(1000,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(4788,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>
范围内的整数。它还有无符号变种 <code>unsigned __int128</code>，值域为
<span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.365ex" height="2.565ex" role="img" focusable="false" viewBox="0 -883.9 3255.3 1133.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msup" transform="translate(1222.7,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" transform="translate(533,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"></path><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1000,0)"></path></g></g></g><g data-mml-node="mo" transform="translate(2866.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>。</p>
<p>它支持和其他整数一致的算术运算（加减乘除模），但是标准库并没有提供支持。例如
<code>cin</code> 和 <code>cout</code> 不能输入输出
<code>__int128</code>，<code>abs()</code> 函数不能对
<code>__int128</code> 取绝对值。</p>
<p>GCC 默认使用的是名为 <code>gnu++</code> 的扩展标准，可能支持
<code>__int128</code> 的更多操作。在考场上，请始终使用
<code>-std=c++14</code>（或以后可能换用更高标准）编译程序，避免 CE。</p>
<h4 id="内建位运算函数">内建位运算函数</h4>
<p>GCC
提供了很多用来进行位运算的编译器扩展。这些函数的效率很高，远高于手写（可能直接编译成一条硬件指令）。</p>
<p>这些函数都是接受 <code>unsigned int</code>
类型。同时提供了不同后缀的变种，接受 <code>unsigned long</code> 和
<code>unsigned long long</code>。例如：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>参数类型</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__builtin_clz</code></td>
<td><code>unsigned int</code></td>
</tr>
<tr>
<td><code>__builtin_clzl</code></td>
<td><code>unsigned long</code></td>
</tr>
<tr>
<td><code>__builtin_clzll</code></td>
<td><code>unsigned long long</code></td>
</tr>
</tbody>
</table>
<p>C++20
起，标准库提供了它们的替代品。在调用标准库函数时，可以自动推导类型，但是传入的必须是无符号整数，否则会编译错误。</p>
<table>
<thead>
<tr>
<th>内建函数</th>
<th>替代方案</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__builtin_popcount</code></td>
<td><code>std::popcount(x)</code></td>
<td>二进制“1”的个数</td>
</tr>
<tr>
<td><code>__builtin_clz</code></td>
<td><code>std::countl_zero(x)</code></td>
<td>二进制前导零数量</td>
</tr>
<tr>
<td><code>__builtin_ctz</code></td>
<td><code>std::countr_zero(x)</code></td>
<td>二进制后缀零数量</td>
</tr>
<tr>
<td><code>__builtin_parity</code></td>
<td><code>std::popcount(x) &amp; 1</code></td>
<td>popcount 的奇偶性</td>
</tr>
<tr>
<td><code>std::__lg</code></td>
<td><code>std::bit_width(x)-1</code></td>
<td><code>log2(x)</code> 下取整</td>
</tr>
</tbody>
</table>
<p><code>std::__lg</code>
本质上不是内建函数，而是标准库实现过程中的一个工具函数。因为只有 GCC
配套的 libstdc++
标准库提供了这个函数，所以它也不具备可移植性，和内建函数性质相似，所以归到这里。</p>
<p>向这些函数中传入 0 是未定义行为。</p>
<p>另外还有一个常用的函数是
<code>std::__gcd(x, y)</code>，用于求两个整数的最大公约数，它的性质和
<code>std::__lg</code> 一致。C++17 标准提供了 <code>std::gcd</code>
替代，并且采用了更高效的“二进制 gcd”算法。</p>
<h4 id="调试宏">调试宏</h4>
<p>GCC
调试宏为标准库工具提供了更多的检查，可以检查容器访问越界、迭代器非法使用，甚至
<code>lower_bound</code>
之前没有排序这样的问题。但是<strong>对于原生数组依旧没有任何检查</strong>。</p>
<p>可以使用 <code>std::array</code> 或者 <code>std::vector</code>
替代所有原生数组，配合调试宏，可以提供越界检查。并且前者不会引入任何的运行时开销。</p>
<p>使用调试宏可以发现绝大多数运行时错误的位置，配合 gdb
工具可以获取更佳体验。</p>
<p>在<strong>头文件之前</strong>添加以下宏定义即可使用调试宏。</p>
<div class="sourceCode" id="cb202"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define _GLIBCXX_DEBUG </span><span class="dv">1</span></span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define _GLIBCXX_DEBUG_PEDANTIC </span><span class="dv">1</span></span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define _GLIBCXX_SANITIZE_VECTOR </span><span class="dv">1</span></span></code></pre></div>
<p>或者添加以下编译选项：</p>
<pre><code>-D_GLIBCXX_DEBUG=1 -D_GLIBCXX_DEBUG_PEDANTIC=1 -D_GLIBCXX_SANITIZE_VECTOR=1</code></pre>
<p><strong>调试宏会极大地影响代码运行速度</strong>（让代码的运行时间延长
5~10 倍，甚至更多），所以在提交到 OJ
之前需要删除调试宏。建议在本地编译选项中包含调试宏，而不是通过代码中的
<code>#define</code>。进行性能测试前请删除调试宏。</p>
<h2 id="实用标准库工具">实用标准库工具</h2>
<p>下方会列出一些比较好用，但又没有
<code>set</code>、<code>pair</code>、<code>vector</code>、<code>sort</code>
那样熟知的标准库工具。C++ 标准库其实有很多工具都很好用。</p>
<h3 id="assert">assert</h3>
<p><code>assert</code> 是一个预定义的宏，在 <code>cassert</code>
头文件中。它用于确保某个条件成立，否则中断程序运行，并输出诊断信息。例如：</p>
<div class="sourceCode" id="cb204"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> f<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a>    <span class="ot">assert</span><span class="op">(</span>x <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>此时这个函数如果传入了一个负数，将会在这一行出现断言失败。此时的报错信息可以提示错误行号，方便调试。</p>
<p>C++26 起可以使用 <code>contract_assert</code> 来替代
<code>assert</code>，但是在此之前，<code>assert</code> 都极为好用。</p>
<h3 id="随机数生成器">随机数生成器</h3>
<p>C++11 起通过 <code>random</code>
头文件提供了更加现代的随机数生成器。此前使用 <code>rand()</code>
进行随机数生成，随机数质量较低，并且值域上限较小（由实现定义，通常为
32767），无法满足使用。</p>
<p>最常用的随机数生成器是
<code>std::mt19937</code>。通过以下方式定义一个 <code>mt19937</code>
生成器：</p>
<div class="sourceCode" id="cb205"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>mt19937 rng<span class="op">{</span><span class="co">/*seed*/</span><span class="op">};</span></span></code></pre></div>
<p><code>mt19937</code>
生成的是伪随机数，本质上是通过一个种子不断地进行确定变换。相同种子会导致接下来随机数生成的行为一致。</p>
<p><code>std::random_device{}()</code>
可以生成一个真随机数，但是效率较低，通常只用来提供一次随机种子。以下是一个常见的用法：</p>
<div class="sourceCode" id="cb206"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>mt19937 rng<span class="op">{</span><span class="bu">std::</span>random_device<span class="op">{}()};</span></span></code></pre></div>
<p>接下来便可以开始使用 <code>rng</code> 生成随机数了。直接使用
<code>rng()</code> 可以在 <code>unsigned int</code>
值域内均匀随机地生成一个整数。</p>
<p>如果希望生成某个值域内的整数，通常情况下可以简单地通过取模实现。如果希望绝对的均匀随机，可以通过
<code>std::uniform_int_distribution</code>。</p>
<div class="sourceCode" id="cb207"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 假设需要 [1, 10]</span></span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> rng<span class="op">()</span> <span class="op">%</span> <span class="dv">10</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// 通常情况下足够</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>uniform_int_distribution dist<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">10</span><span class="op">};</span></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> y <span class="op">=</span> dist<span class="op">(</span>rng<span class="op">);</span></span></code></pre></div>
<p>如果要生成数据的值域大于 <code>unsigned int</code>
值域，也可以安全地使用 <code>uniform_int_distribution</code>。</p>
<div class="sourceCode" id="cb208"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> max <span class="op">=</span> <span class="fl">1e14</span><span class="op">;</span></span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>uniform_int_distribution<span class="op">&lt;</span><span class="dt">long</span> <span class="dt">long</span><span class="op">&gt;</span> dist<span class="op">{</span><span class="dv">1</span><span class="op">,</span> max<span class="op">};</span></span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> res <span class="op">=</span> dist<span class="op">(</span>rng<span class="op">);</span>  <span class="co">// res 类型为 long long</span></span></code></pre></div>
<p>更多的随机数生成器和随机分布，见 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/random.html">cppreference</a>。</p>
<h3 id="ranges">ranges</h3>
<p>C++20 起添加了 ranges
库，进一步方便了代码编写。一方面优化了标准库算法的使用，另一方面添加了更多的实用功能。</p>
<h4 id="ranges-算法">ranges 算法</h4>
<p><code>ranges</code>
命名空间中重新实现了几乎所有标准库算法（<code>algorithm</code>
头文件），最大的特点就是可以不再显式传入 <code>begin</code> 和
<code>end</code> 参数。</p>
<div class="sourceCode" id="cb209"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">;</span></span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb209-3"><a href="#cb209-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ranges::sort<span class="op">(</span>vec<span class="op">);</span></span>
<span id="cb209-4"><a href="#cb209-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ranges::sort<span class="op">(</span>vec<span class="op">.</span>begin<span class="op">(),</span> vec<span class="op">.</span>end<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span>  <span class="co">// 两种方式均可支持</span></span></code></pre></div>
<p>所以 C++20 起，建议全面使用 ranges 算法代替旧的标准库算法。</p>
<p>ranges
算法还有一个“投影”特性，可以传入一个投影函数，实际表现相当于将范围内的所有元素进行一次投影，对投影后的元素进行操作，间接影响原始元素。这只是一个直观理解，实际上每个
ranges 算法都对投影函数做了严谨的定义。例如，假设投影函数为
<code>proj</code>，<code>sort</code> 可以保证排序后的结果，若
<code>x</code> 在 <code>y</code> 之前，则 <code>proj(y)</code> &lt;
<code>proj(x)</code> 为 <code>false</code>。</p>
<p>听起来可能有些抽象。可以通过以下例子理解，这会把所有的元素按照
<code>second</code> 排序。</p>
<div class="sourceCode" id="cb210"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&gt;</span> vec<span class="op">;</span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>ranges::sort<span class="op">(</span>vec<span class="op">,</span> <span class="bu">std::</span>less<span class="op">{}</span><span class="co">/*比较函数*/</span><span class="op">,</span> <span class="op">[](</span><span class="kw">auto</span> x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">.</span>second<span class="op">;</span> <span class="op">}</span><span class="co">/*投影函数*/</span><span class="op">);</span></span></code></pre></div>
<h4 id="视图">视图</h4>
<p>视图（views）是 ranges
库中的另一个重要概念。它可以通过“管道运算符”对范围进行操作，允许进行链式地数据处理。视图通过头文件
<code>ranges</code> 提供。</p>
<p>管道运算符实际上是重载的按位或，使用方式为
<code>range | op</code>。<code>range</code>
是原始范围，然后使用范围适配器 <code>op</code>
来描述一个操作，最后返回一个新范围。</p>
<p>例如，<code>std::views::reverse</code> 就是一个范围适配器，可以将
<code>range</code> 中的元素逆序。以下代码可以逆序输出 <code>vec</code>
中的所有元素。</p>
<div class="sourceCode" id="cb211"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector vec<span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">:</span> vec <span class="op">|</span> <span class="bu">std::</span>views::reverse<span class="op">)</span> <span class="op">{</span></span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> x <span class="op">&lt;&lt;</span> <span class="ch">' '</span><span class="op">;</span></span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>实际上，大多数视图是惰性求值的，即在访问元素的同时进行计算。如果最终的范围遍历一半就中止，不会有额外的计算。</p>
<p>以下是一些常用的视图（省略 <code>std::views</code> 命名空间）：</p>
<ul>
<li><code>filter(pred)</code>：筛选符合条件的元素。仅保留
<code>pred(x)</code> 为 <code>true</code> 的函数。</li>
<li><code>transform(func)</code>：映射元素。对每个旧范围的元素
<code>x</code>，新范围会包含一个元素 <code>func(x)</code>。</li>
<li><code>take(n)</code>：只取前 <code>n</code> 个元素。</li>
<li><code>drop(n)</code>：跳过前 <code>n</code> 个元素。</li>
<li><code>reverse</code>：反转序列。</li>
<li><code>join</code>：展平一层嵌套范围。例如
<code>{{0, 1}, {2, 3}}</code> 变为 <code>{0, 1, 2, 3}</code>。</li>
<li><code>split(x)</code>：根据指定元素分隔范围。例如
<code>{1, 2, 0, 3, 0, 4}</code> 按照 <code>0</code> 划分，变为
<code>{{1, 2}, {3}, {4}}</code>。</li>
</ul>
<p>以及可以使用 <code>std::views::iota(a, b)</code> 生成一个 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.683ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2069.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(807,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1251.7,0)"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(1680.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span> 范围内的连续序列。例如
<code>std::views::iota(3, 6)</code> 包含元素 3、4、5。</p>
<p>C++23 起，可以使用 <code>std::ranges::to</code>
把一个范围转换为另一个范围，即构造一个指定类型范围，依次包含原范围的所有元素。</p>
<p>例如，以下是一个字符串的分割。</p>
<div class="sourceCode" id="cb212"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>string s<span class="op">{</span><span class="st">"abc,de,fg"</span><span class="op">};</span></span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> x<span class="op">:</span> s <span class="op">|</span> <span class="bu">std::</span>views::split<span class="op">(</span><span class="ch">','</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="bu">std::</span>ranges::to<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">&gt;(</span>x<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>以下代码可以输入一个 1-index 的 vector。</p>
<div class="sourceCode" id="cb213"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vec<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>x<span class="op">:</span> vec <span class="op">|</span> views<span class="op">::</span>drop<span class="op">(</span><span class="dv">1</span><span class="op">))</span> <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> x<span class="op">;</span></span></code></pre></div>
<h2 id="实战实现简易-vector">实战：实现简易 vector</h2>
<p>在这个章节中，我们将会在最新的 C++ 标准下实现一个简易的
<code>vector</code>，支持 <code>std::vector</code> 的部分功能。</p>
<p><code>vector</code>
使用一片连续内存存储对象。为了实现扩容操作，采取以下策略：</p>
<ul>
<li>预留一部分内存，足以存储 <code>capacity</code> 个元素。但是实际只有
<code>size</code> 个元素。</li>
<li>当 <code>size == capacity</code>
时发生扩容，重新分配内存、移动数据，使得 <code>capacity</code>
翻倍。</li>
</ul>
<p>可以证明，这种策略下 <code>push_back</code> 的均摊复杂度是 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span>。</p>
<p>首先，定义一个元素类型 <code>A</code>，便于观察
<code>std::vector</code> 的行为。</p>
<div class="sourceCode" id="cb214"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value<span class="op">{};</span></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>    A<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Default Construct</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span><span class="dt">int</span> value<span class="op">):</span> value<span class="op">{</span>value<span class="op">}</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Construct"</span> <span class="op">&lt;&lt;</span> value <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span>A <span class="at">const</span> <span class="op">&amp;</span>other<span class="op">):</span> value<span class="op">{</span>other<span class="op">.</span>value<span class="op">}</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Copy Construct"</span> <span class="op">&lt;&lt;</span> value <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a>    A<span class="op">(</span>A <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="kw">noexcept</span><span class="op">:</span> value<span class="op">{</span>other<span class="op">.</span>value<span class="op">}</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Move Construct"</span> <span class="op">&lt;&lt;</span> value <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span>A <span class="at">const</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">-&gt;</span> A <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Copy Assign"</span> <span class="op">&lt;&lt;</span> value <span class="op">&lt;&lt;</span> <span class="ch">' '</span> <span class="op">&lt;&lt;</span> other<span class="op">.</span>value <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> other<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb214-12"><a href="#cb214-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb214-13"><a href="#cb214-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb214-14"><a href="#cb214-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span>A <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> A <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb214-15"><a href="#cb214-15" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">"Move Assign"</span> <span class="op">&lt;&lt;</span> value <span class="op">&lt;&lt;</span> <span class="ch">' '</span> <span class="op">&lt;&lt;</span> other<span class="op">.</span>value <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb214-16"><a href="#cb214-16" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> other<span class="op">.</span>value<span class="op">;</span></span>
<span id="cb214-17"><a href="#cb214-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb214-18"><a href="#cb214-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb214-19"><a href="#cb214-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="动态内存分配-1">动态内存分配</h3>
<p>我们先来实现动态内存分配相关操作。事实上，<code>std::vector</code>
使用分配器（Allocator）来实现，但是相关机制较为复杂，我们采用简化方案：封装静态成员函数
<code>allocate</code> 和 <code>deallocate</code> 进行分配和解分配。</p>
<div class="sourceCode" id="cb215"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> mystd <span class="op">{</span></span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">class</span> vector <span class="op">{</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 分配未初始化内存，足以存储 n 个 T 类型</span></span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="kw">constexpr</span> <span class="at">static</span> allocate<span class="op">(</span><span class="bu">std::</span>size_t n<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">*</span> <span class="op">{</span></span>
<span id="cb215-6"><a href="#cb215-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb215-7"><a href="#cb215-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>is_constant_evaluated<span class="op">())</span> <span class="op">{</span></span>
<span id="cb215-8"><a href="#cb215-8" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 编译器开洞实现 std::allocator，可以在编译期动态分配内存</span></span>
<span id="cb215-9"><a href="#cb215-9" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 正常的常量求值无法使用 ::operator new</span></span>
<span id="cb215-10"><a href="#cb215-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="bu">std::</span>allocator<span class="op">&lt;</span>T<span class="op">&gt;{}.</span>allocate<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb215-11"><a href="#cb215-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb215-12"><a href="#cb215-12" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 显式指定对象对齐，允许非标准对齐的对象</span></span>
<span id="cb215-13"><a href="#cb215-13" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> ptr <span class="op">=</span> <span class="op">::</span><span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span>n <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span>T<span class="op">),</span> <span class="bu">std::</span>align_val_t<span class="op">{</span><span class="kw">alignof</span><span class="op">(</span>T<span class="op">)});</span></span>
<span id="cb215-14"><a href="#cb215-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="kw">static_cast</span><span class="op">&lt;</span>T <span class="op">*&gt;(</span>ptr<span class="op">);</span></span>
<span id="cb215-15"><a href="#cb215-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb215-16"><a href="#cb215-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb215-17"><a href="#cb215-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-18"><a href="#cb215-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 释放 allocate 分配的内存</span></span>
<span id="cb215-19"><a href="#cb215-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> <span class="kw">constexpr</span> <span class="at">static</span> deallocate<span class="op">(</span>T <span class="op">*</span>ptr<span class="op">,</span> <span class="bu">std::</span>size_t n<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb215-20"><a href="#cb215-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>is_constant_evaluated<span class="op">())</span> <span class="op">{</span></span>
<span id="cb215-21"><a href="#cb215-21" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>allocator<span class="op">&lt;</span>T<span class="op">&gt;{}.</span>deallocate<span class="op">(</span>ptr<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb215-22"><a href="#cb215-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb215-23"><a href="#cb215-23" aria-hidden="true" tabindex="-1"></a>                <span class="op">::</span><span class="kw">operator</span> <span class="kw">delete</span><span class="op">(</span>ptr<span class="op">,</span> <span class="bu">std::</span>align_val_t<span class="op">{</span><span class="kw">alignof</span><span class="op">(</span>T<span class="op">)});</span></span>
<span id="cb215-24"><a href="#cb215-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb215-25"><a href="#cb215-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb215-26"><a href="#cb215-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb215-27"><a href="#cb215-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="基本定义">基本定义</h3>
<p><code>vector</code> 需要以下三个成员存储数据：</p>
<ul>
<li><code>data_</code>：存储区开始的指针。</li>
<li><code>size_</code>：当前存储的元素数量。</li>
<li><code>capacity_</code>：存储区最多能存储的元素数量。</li>
</ul>
<p>还需要定义一些嵌套类型：</p>
<ul>
<li><code>iterator</code>：迭代器。</li>
<li><code>const_iterator</code>：常量迭代器。</li>
<li><code>value_type</code>：元素类型，即 <code>T</code>。</li>
</ul>
<p>这里我们直接使用指针作为迭代器。</p>
<div class="sourceCode" id="cb216"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a>    T <span class="op">*</span><span class="va">data_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb216-3"><a href="#cb216-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t <span class="va">size_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb216-4"><a href="#cb216-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t <span class="va">capacity_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb216-5"><a href="#cb216-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-6"><a href="#cb216-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> iterator <span class="op">=</span> T <span class="op">*;</span></span>
<span id="cb216-7"><a href="#cb216-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> const_iterator <span class="op">=</span> T <span class="at">const</span> <span class="op">*;</span></span>
<span id="cb216-8"><a href="#cb216-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">using</span> <span class="dt">value_type</span> <span class="op">=</span> T<span class="op">;</span></span>
<span id="cb216-9"><a href="#cb216-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb216-10"><a href="#cb216-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> vector<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb216-11"><a href="#cb216-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-12"><a href="#cb216-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> size<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="bu">std::</span>size_t <span class="op">{</span> <span class="cf">return</span> <span class="va">size_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb216-13"><a href="#cb216-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> capacity<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="bu">std::</span>size_t <span class="op">{</span> <span class="cf">return</span> <span class="va">capacity_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb216-14"><a href="#cb216-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> data<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> T <span class="op">*</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">data_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb216-15"><a href="#cb216-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb216-16"><a href="#cb216-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// begin() end() 需要同时提供 const 和非 const 版本</span></span>
<span id="cb216-17"><a href="#cb216-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> begin<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> const_iterator <span class="op">{</span> <span class="cf">return</span> <span class="va">data_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb216-18"><a href="#cb216-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> end<span class="op">()</span> <span class="at">const</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> const_iterator <span class="op">{</span> <span class="cf">return</span> <span class="va">data_</span> <span class="op">+</span> <span class="va">size_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb216-19"><a href="#cb216-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> begin<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> iterator <span class="op">{</span> <span class="cf">return</span> <span class="va">data_</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb216-20"><a href="#cb216-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> end<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> iterator <span class="op">{</span> <span class="cf">return</span> <span class="va">data_</span> <span class="op">+</span> <span class="va">size_</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<h3 id="基础功能">基础功能</h3>
<p>我们将会在这里实现构造函数、析构函数、下标访问等基本功能。</p>
<div class="sourceCode" id="cb217"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> vector<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="op">~</span>vector<span class="op">()</span> <span class="op">{</span></span>
<span id="cb217-4"><a href="#cb217-4" aria-hidden="true" tabindex="-1"></a>        destroy_all<span class="op">();</span></span>
<span id="cb217-5"><a href="#cb217-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-6"><a href="#cb217-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-7"><a href="#cb217-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">explicit</span> <span class="kw">constexpr</span> vector<span class="op">(</span><span class="bu">std::</span>size_t count<span class="op">)</span></span>
<span id="cb217-8"><a href="#cb217-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="va">data_</span><span class="op">(</span>allocate<span class="op">(</span>count<span class="op">)),</span> <span class="va">capacity_</span><span class="op">(</span>count<span class="op">)</span></span>
<span id="cb217-9"><a href="#cb217-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb217-10"><a href="#cb217-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb217-11"><a href="#cb217-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span>T <span class="op">*</span>ptr <span class="op">=</span> <span class="va">data_</span><span class="op">;</span> <span class="va">size_</span> <span class="op">!=</span> count<span class="op">;</span> <span class="op">++</span><span class="va">size_</span><span class="op">,</span> <span class="op">++</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb217-12"><a href="#cb217-12" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>construct_at<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb217-13"><a href="#cb217-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb217-14"><a href="#cb217-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb217-15"><a href="#cb217-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 构造失败，销毁资源并释放内存（异常安全）</span></span>
<span id="cb217-16"><a href="#cb217-16" aria-hidden="true" tabindex="-1"></a>            destroy_all<span class="op">();</span>  <span class="co">// 由于 size_ 是当前元素数量，可以直接使用</span></span>
<span id="cb217-17"><a href="#cb217-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span><span class="op">;</span>  <span class="co">// 重新抛出异常</span></span>
<span id="cb217-18"><a href="#cb217-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb217-19"><a href="#cb217-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-20"><a href="#cb217-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span><span class="bu">std::</span>size_t count<span class="op">,</span> T <span class="at">const</span> <span class="op">&amp;</span>value<span class="op">)</span></span>
<span id="cb217-21"><a href="#cb217-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="va">data_</span><span class="op">(</span>allocate<span class="op">(</span>count<span class="op">)),</span> <span class="va">capacity_</span><span class="op">(</span>count<span class="op">)</span></span>
<span id="cb217-22"><a href="#cb217-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb217-23"><a href="#cb217-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb217-24"><a href="#cb217-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span>T <span class="op">*</span>ptr <span class="op">=</span> <span class="va">data_</span><span class="op">;</span> <span class="va">size_</span> <span class="op">!=</span> count<span class="op">;</span> <span class="op">++</span><span class="va">size_</span><span class="op">,</span> <span class="op">++</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb217-25"><a href="#cb217-25" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>construct_at<span class="op">(</span>ptr<span class="op">,</span> value<span class="op">);</span></span>
<span id="cb217-26"><a href="#cb217-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb217-27"><a href="#cb217-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb217-28"><a href="#cb217-28" aria-hidden="true" tabindex="-1"></a>            destroy_all<span class="op">();</span></span>
<span id="cb217-29"><a href="#cb217-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span><span class="op">;</span></span>
<span id="cb217-30"><a href="#cb217-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb217-31"><a href="#cb217-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-32"><a href="#cb217-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 复制构造函数</span></span>
<span id="cb217-33"><a href="#cb217-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span>vector <span class="at">const</span> <span class="op">&amp;</span>other<span class="op">)</span></span>
<span id="cb217-34"><a href="#cb217-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="va">data_</span><span class="op">(</span>allocate<span class="op">(</span>other<span class="op">.</span>size<span class="op">())),</span> <span class="va">capacity_</span><span class="op">(</span>other<span class="op">.</span>size<span class="op">())</span></span>
<span id="cb217-35"><a href="#cb217-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb217-36"><a href="#cb217-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb217-37"><a href="#cb217-37" aria-hidden="true" tabindex="-1"></a>            T <span class="at">const</span> <span class="op">*</span>in <span class="op">=</span> other<span class="op">.</span><span class="va">data_</span><span class="op">;</span></span>
<span id="cb217-38"><a href="#cb217-38" aria-hidden="true" tabindex="-1"></a>            T <span class="op">*</span>out <span class="op">=</span> <span class="va">data_</span><span class="op">;</span></span>
<span id="cb217-39"><a href="#cb217-39" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(;</span> <span class="va">size_</span> <span class="op">!=</span> other<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span><span class="va">size_</span><span class="op">,</span> <span class="op">++</span>in<span class="op">,</span> <span class="op">++</span>out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb217-40"><a href="#cb217-40" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>construct_at<span class="op">(</span>out<span class="op">,</span> <span class="op">*</span>in<span class="op">);</span></span>
<span id="cb217-41"><a href="#cb217-41" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb217-42"><a href="#cb217-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb217-43"><a href="#cb217-43" aria-hidden="true" tabindex="-1"></a>            destroy_all<span class="op">();</span></span>
<span id="cb217-44"><a href="#cb217-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span><span class="op">;</span></span>
<span id="cb217-45"><a href="#cb217-45" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb217-46"><a href="#cb217-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-47"><a href="#cb217-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-48"><a href="#cb217-48" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 移动构造函数</span></span>
<span id="cb217-49"><a href="#cb217-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span>vector <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb217-50"><a href="#cb217-50" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> <span class="va">data_</span><span class="op">(</span>other<span class="op">.</span><span class="va">data_</span><span class="op">),</span> <span class="va">size_</span><span class="op">(</span>other<span class="op">.</span><span class="va">size_</span><span class="op">),</span> <span class="va">capacity_</span><span class="op">(</span>other<span class="op">.</span><span class="va">capacity_</span><span class="op">)</span></span>
<span id="cb217-51"><a href="#cb217-51" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb217-52"><a href="#cb217-52" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 将另一个容器置空，避免内存多次释放</span></span>
<span id="cb217-53"><a href="#cb217-53" aria-hidden="true" tabindex="-1"></a>        other<span class="op">.</span><span class="va">data_</span> <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb217-54"><a href="#cb217-54" aria-hidden="true" tabindex="-1"></a>        other<span class="op">.</span><span class="va">size_</span> <span class="op">=</span> other<span class="op">.</span><span class="va">capacity_</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb217-55"><a href="#cb217-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-56"><a href="#cb217-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-57"><a href="#cb217-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 接受一个范围内的数据</span></span>
<span id="cb217-58"><a href="#cb217-58" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> InputIt<span class="op">&gt;</span></span>
<span id="cb217-59"><a href="#cb217-59" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span>InputIt first<span class="op">,</span> InputIt last<span class="op">):</span> vector<span class="op">()</span> <span class="op">{</span></span>
<span id="cb217-60"><a href="#cb217-60" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 如果是 ForwardIterator，预先获取区间大小；否则依次 emplace_back</span></span>
<span id="cb217-61"><a href="#cb217-61" aria-hidden="true" tabindex="-1"></a>        <span class="kw">using</span> category <span class="op">=</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits<span class="op">&lt;</span>InputIt<span class="op">&gt;::</span>iterator_category<span class="op">;</span></span>
<span id="cb217-62"><a href="#cb217-62" aria-hidden="true" tabindex="-1"></a>        <span class="kw">constexpr</span> <span class="dt">bool</span> is_forward <span class="op">=</span> <span class="bu">std::</span>is_base_of_v<span class="op">&lt;</span><span class="bu">std::</span>forward_iterator_tag<span class="op">,</span> category<span class="op">&gt;;</span></span>
<span id="cb217-63"><a href="#cb217-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-64"><a href="#cb217-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span>is_forward<span class="op">)</span> <span class="op">{</span></span>
<span id="cb217-65"><a href="#cb217-65" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>size_t size <span class="op">=</span> <span class="bu">std::</span>distance<span class="op">(</span>first<span class="op">,</span> last<span class="op">);</span></span>
<span id="cb217-66"><a href="#cb217-66" aria-hidden="true" tabindex="-1"></a>            reserve<span class="op">(</span>size<span class="op">);</span></span>
<span id="cb217-67"><a href="#cb217-67" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb217-68"><a href="#cb217-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-69"><a href="#cb217-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(;</span> first <span class="op">!=</span> last<span class="op">;</span> <span class="op">++</span>first<span class="op">)</span> <span class="op">{</span></span>
<span id="cb217-70"><a href="#cb217-70" aria-hidden="true" tabindex="-1"></a>            emplace_back<span class="op">(*</span>first<span class="op">);</span></span>
<span id="cb217-71"><a href="#cb217-71" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb217-72"><a href="#cb217-72" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-73"><a href="#cb217-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-74"><a href="#cb217-74" aria-hidden="true" tabindex="-1"></a>    <span class="co">// std::initializer_list</span></span>
<span id="cb217-75"><a href="#cb217-75" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> vector<span class="op">(</span><span class="bu">std::</span>initializer_list<span class="op">&lt;</span>T<span class="op">&gt;</span> list<span class="op">)</span></span>
<span id="cb217-76"><a href="#cb217-76" aria-hidden="true" tabindex="-1"></a>        <span class="op">:</span> vector<span class="op">(</span>list<span class="op">.</span>begin<span class="op">(),</span> list<span class="op">.</span>end<span class="op">())</span> <span class="op">{}</span></span>
<span id="cb217-77"><a href="#cb217-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-78"><a href="#cb217-78" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> <span class="kw">operator</span><span class="op">[]</span> <span class="op">(</span><span class="bu">std::</span>size_t pos<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb217-79"><a href="#cb217-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">data_</span><span class="op">[</span>pos<span class="op">];</span></span>
<span id="cb217-80"><a href="#cb217-80" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-81"><a href="#cb217-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 同时提供常量的只读下标访问</span></span>
<span id="cb217-82"><a href="#cb217-82" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> <span class="kw">operator</span><span class="op">[]</span> <span class="op">(</span><span class="bu">std::</span>size_t pos<span class="op">)</span> <span class="at">const</span> <span class="op">-&gt;</span> T <span class="at">const</span> <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb217-83"><a href="#cb217-83" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">data_</span><span class="op">[</span>pos<span class="op">];</span></span>
<span id="cb217-84"><a href="#cb217-84" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-85"><a href="#cb217-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb217-86"><a href="#cb217-86" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 交换两个 vector</span></span>
<span id="cb217-87"><a href="#cb217-87" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> swap<span class="op">(</span>vector <span class="op">&amp;</span>other<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb217-88"><a href="#cb217-88" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span><span class="va">data_</span><span class="op">,</span> other<span class="op">.</span><span class="va">data_</span><span class="op">);</span></span>
<span id="cb217-89"><a href="#cb217-89" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span><span class="va">size_</span><span class="op">,</span> other<span class="op">.</span><span class="va">size_</span><span class="op">);</span></span>
<span id="cb217-90"><a href="#cb217-90" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>swap<span class="op">(</span><span class="va">capacity_</span><span class="op">,</span> other<span class="op">.</span><span class="va">capacity_</span><span class="op">);</span></span>
<span id="cb217-91"><a href="#cb217-91" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-92"><a href="#cb217-92" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 提供非成员的 swap，允许 ADL 查找</span></span>
<span id="cb217-93"><a href="#cb217-93" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">friend</span> <span class="kw">constexpr</span> swap<span class="op">(</span>vector <span class="op">&amp;</span>lhs<span class="op">,</span> vector <span class="op">&amp;</span>rhs<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb217-94"><a href="#cb217-94" aria-hidden="true" tabindex="-1"></a>        lhs<span class="op">.</span>swap<span class="op">(</span>rhs<span class="op">);</span></span>
<span id="cb217-95"><a href="#cb217-95" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-96"><a href="#cb217-96" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 复制赋值</span></span>
<span id="cb217-97"><a href="#cb217-97" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span>vector <span class="at">const</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="op">-&gt;</span> vector <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb217-98"><a href="#cb217-98" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">this</span> <span class="op">==</span> <span class="op">&amp;</span>other<span class="op">)</span> <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span>  <span class="co">// 避免自赋值</span></span>
<span id="cb217-99"><a href="#cb217-99" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>T<span class="op">&gt;</span> tmp<span class="op">(</span>other<span class="op">);</span>  <span class="co">// 构造临时对象</span></span>
<span id="cb217-100"><a href="#cb217-100" aria-hidden="true" tabindex="-1"></a>        swap<span class="op">(</span>tmp<span class="op">);</span>  <span class="co">// 直接和临时对象交换，复用代码且异常安全</span></span>
<span id="cb217-101"><a href="#cb217-101" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb217-102"><a href="#cb217-102" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-103"><a href="#cb217-103" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 移动赋值</span></span>
<span id="cb217-104"><a href="#cb217-104" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> <span class="kw">operator</span><span class="op">=</span> <span class="op">(</span>vector <span class="op">&amp;&amp;</span>other<span class="op">)</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> vector <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb217-105"><a href="#cb217-105" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>T<span class="op">&gt;</span> tmp<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>other<span class="op">));</span>  <span class="co">// 移动构造一个临时对象，other 直接置空</span></span>
<span id="cb217-106"><a href="#cb217-106" aria-hidden="true" tabindex="-1"></a>        swap<span class="op">(</span>tmp<span class="op">);</span>  <span class="co">// 和临时对象交换，旧资源将在 tmp 销毁时释放</span></span>
<span id="cb217-107"><a href="#cb217-107" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 可以证明，这种方式对于自赋值是安全的</span></span>
<span id="cb217-108"><a href="#cb217-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span><span class="kw">this</span><span class="op">;</span></span>
<span id="cb217-109"><a href="#cb217-109" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-110"><a href="#cb217-110" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb217-111"><a href="#cb217-111" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 销毁所有元素，释放资源</span></span>
<span id="cb217-112"><a href="#cb217-112" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> <span class="kw">constexpr</span> destroy_all<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb217-113"><a href="#cb217-113" aria-hidden="true" tabindex="-1"></a>        T <span class="op">*</span>ptr <span class="op">=</span> data<span class="op">();</span></span>
<span id="cb217-114"><a href="#cb217-114" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="bu">std::</span>size_t i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">!=</span> size<span class="op">();</span> <span class="op">++</span>i<span class="op">,</span> <span class="op">++</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb217-115"><a href="#cb217-115" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>destroy_at<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb217-116"><a href="#cb217-116" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb217-117"><a href="#cb217-117" aria-hidden="true" tabindex="-1"></a>        deallocate<span class="op">(</span>data<span class="op">(),</span> capacity<span class="op">());</span></span>
<span id="cb217-118"><a href="#cb217-118" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb217-119"><a href="#cb217-119" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="动态扩容">动态扩容</h3>
<p>我们将会实现
<code>push_back</code>、<code>emplace_back</code>，并正确地处理扩容逻辑。</p>
<div class="sourceCode" id="cb218"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="kw">constexpr</span> back<span class="op">()</span> <span class="at">const</span> <span class="op">-&gt;</span> T <span class="at">const</span> <span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">data_</span><span class="op">[</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="op">}</span></span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="kw">constexpr</span> front<span class="op">()</span> <span class="at">const</span> <span class="op">-&gt;</span> T <span class="at">const</span> <span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">data_</span><span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="op">}</span></span>
<span id="cb218-3"><a href="#cb218-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="kw">constexpr</span> back<span class="op">()</span> <span class="op">-&gt;</span> T <span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">data_</span><span class="op">[</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="op">}</span></span>
<span id="cb218-4"><a href="#cb218-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="kw">constexpr</span> front<span class="op">()</span> <span class="op">-&gt;</span> T <span class="op">&amp;</span> <span class="op">{</span> <span class="cf">return</span> <span class="va">data_</span><span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="op">}</span></span>
<span id="cb218-5"><a href="#cb218-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-6"><a href="#cb218-6" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> <span class="op">...</span>Ts<span class="op">&gt;</span></span>
<span id="cb218-7"><a href="#cb218-7" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="kw">constexpr</span> emplace_back<span class="op">(</span>Ts <span class="op">&amp;&amp;...</span>args<span class="op">)</span> <span class="op">-&gt;</span> T <span class="op">&amp;</span> <span class="op">{</span></span>
<span id="cb218-8"><a href="#cb218-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 检查是否需要扩容</span></span>
<span id="cb218-9"><a href="#cb218-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>size<span class="op">()</span> <span class="op">==</span> capacity<span class="op">())</span> <span class="op">{</span></span>
<span id="cb218-10"><a href="#cb218-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 执行扩容</span></span>
<span id="cb218-11"><a href="#cb218-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 分配一片新的内存</span></span>
<span id="cb218-12"><a href="#cb218-12" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> new_capacity <span class="op">=</span> capacity<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">?</span> <span class="dv">1</span><span class="op">:</span> capacity<span class="op">()</span> <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb218-13"><a href="#cb218-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> new_data <span class="op">=</span> allocate<span class="op">(</span>new_capacity<span class="op">);</span></span>
<span id="cb218-14"><a href="#cb218-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 直接构造新对象</span></span>
<span id="cb218-15"><a href="#cb218-15" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> pos <span class="op">=</span> new_data <span class="op">+</span> size<span class="op">();</span></span>
<span id="cb218-16"><a href="#cb218-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>construct_at<span class="op">(</span>pos<span class="op">,</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>Ts<span class="op">&gt;(</span>args<span class="op">)...);</span></span>
<span id="cb218-17"><a href="#cb218-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 逐个移动现有元素</span></span>
<span id="cb218-18"><a href="#cb218-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 但是此处需要注意，仅当移动构造为 noexcept 才能保证强异常安全</span></span>
<span id="cb218-19"><a href="#cb218-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 否则如果在某个元素移动时抛出异常，将会永久丢失它的状态，无法保证回退</span></span>
<span id="cb218-20"><a href="#cb218-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 标准库的处理是，如果不能安全地移动，就使用拷贝构造。</span></span>
<span id="cb218-21"><a href="#cb218-21" aria-hidden="true" tabindex="-1"></a>        T <span class="op">*</span>in <span class="op">=</span> data<span class="op">();</span></span>
<span id="cb218-22"><a href="#cb218-22" aria-hidden="true" tabindex="-1"></a>        T <span class="op">*</span>out <span class="op">=</span> new_data<span class="op">;</span></span>
<span id="cb218-23"><a href="#cb218-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb218-24"><a href="#cb218-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="bu">std::</span>size_t i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">!=</span> size<span class="op">();</span> <span class="op">++</span>i<span class="op">,</span> <span class="op">++</span>in<span class="op">,</span> <span class="op">++</span>out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb218-25"><a href="#cb218-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="bu">std::</span>is_nothrow_move_constructible_v<span class="op">&lt;</span>T<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb218-26"><a href="#cb218-26" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>construct_at<span class="op">(</span>out<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(*</span>in<span class="op">));</span></span>
<span id="cb218-27"><a href="#cb218-27" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb218-28"><a href="#cb218-28" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">std::</span>construct_at<span class="op">(</span>out<span class="op">,</span> <span class="op">*</span>in<span class="op">);</span></span>
<span id="cb218-29"><a href="#cb218-29" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb218-30"><a href="#cb218-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb218-31"><a href="#cb218-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb218-32"><a href="#cb218-32" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 销毁刚构造的新元素</span></span>
<span id="cb218-33"><a href="#cb218-33" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>destroy_at<span class="op">(</span>pos<span class="op">);</span></span>
<span id="cb218-34"><a href="#cb218-34" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> ptr <span class="op">=</span> new_data<span class="op">;</span> ptr <span class="op">!=</span> out<span class="op">;</span> <span class="op">++</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb218-35"><a href="#cb218-35" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>destroy_at<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb218-36"><a href="#cb218-36" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb218-37"><a href="#cb218-37" aria-hidden="true" tabindex="-1"></a>            deallocate<span class="op">(</span>new_data<span class="op">,</span> new_capacity<span class="op">);</span></span>
<span id="cb218-38"><a href="#cb218-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span><span class="op">;</span></span>
<span id="cb218-39"><a href="#cb218-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb218-40"><a href="#cb218-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 释放旧数据</span></span>
<span id="cb218-41"><a href="#cb218-41" aria-hidden="true" tabindex="-1"></a>        destroy_all<span class="op">();</span></span>
<span id="cb218-42"><a href="#cb218-42" aria-hidden="true" tabindex="-1"></a>        <span class="va">data_</span> <span class="op">=</span> new_data<span class="op">,</span> <span class="va">capacity_</span> <span class="op">=</span> new_capacity<span class="op">;</span></span>
<span id="cb218-43"><a href="#cb218-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb218-44"><a href="#cb218-44" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 直接在结尾构造</span></span>
<span id="cb218-45"><a href="#cb218-45" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> pos <span class="op">=</span> data<span class="op">()</span> <span class="op">+</span> size<span class="op">();</span></span>
<span id="cb218-46"><a href="#cb218-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>construct_at<span class="op">(</span>pos<span class="op">,</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>Ts<span class="op">&gt;(</span>args<span class="op">)...);</span></span>
<span id="cb218-47"><a href="#cb218-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb218-48"><a href="#cb218-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">++</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb218-49"><a href="#cb218-49" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> back<span class="op">();</span></span>
<span id="cb218-50"><a href="#cb218-50" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb218-51"><a href="#cb218-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-52"><a href="#cb218-52" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="kw">constexpr</span> push_back<span class="op">(</span>T <span class="at">const</span> <span class="op">&amp;</span>x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb218-53"><a href="#cb218-53" aria-hidden="true" tabindex="-1"></a>    emplace_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb218-54"><a href="#cb218-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb218-55"><a href="#cb218-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-56"><a href="#cb218-56" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="kw">constexpr</span> push_back<span class="op">(</span>T <span class="op">&amp;&amp;</span>x<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb218-57"><a href="#cb218-57" aria-hidden="true" tabindex="-1"></a>    emplace_back<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>x<span class="op">));</span></span>
<span id="cb218-58"><a href="#cb218-58" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb218-59"><a href="#cb218-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-60"><a href="#cb218-60" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="kw">constexpr</span> reserve<span class="op">(</span><span class="bu">std::</span>size_t new_cap<span class="op">)</span> <span class="op">-&gt;</span> <span class="dt">void</span> <span class="op">{</span></span>
<span id="cb218-61"><a href="#cb218-61" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>new_cap <span class="op">&lt;=</span> capacity<span class="op">())</span> <span class="cf">return</span><span class="op">;</span></span>
<span id="cb218-62"><a href="#cb218-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span> new_data <span class="op">=</span> allocate<span class="op">(</span>new_cap<span class="op">);</span></span>
<span id="cb218-63"><a href="#cb218-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-64"><a href="#cb218-64" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 和 emplace_back 相同逻辑，决定移动还是复制</span></span>
<span id="cb218-65"><a href="#cb218-65" aria-hidden="true" tabindex="-1"></a>    T <span class="op">*</span>in <span class="op">=</span> data<span class="op">();</span></span>
<span id="cb218-66"><a href="#cb218-66" aria-hidden="true" tabindex="-1"></a>    T <span class="op">*</span>out <span class="op">=</span> new_data<span class="op">;</span></span>
<span id="cb218-67"><a href="#cb218-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb218-68"><a href="#cb218-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> end_ptr <span class="op">=</span> data<span class="op">()</span> <span class="op">+</span> size<span class="op">();</span> in <span class="op">!=</span> end_ptr<span class="op">;</span> <span class="op">++</span>in<span class="op">,</span> <span class="op">++</span>out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb218-69"><a href="#cb218-69" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="bu">std::</span>is_nothrow_move_constructible_v<span class="op">&lt;</span>T<span class="op">&gt;)</span> <span class="op">{</span></span>
<span id="cb218-70"><a href="#cb218-70" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>construct_at<span class="op">(</span>out<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(*</span>in<span class="op">));</span></span>
<span id="cb218-71"><a href="#cb218-71" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb218-72"><a href="#cb218-72" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>construct_at<span class="op">(</span>out<span class="op">,</span> <span class="op">*</span>in<span class="op">);</span></span>
<span id="cb218-73"><a href="#cb218-73" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb218-74"><a href="#cb218-74" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb218-75"><a href="#cb218-75" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb218-76"><a href="#cb218-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> ptr <span class="op">=</span> new_data<span class="op">;</span> ptr <span class="op">!=</span> out<span class="op">;</span> <span class="op">++</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb218-77"><a href="#cb218-77" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>destroy_at<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb218-78"><a href="#cb218-78" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb218-79"><a href="#cb218-79" aria-hidden="true" tabindex="-1"></a>        deallocate<span class="op">(</span>new_data<span class="op">,</span> new_cap<span class="op">);</span></span>
<span id="cb218-80"><a href="#cb218-80" aria-hidden="true" tabindex="-1"></a>        <span class="cf">throw</span><span class="op">;</span></span>
<span id="cb218-81"><a href="#cb218-81" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb218-82"><a href="#cb218-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb218-83"><a href="#cb218-83" aria-hidden="true" tabindex="-1"></a>    destroy_all<span class="op">();</span></span>
<span id="cb218-84"><a href="#cb218-84" aria-hidden="true" tabindex="-1"></a>    <span class="va">data_</span> <span class="op">=</span> new_data<span class="op">;</span></span>
<span id="cb218-85"><a href="#cb218-85" aria-hidden="true" tabindex="-1"></a>    <span class="va">capacity_</span> <span class="op">=</span> new_cap<span class="op">;</span></span>
<span id="cb218-86"><a href="#cb218-86" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="其他操作">其他操作</h3>
<p>此处以 <code>insert</code>
为例，主要演示何时应该使用构造，何时应该使用赋值。</p>
<div class="sourceCode" id="cb219"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 这里采取了一种简化的实现方法，按值传参，在内部统一移动</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 对于 std::array 这类移动开销大的对象可能性能较差</span></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a><span class="co">// 标准库分别实现了 T const &amp; 和 T &amp;&amp;，更加健壮</span></span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 标准库 insert 没有强异常安全的保证，所以可以直接使用移动赋值和构造</span></span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> <span class="kw">constexpr</span> insert<span class="op">(</span>const_iterator pos<span class="op">,</span> T value<span class="op">)</span> <span class="op">-&gt;</span> iterator <span class="op">{</span></span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>size_t index <span class="op">=</span> pos <span class="op">-</span> begin<span class="op">();</span></span>
<span id="cb219-7"><a href="#cb219-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>size<span class="op">()</span> <span class="op">==</span> capacity<span class="op">())</span> <span class="op">{</span></span>
<span id="cb219-8"><a href="#cb219-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 扩容的同时移动数据</span></span>
<span id="cb219-9"><a href="#cb219-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> new_capacity <span class="op">=</span> capacity<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">?</span> <span class="dv">1</span><span class="op">:</span> capacity<span class="op">()</span> <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb219-10"><a href="#cb219-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> new_data <span class="op">=</span> allocate<span class="op">(</span>new_capacity<span class="op">);</span></span>
<span id="cb219-11"><a href="#cb219-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-12"><a href="#cb219-12" aria-hidden="true" tabindex="-1"></a>        T <span class="op">*</span>in <span class="op">=</span> data<span class="op">();</span></span>
<span id="cb219-13"><a href="#cb219-13" aria-hidden="true" tabindex="-1"></a>        T <span class="op">*</span>out <span class="op">=</span> new_data<span class="op">;</span></span>
<span id="cb219-14"><a href="#cb219-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span> <span class="op">{</span></span>
<span id="cb219-15"><a href="#cb219-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(;</span> in <span class="op">!=</span> pos<span class="op">;</span> <span class="op">++</span>in<span class="op">,</span> <span class="op">++</span>out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb219-16"><a href="#cb219-16" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 内存位置尚未构造对象，所以使用构造而非赋值</span></span>
<span id="cb219-17"><a href="#cb219-17" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>construct_at<span class="op">(</span>out<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(*</span>in<span class="op">));</span></span>
<span id="cb219-18"><a href="#cb219-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb219-19"><a href="#cb219-19" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>construct_at<span class="op">(</span>out<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(</span>value<span class="op">)),</span> <span class="op">++</span>out<span class="op">;</span></span>
<span id="cb219-20"><a href="#cb219-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> end_ptr <span class="op">=</span> data<span class="op">()</span> <span class="op">+</span> size<span class="op">();</span> in <span class="op">!=</span> end_ptr<span class="op">;</span> <span class="op">++</span>in<span class="op">,</span> <span class="op">++</span>out<span class="op">)</span> <span class="op">{</span></span>
<span id="cb219-21"><a href="#cb219-21" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>construct_at<span class="op">(</span>out<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(*</span>in<span class="op">));</span></span>
<span id="cb219-22"><a href="#cb219-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb219-23"><a href="#cb219-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">catch</span> <span class="op">(...)</span> <span class="op">{</span></span>
<span id="cb219-24"><a href="#cb219-24" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 出现异常，保证无资源泄漏即可</span></span>
<span id="cb219-25"><a href="#cb219-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> ptr <span class="op">=</span> new_data<span class="op">;</span> ptr <span class="op">!=</span> out<span class="op">;</span> <span class="op">++</span>ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb219-26"><a href="#cb219-26" aria-hidden="true" tabindex="-1"></a>                <span class="bu">std::</span>destroy_at<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb219-27"><a href="#cb219-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb219-28"><a href="#cb219-28" aria-hidden="true" tabindex="-1"></a>            deallocate<span class="op">(</span>new_data<span class="op">,</span> new_capacity<span class="op">);</span></span>
<span id="cb219-29"><a href="#cb219-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">throw</span><span class="op">;</span></span>
<span id="cb219-30"><a href="#cb219-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb219-31"><a href="#cb219-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-32"><a href="#cb219-32" aria-hidden="true" tabindex="-1"></a>        destroy_all<span class="op">();</span></span>
<span id="cb219-33"><a href="#cb219-33" aria-hidden="true" tabindex="-1"></a>        <span class="va">data_</span> <span class="op">=</span> new_data<span class="op">,</span> <span class="va">capacity_</span> <span class="op">=</span> new_capacity<span class="op">;</span></span>
<span id="cb219-34"><a href="#cb219-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">++</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb219-35"><a href="#cb219-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb219-36"><a href="#cb219-36" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 直接移动数据</span></span>
<span id="cb219-37"><a href="#cb219-37" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 最后一个元素使用构造，其他元素使用赋值</span></span>
<span id="cb219-38"><a href="#cb219-38" aria-hidden="true" tabindex="-1"></a>        T <span class="op">*</span>out <span class="op">=</span> data<span class="op">()</span> <span class="op">+</span> size<span class="op">();</span></span>
<span id="cb219-39"><a href="#cb219-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 结尾插入元素，直接构造即可</span></span>
<span id="cb219-40"><a href="#cb219-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pos <span class="op">==</span> end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb219-41"><a href="#cb219-41" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>construct_at<span class="op">(</span>out<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(</span>value<span class="op">));</span></span>
<span id="cb219-42"><a href="#cb219-42" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb219-43"><a href="#cb219-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb219-44"><a href="#cb219-44" aria-hidden="true" tabindex="-1"></a>            T <span class="op">*</span>in <span class="op">=</span> <span class="bu">std::</span>prev<span class="op">(</span>out<span class="op">);</span></span>
<span id="cb219-45"><a href="#cb219-45" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>construct_at<span class="op">(</span>out<span class="op">,</span> <span class="bu">std::</span>move<span class="op">(*</span>in<span class="op">)),</span> <span class="op">--</span>out<span class="op">,</span> <span class="op">--</span>in<span class="op">;</span></span>
<span id="cb219-46"><a href="#cb219-46" aria-hidden="true" tabindex="-1"></a>            <span class="op">++</span><span class="va">size_</span><span class="op">;</span></span>
<span id="cb219-47"><a href="#cb219-47" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 此后如果抛出异常，可以保证容器基本信息（size_）正确，但是容器内数据处于未指定状态</span></span>
<span id="cb219-48"><a href="#cb219-48" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(;</span> out <span class="op">!=</span> pos<span class="op">;</span> <span class="op">--</span>out<span class="op">,</span> <span class="op">--</span>in<span class="op">)</span> <span class="op">{</span></span>
<span id="cb219-49"><a href="#cb219-49" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 当这个位置已经有了一个对象，应当使用赋值</span></span>
<span id="cb219-50"><a href="#cb219-50" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 否则应当是先销毁再构造，但是用户定义的赋值可能更加高效</span></span>
<span id="cb219-51"><a href="#cb219-51" aria-hidden="true" tabindex="-1"></a>                <span class="op">*</span>out <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(*</span>in<span class="op">);</span></span>
<span id="cb219-52"><a href="#cb219-52" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb219-53"><a href="#cb219-53" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 此时 out 的位置上同样已经存在对象</span></span>
<span id="cb219-54"><a href="#cb219-54" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 通过赋值放置新对象</span></span>
<span id="cb219-55"><a href="#cb219-55" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>out <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>value<span class="op">);</span></span>
<span id="cb219-56"><a href="#cb219-56" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb219-57"><a href="#cb219-57" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb219-58"><a href="#cb219-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> begin<span class="op">()</span> <span class="op">+</span> index<span class="op">;</span>  <span class="co">// 转换成非常量迭代器</span></span>
<span id="cb219-59"><a href="#cb219-59" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>其他功能不再演示如何实现。以上功能的完整代码见<a target="_blank" rel="noopener" href="https://www.luogu.com.cn/paste/n0pegsd0">洛谷云剪贴板</a>。</p>
<h2 id="结语">结语</h2>
<p>不知不觉间，这篇专栏已经包含不少内容了。由于篇幅限制，这个专栏也即将告一段落。</p>
<p>在这个专栏中，我们介绍了很多可能不被大家熟知的语法特性，从基本的变量、类型，到模板元编程这样更加深入的内容。当然，这篇专栏只是
C++
语言的冰山一角，但是希望你能够从这个专栏得到一些启示，了解到一些比较新鲜的知识。由于个人能力有限，某些地方的表述可能不够清晰，甚至可能存在笔误或理解上的偏差。如果遇到困惑或发现错误，还请多多包涵，也欢迎指正和交流。</p>
<p>正如前言所讲，这些语法特性可能对赛场上的得分不会有帮助，但我相信它们也不会是毫无意义的。也许有一天，你会想要封装属于自己的模板库；也许你会发现，lambda
函数可以简化封装函数的过程，简化你的代码；也许你面对编译器给出的大量报错不再慌张，而是可以冷静地分析其中的函数重载、模板特化；也许你在以后工作中也会使用
C++
进行开发，这些语法特性会成为你项目中的一砖一瓦……那些看似晦涩的特性，当你真正需要它们时，或许也会展现出惊人的价值。</p>
<p>最后，感谢你与我共同完成这次 C++
的学习之旅。“路漫漫其修远兮”，编程之路永无止境，我们都是正在探索的初学者。愿你对技术的好奇心永远如初，愿这段内容能成为你未来编程路上的小小助力。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/blogs/uncategorized/2025/07/b5da511d8bf6/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/blogs/uncategorized/2024/11/a5a1e485ca8f/">
        <h2 class="post-title">Hello World</h2>
    </a>
    <div class="category-and-date">
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/11/11
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> hexo new <span class="st">"My New Post"</span></span></code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> hexo server</span></code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<div class="sourceCode" id="cb3"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> hexo generate</span></code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<div class="sourceCode" id="cb4"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> hexo deploy</span></code></pre></div>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/blogs/uncategorized/2024/11/a5a1e485ca8f/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/blogs/Solution/2024/10/e82fba70d93a/">
        <h2 class="post-title">P5380 鸭棋 题解</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/blogs/categories/Solution/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Solution
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/10/28
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="题意简述">题意简述</h2>
<p>一款在中国象棋基础上制作的游戏“鸭棋”，把棋子“炮”替换为了“鸭”。其中，“鸭”的移动规则是沿着
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="5.028ex" height="1.557ex" role="img" focusable="false" viewBox="0 -666 2222.4 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="mn" transform="translate(1722.4,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></svg></mjx-container></span>
网格的对角线上移动，但是如果在如图的两个红点处有其他棋子，则会“别鸭腿”，移动失败。
<img src="https://cdn.luogu.com.cn/upload/image_hosting/bvt7malu.png" alt="鸭的移动规则"></p>
<p>接下来，给出 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.79ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 791 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container></span> 次移动的起点
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.144ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3157.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(523,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(2768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></span> 和终点 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.144ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3157.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(523,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></span>，对于每一个步骤，要求求出： +
这一步移动的棋子，输出所处阵营和棋子类型，例如 <code>red horse</code>。
+ 这一步吃掉的棋子。 + 这一步后是否构成“将军”。 +
这一步后游戏是否结束。</p>
<p>如果不合法，输出 <code>Invalid command</code>。</p>
<p>其中，“不合法”的情况包括： - 没有选中或者选中敌方棋子。 -
试图攻击己方棋子。 - 试图移动到棋盘外。 - 游戏已经结束。</p>
<p>一方的王（将帅）被吃掉则游戏结束，一步之内可以使游戏结束被称为“将军”。特别地，王被吃掉的那一轮不能算作将军。</p>
<h2 id="题目分析">题目分析</h2>
<p>本题数据范围很小，按照题意模拟即可。主要包括以下步骤： - 选中棋子。 -
判断合法性。 - 移动棋子。 - 判断是否将军和游戏是否结束。</p>
<p>这篇题解将会在判断合法性时采用较为新颖的方法，可以优化编码体验。同时，也会带有一定的面向对象编程的思想。对于模拟题，我的代码通常以追求可读性为主。</p>
<p>接下来按照我会大致按照自己的编码顺序，从大体框架开始介绍。</p>
<h3 id="大体框架">大体框架</h3>
<p>对于棋盘的存储，我选择了直接存储所有棋子及其位置信息。</p>
<p>考虑把棋子抽象成一个类。那么，它需要包括三个属性：类型，位置和队伍。进一步，位置包含
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></svg></mjx-container></span> 坐标和 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewBox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>
坐标两个属性。我们用一个二维向量表示位置。之所以叫做向量，是因为我们接下来会用到一部分的向量运算。</p>
<p>接下来就可以一层一层地定义了。向量类：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec2d <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    Vec2d <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span>x<span class="op">+</span>other<span class="op">.</span>x<span class="op">,</span> y<span class="op">+</span>other<span class="op">.</span>y<span class="op">};</span> <span class="op">}</span> <span class="co">// 加</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    Vec2d <span class="kw">operator</span><span class="op">-(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span>x<span class="op">-</span>other<span class="op">.</span>x<span class="op">,</span> y<span class="op">-</span>other<span class="op">.</span>y<span class="op">};</span> <span class="op">}</span> <span class="co">// 减</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    Vec2d <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> <span class="dt">int</span> other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span>x<span class="op">*</span>other<span class="op">,</span> y<span class="op">*</span>other<span class="op">};</span> <span class="op">}</span> <span class="co">// 数乘</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    Vec2d <span class="kw">operator</span><span class="op">/(</span><span class="at">const</span> <span class="dt">int</span> other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span>x<span class="op">/</span>other<span class="op">,</span> y<span class="op">/</span>other<span class="op">};</span> <span class="op">}</span> <span class="co">// 乘以 1/other</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">*</span>other<span class="op">.</span>x <span class="op">+</span> y<span class="op">*</span>other<span class="op">.</span>y<span class="op">;</span> <span class="op">}</span> <span class="co">// 数量积</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cross<span class="op">(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">*</span>other<span class="op">.</span>y <span class="op">-</span> y<span class="op">*</span>other<span class="op">.</span>x<span class="op">;</span> <span class="op">}</span> <span class="co">// 叉乘的模长</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">==</span>other<span class="op">.</span>x <span class="kw">and</span> y<span class="op">==</span>other<span class="op">.</span>y<span class="op">;</span> <span class="op">}</span> <span class="co">// 相等</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">!=</span>other<span class="op">.</span>x <span class="kw">or</span> y<span class="op">!=</span>other<span class="op">.</span>y<span class="op">;</span> <span class="op">}</span> <span class="co">// 不等</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sqrDistance<span class="op">(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="co">// 两点间欧几里得距离的平方</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>x<span class="op">-</span>other<span class="op">.</span>x<span class="op">)*(</span>x<span class="op">-</span>other<span class="op">.</span>x<span class="op">)+(</span>y<span class="op">-</span>other<span class="op">.</span>y<span class="op">)*(</span>y<span class="op">-</span>other<span class="op">.</span>y<span class="op">);</span> </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> manhattan<span class="op">(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> abs<span class="op">(</span>x<span class="op">-</span>other<span class="op">.</span>x<span class="op">)+</span>abs<span class="op">(</span>y<span class="op">-</span>other<span class="op">.</span>y<span class="op">);</span> <span class="op">}</span> <span class="co">// 曼哈顿距离</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> chebyshev<span class="op">(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>max<span class="op">(</span>abs<span class="op">(</span>x<span class="op">-</span>other<span class="op">.</span>x<span class="op">),</span> abs<span class="op">(</span>y<span class="op">-</span>other<span class="op">.</span>y<span class="op">));</span> <span class="op">}</span> <span class="co">// 切比雪夫距离</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sqrAbs<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">*</span>x<span class="op">+</span>y<span class="op">*</span>y<span class="op">;</span> <span class="op">}</span>  <span class="co">// 模长的平方</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>这里，我们实现了两点间的三种距离也是为下文做准备。叉乘的结果是一个三维向量，这里为了方便直接返回模长。对于欧几里得距离（和模长），我们省略了开平方操作（这会引入浮点数的误差），直接采用开方前的结果。</p>
<p>阵营枚举：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Team <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    Red<span class="op">,</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    Blue<span class="op">,</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>按照定义顺序，<code>Team::Red</code> 和 <code>Team::Blue</code>
分别为 0 和 1。所以我们可以直接使用“异或”操作进行阵营的轮换。</p>
<p>接下来我们定义棋子类和棋子列表。</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Piece<span class="op">;</span>  <span class="co">// 预先声明，解决循环引用问题</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>Piece<span class="op">&gt;</span> pieces<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Piece <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    string  name<span class="op">;</span>   <span class="co">// 棋子类型，如 horse, elephant</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    Vec2d   pos<span class="op">;</span>    <span class="co">// 棋子位置</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    Team    team<span class="op">;</span>   <span class="co">// 棋子阵营</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> reachable<span class="op">(</span>Vec2d dest<span class="op">)</span> <span class="op">{</span>  <span class="co">// 能否到达目标地点</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// To be done.</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>这里有一个小问题，后面我们在实现 <code>reachable</code>
方法的时候会用到 <code>pieces</code>
数组，所以采用了预先声明的办法解决循环引用问题。当然，也可以在类外定义
<code>reachable</code> 方法。</p>
<p>绝大多数定义在这一步就完成了。</p>
<h3 id="判断合法性">判断合法性</h3>
<p>我们先不考虑其他因素，只处理两点的位置和“别脚”问题。</p>
<p>对于相对位置，我们使用上文的三种距离筛选。我们先简要介绍一下这三种距离。</p>
<p>对于两个点 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.144ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3157.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(523,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(2768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></span>
和 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.144ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3157.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(1397.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(1842.2,0)"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(523,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2768.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></span>，我们令
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex;" xmlns="http://www.w3.org/2000/svg" width="30.016ex" height="2.26ex" role="img" focusable="false" viewBox="0 -749.5 13266.9 999"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"></path></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1682.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(2738.6,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="msub" transform="translate(3016.6,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(4247.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msub" transform="translate(5247.6,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(6256.1,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="mo" transform="translate(6534.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(6978.8,0)"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"></path></g><g data-mml-node="mi" transform="translate(7811.8,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(8579.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(9635.3,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="msub" transform="translate(9913.3,0)"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(523,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(11062.1,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="msub" transform="translate(12062.3,0)"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(523,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(12988.9,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g></g></g></svg></mjx-container></span>。则两点的欧几里得距离是 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="10.913ex" height="2.351ex" role="img" focusable="false" viewBox="0 -833.9 4823.6 1038.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"></path></g><g data-mml-node="msup" transform="translate(833,0)"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mn" transform="translate(605,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2063.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(3064,0)"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"></path></g><g data-mml-node="msup" transform="translate(3897,0)"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(523,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g></svg></mjx-container></span>，曼哈顿距离是 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="8.938ex" height="2.084ex" role="img" focusable="false" viewBox="0 -716 3950.4 921"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"></path></g><g data-mml-node="mi" transform="translate(833,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1627.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(2627.4,0)"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"></path></g><g data-mml-node="mi" transform="translate(3460.4,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>，切比雪夫距离是 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.028ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6200.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"></path><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(833,0)"></path><path data-c="78" d="M201 0Q189 3 102 3Q26 3 17 0H11V46H25Q48 47 67 52T96 61T121 78T139 96T160 122T180 150L226 210L168 288Q159 301 149 315T133 336T122 351T113 363T107 370T100 376T94 379T88 381T80 383Q74 383 44 385H16V431H23Q59 429 126 429Q219 429 229 431H237V385Q201 381 201 369Q201 367 211 353T239 315T268 274L272 270L297 304Q329 345 329 358Q329 364 327 369T322 376T317 380T310 384L307 385H302V431H309Q324 428 408 428Q487 428 493 431H499V385H492Q443 385 411 368Q394 360 377 341T312 257L296 236L358 151Q424 61 429 57T446 50Q464 46 499 46H516V0H510H502Q494 1 482 1T457 2T432 2T414 3Q403 3 377 3T327 1L304 0H295V46H298Q309 46 320 51T331 63Q331 65 291 120L250 175Q249 174 219 133T185 88Q181 83 181 74Q181 63 188 55T206 46Q208 46 208 23V0H201Z" transform="translate(1333,0)"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2027.7,0)"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="7B" d="M434 -231Q434 -244 428 -250H410Q281 -250 230 -184Q225 -177 222 -172T217 -161T213 -148T211 -133T210 -111T209 -84T209 -47T209 0Q209 21 209 53Q208 142 204 153Q203 154 203 155Q189 191 153 211T82 231Q71 231 68 234T65 250T68 266T82 269Q116 269 152 289T203 345Q208 356 208 377T209 529V579Q209 634 215 656T244 698Q270 724 324 740Q361 748 377 749Q379 749 390 749T408 750H428Q434 744 434 732Q434 719 431 716Q429 713 415 713Q362 710 332 689T296 647Q291 634 291 499V417Q291 370 288 353T271 314Q240 271 184 255L170 250L184 245Q202 239 220 230T262 196T290 137Q291 131 291 1Q291 -134 296 -147Q306 -174 339 -192T415 -213Q429 -213 431 -216Q434 -219 434 -231Z"></path></g><g data-mml-node="mi" transform="translate(500,0)"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"></path></g><g data-mml-node="mi" transform="translate(1333,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g><g data-mml-node="mo" transform="translate(1905,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2349.7,0)"><path data-c="394" d="M51 0Q46 4 46 7Q46 9 215 357T388 709Q391 716 416 716Q439 716 444 709Q447 705 616 357T786 7Q786 4 781 0H51ZM507 344L384 596L137 92L383 91H630Q630 93 507 344Z"></path></g><g data-mml-node="mi" transform="translate(3182.7,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3672.7,0)"><path data-c="7D" d="M65 731Q65 745 68 747T88 750Q171 750 216 725T279 670Q288 649 289 635T291 501Q292 362 293 357Q306 312 345 291T417 269Q428 269 431 266T434 250T431 234T417 231Q380 231 345 210T298 157Q293 143 292 121T291 -28V-79Q291 -134 285 -156T256 -198Q202 -250 89 -250Q71 -250 68 -247T65 -230Q65 -224 65 -223T66 -218T69 -214T77 -213Q91 -213 108 -210T146 -200T183 -177T207 -139Q208 -134 209 3L210 139Q223 196 280 230Q315 247 330 250Q305 257 280 270Q225 304 212 352L210 362L209 498Q208 635 207 640Q195 680 154 696T77 713Q68 713 67 716T65 731Z"></path></g></g></g></g></g></svg></mjx-container></span>。</p>
<p>感性地理解，曼哈顿距离下的“圆”是一个斜着的正方形，切比雪夫距离下的“圆”是一个正置的正方形。</p>
<p>接下来，我们用 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.176ex" height="1.593ex" role="img" focusable="false" viewBox="0 -694 520 704"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g></g></g></svg></mjx-container></span>
表示欧几里得距离，<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.986ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 878 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container></span>
表示曼哈顿距离，<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.98ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 433 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g></g></svg></mjx-container></span>
表示切比雪夫距离。各种棋子便有如下的筛法： - 王：<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.325ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2353.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(797.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1853.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span> - 士：<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="12.269ex" height="1.946ex" role="img" focusable="false" viewBox="0 -666 5422.8 860"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1155.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2211.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(2711.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3156.2,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(3867,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(4922.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>（或者 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.225ex;" xmlns="http://www.w3.org/2000/svg" width="7.255ex" height="2.398ex" role="img" focusable="false" viewBox="0 -960.5 3206.6 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(797.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msqrt" transform="translate(1853.6,0)"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(0,100.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="500" height="60" x="853" y="840.5"></rect></g></g></g></svg></mjx-container></span>） - 象：<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="12.269ex" height="1.971ex" role="img" focusable="false" viewBox="0 -677 5422.8 871"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1155.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2211.6,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"></path></g><g data-mml-node="mo" transform="translate(2711.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3156.2,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(3867,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(4922.8,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container></span>（或者 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.225ex;" xmlns="http://www.w3.org/2000/svg" width="8.386ex" height="2.398ex" role="img" focusable="false" viewBox="0 -960.5 3706.6 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(797.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1853.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="msqrt" transform="translate(2353.6,0)"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(0,100.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="500" height="60" x="853" y="840.5"></rect></g></g></g></svg></mjx-container></span>） - 马：<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.25ex;" xmlns="http://www.w3.org/2000/svg" width="7.255ex" height="2.398ex" role="img" focusable="false" viewBox="0 -949.5 3206.6 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(797.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msqrt" transform="translate(1853.6,0)"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g></g><g data-mml-node="mo" transform="translate(0,89.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="500" height="60" x="853" y="829.5"></rect></g></g></g></svg></mjx-container></span> - 车：<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.486ex;" xmlns="http://www.w3.org/2000/svg" width="10.131ex" height="2.106ex" role="img" focusable="false" viewBox="0 -716 4478.1 931"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1155.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2211.6,0)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(2922.3,0)"><path data-c="2260" d="M166 -215T159 -215T147 -212T141 -204T139 -197Q139 -190 144 -183L306 133H70Q56 140 56 153Q56 168 72 173H327L406 327H72Q56 332 56 347Q56 360 70 367H426Q597 702 602 707Q605 716 618 716Q625 716 630 712T636 703T638 696Q638 692 471 367H707Q722 359 722 347Q722 336 708 328L451 327L371 173H708Q722 163 722 153Q722 140 707 133H351Q175 -210 170 -212Q166 -215 159 -215Z"></path></g><g data-mml-node="mn" transform="translate(3978.1,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g></svg></mjx-container></span> - 鸭：<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.25ex;" xmlns="http://www.w3.org/2000/svg" width="8.386ex" height="2.398ex" role="img" focusable="false" viewBox="0 -949.5 3706.6 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(797.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msqrt" transform="translate(1853.6,0)"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(500,0)"></path></g></g><g data-mml-node="mo" transform="translate(0,89.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="1000" height="60" x="853" y="829.5"></rect></g></g></g></svg></mjx-container></span> - 兵：<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.128ex" height="1.692ex" role="img" focusable="false" viewBox="0 -666 2266.6 748"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g><g data-mml-node="mo" transform="translate(710.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(1766.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span></p>
<p>接下来处理“别脚”的情况。这里我们就用到向量筛选。我们设 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.79ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 791 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container></span> 是当前棋盘上的一个棋子，出发点是 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.726ex" height="1.643ex" role="img" focusable="false" viewBox="0 -704 763 726"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g></g></g></svg></mjx-container></span>，终点是 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.699ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 751 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g></g></g></svg></mjx-container></span>。为了简便，令 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="16.149ex" height="4ex" role="img" focusable="false" viewBox="0 -1574 7137.8 1768"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(806.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mover" transform="translate(1862.6,0)"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mi" transform="translate(763,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g></g><g data-mml-node="mo" transform="translate(0,891)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(514,0)"></path><svg width="614" height="865" x="0" y="-182" viewBox="153.5 -182 614 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(1.184,1)"></path></svg></g></g><g data-mml-node="mo" transform="translate(3376.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3821.2,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(4528,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mover" transform="translate(5583.8,0)"><g data-mml-node="mrow"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mi" transform="translate(763,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g><g data-mml-node="mo" transform="translate(0,891)"><path data-c="2192" d="M56 237T56 250T70 270H835Q719 357 692 493Q692 494 692 496T691 499Q691 511 708 511H711Q720 511 723 510T729 506T732 497T735 481T743 456Q765 389 816 336T935 261Q944 258 944 250Q944 244 939 241T915 231T877 212Q836 186 806 152T761 85T740 35T732 4Q730 -6 727 -8T711 -11Q691 -11 691 0Q691 7 696 25Q728 151 835 230H70Q56 237 56 250Z" transform="translate(554,0)"></path><svg width="654" height="865" x="0" y="-182" viewBox="163.5 -182 654 865"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z" transform="scale(1.261,1)"></path></svg></g></g></g></g></svg></mjx-container></span>。</p>
<p>对于象，不难发现 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.316ex" height="2.667ex" role="img" focusable="false" viewBox="0 -1097 2791.6 1179"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(500,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1206.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2262.6,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g></svg></mjx-container></span> 会构成压象眼。</p>
<p>接下来考虑别马脚。注意到，别马脚的子距离起点长度一定为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewBox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>，即 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex;" xmlns="http://www.w3.org/2000/svg" width="6.377ex" height="3.046ex" role="img" focusable="false" viewBox="0 -1097 2818.6 1346.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(278,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(707,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="mo" transform="translate(1262.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2318.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>。此外，我们注意到，这两条向量的夹角永远是不变的，同时模长不变，自然想到利用数量积筛选。做
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.971ex" height="2.507ex" role="img" focusable="false" viewBox="0 -1097 429 1108"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g></svg></mjx-container></span> 在 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.934ex" role="img" focusable="false" viewBox="0 -845 529 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g></svg></mjx-container></span> 上的投影，显然有 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.95ex" height="2.667ex" role="img" focusable="false" viewBox="0 -1097 3514 1179"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(751.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1251.4,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1958.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3014,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container></span>。我们也可以用
GeoGebra 的画图功能来验证这个筛选。 <img src="https://cdn.luogu.com.cn/upload/image_hosting/76liyz5f.png"></p>
<p>红色直线上的点符合数量积要求，蓝色圆上的点符合模长要求，同时由于两个轴上的坐标都是整数，所以点
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.79ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 791 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container></span>
是唯一的——这个点也确实会别到马脚。</p>
<p>对于鸭子，有了处理别马脚的经验，也能很快的想出结论。第一种可能，<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex;" xmlns="http://www.w3.org/2000/svg" width="6.377ex" height="3.046ex" role="img" focusable="false" viewBox="0 -1097 2818.6 1346.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(278,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(707,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="mo" transform="translate(1262.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2318.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span> 且 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.95ex" height="2.667ex" role="img" focusable="false" viewBox="0 -1097 3514 1179"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(751.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1251.4,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1958.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3014,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></svg></mjx-container></span>；第二种可能，<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex;" xmlns="http://www.w3.org/2000/svg" width="8.307ex" height="3.046ex" role="img" focusable="false" viewBox="0 -1097 3671.6 1346.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(278,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(707,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="mo" transform="translate(1262.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msqrt" transform="translate(2318.6,0)"><g transform="translate(853,0)"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"></path></g></g><g data-mml-node="mo" transform="translate(0,89.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"></path></g><rect width="500" height="60" x="853" y="829.5"></rect></g></g></g></svg></mjx-container></span> 且 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.95ex" height="2.667ex" role="img" focusable="false" viewBox="0 -1097 3514 1179"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(751.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1251.4,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1958.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(3014,0)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"></path></g></g></g></svg></mjx-container></span>。</p>
<p>对于车，要求中间没有挡道的棋子。不难想到，如果一个棋子要“挡道”，需要符合以下条件：
- <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.934ex" role="img" focusable="false" viewBox="0 -845 529 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g></svg></mjx-container></span> 和 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.971ex" height="2.507ex" role="img" focusable="false" viewBox="0 -1097 429 1108"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g></svg></mjx-container></span> 共线。 - <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.197ex" height="1.934ex" role="img" focusable="false" viewBox="0 -845 529 855"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g></svg></mjx-container></span> 和 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.971ex" height="2.507ex" role="img" focusable="false" viewBox="0 -1097 429 1108"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g></svg></mjx-container></span> 同向。 - <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.564ex;" xmlns="http://www.w3.org/2000/svg" width="11.849ex" height="3.046ex" role="img" focusable="false" viewBox="0 -1097 5237.1 1346.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="mo" transform="translate(1833.6,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2111.6,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2540.6,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="mo" transform="translate(3096.3,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="mo" transform="translate(4152.1,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(4430.1,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(4959.1,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g></g></g></svg></mjx-container></span>。</p>
<p>使用向量运算描述一下，即为以下条件： <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -4.458ex;" xmlns="http://www.w3.org/2000/svg" width="11.093ex" height="10.048ex" role="img" focusable="false" viewBox="0 -2470.5 4903 4441"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="23A7" d="M712 899L718 893V876V865Q718 854 704 846Q627 793 577 710T510 525Q510 524 509 521Q505 493 504 349Q504 345 504 334Q504 277 504 240Q504 -2 503 -4Q502 -8 494 -9T444 -10Q392 -10 390 -9Q387 -8 386 -5Q384 5 384 230Q384 262 384 312T383 382Q383 481 392 535T434 656Q510 806 664 892L677 899H712Z" transform="translate(0,1571.5)"></path><path data-c="23A9" d="M718 -893L712 -899H677L666 -893Q542 -825 468 -714T385 -476Q384 -466 384 -282Q384 3 385 5L389 9Q392 10 444 10Q486 10 494 9T503 4Q504 2 504 -239V-310V-366Q504 -470 508 -513T530 -609Q546 -657 569 -698T617 -767T661 -812T699 -843T717 -856T718 -876V-893Z" transform="translate(0,-1071.5)"></path><path data-c="23A8" d="M389 1159Q391 1160 455 1160Q496 1160 498 1159Q501 1158 502 1155Q504 1145 504 924Q504 691 503 682Q494 549 425 439T243 259L229 250L243 241Q349 175 421 66T503 -182Q504 -191 504 -424Q504 -600 504 -629T499 -659H498Q496 -660 444 -660T390 -659Q387 -658 386 -655Q384 -645 384 -425V-282Q384 -176 377 -116T342 10Q325 54 301 92T255 155T214 196T183 222T171 232Q170 233 170 250T171 268Q171 269 191 284T240 331T300 407T354 524T383 679Q384 691 384 925Q384 1152 385 1155L389 1159Z" transform="translate(0,0)"></path><svg width="889" height="601.5" y="1060" x="0" viewBox="0 106 889 601.5"><path data-c="23AA" d="M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z" transform="scale(1,2.958)"></path></svg><svg width="889" height="601.5" y="-1161.5" x="0" viewBox="0 106 889 601.5"><path data-c="23AA" d="M384 150V266Q384 304 389 309Q391 310 455 310Q496 310 498 309Q502 308 503 298Q504 283 504 150Q504 32 504 12T499 -9H498Q496 -10 444 -10T390 -9Q386 -8 385 2Q384 17 384 150Z" transform="scale(1,2.958)"></path></svg></g><g data-mml-node="mtable" transform="translate(889,0)"><g data-mml-node="mtr" transform="translate(0,1373.5)"><g data-mml-node="mtd"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(751.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1751.4,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2458.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(3514,0)"><g data-mml-node="mover"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g><g data-mml-node="mo" transform="translate(250,255) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g></g></g><g data-mml-node="mtr" transform="translate(0,-173.5)"><g data-mml-node="mtd"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(751.2,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1251.4,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(1958.2,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"></path></g><g data-mml-node="mn" transform="translate(3014,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g></g><g data-mml-node="mtr" transform="translate(0,-1720.5)"><g data-mml-node="mtd"><g data-mml-node="mo" transform="translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(278,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"></path></g><g data-mml-node="mo" transform="translate(214.5,283) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(707,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="mo" transform="translate(1262.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"></path></g><g data-mml-node="mo" transform="translate(2318.6,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2596.6,0)"><g data-mml-node="mover"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(264.5,31) translate(-250 0)"><path data-c="20D7" d="M377 694Q377 702 382 708T397 714Q404 714 409 709Q414 705 419 690Q429 653 460 633Q471 626 471 615Q471 606 468 603T454 594Q411 572 379 531Q377 529 374 525T369 519T364 517T357 516Q350 516 344 521T337 536Q337 555 384 595H213L42 596Q29 605 29 615Q29 622 42 635H401Q377 673 377 694Z"></path></g></g></g><g data-mml-node="mo" transform="translate(3125.6,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(4903,0) translate(0 250)"></g></g></g></g></svg></mjx-container></span></p>
<p>最后，再检测一下落点是否在棋盘上，以及是否在攻击己方棋子就可以了。</p>
<p>代码如下：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Piece <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// ...</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 检查是否可以到达目标位置，但是只对位置进行判断</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> reachable_pos<span class="op">(</span>Vec2d dest<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"captain"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>sqrDistance<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"guard"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>manhattan<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">2</span> <span class="kw">and</span> pos<span class="op">.</span>chebyshev<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"elephant"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>manhattan<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">4</span> <span class="kw">and</span> pos<span class="op">.</span>chebyshev<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">2</span> <span class="kw">and</span> </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                <span class="kw">not</span> pieces<span class="op">.</span>some<span class="op">(</span>lambda<span class="op">(</span>p<span class="op">,</span> <span class="op">(</span>p<span class="op">.</span>pos<span class="op">-</span>pos<span class="op">)*</span><span class="dv">2</span><span class="op">==(</span>dest<span class="op">-</span>pos<span class="op">)));</span> </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"horse"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>sqrDistance<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">5</span> <span class="kw">and</span> </span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                <span class="kw">not</span> pieces<span class="op">.</span>some<span class="op">(</span>lambda<span class="op">(</span>p<span class="op">,</span> </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                    p<span class="op">.</span>pos<span class="op">.</span>sqrDistance<span class="op">(</span>pos<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> <span class="op">(</span>p<span class="op">.</span>pos<span class="op">-</span>pos<span class="op">)*(</span>dest<span class="op">-</span>pos<span class="op">)==</span><span class="dv">2</span><span class="op">));</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"car"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> a <span class="op">=</span> dest<span class="op">-</span>pos<span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>chebyshev<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> pos<span class="op">.</span>manhattan<span class="op">(</span>dest<span class="op">)</span> <span class="kw">and</span> <span class="kw">not</span> pieces<span class="op">.</span>some<span class="op">([&amp;](</span><span class="kw">auto</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> b <span class="op">=</span> p<span class="op">.</span>pos<span class="op">-</span>pos<span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> b<span class="op">.</span>cross<span class="op">(</span>a<span class="op">)==</span><span class="dv">0</span> <span class="kw">and</span> b<span class="op">.</span>sqrAbs<span class="op">()&lt;</span>a<span class="op">.</span>sqrAbs<span class="op">()</span> <span class="kw">and</span> b<span class="op">*</span>a<span class="op">&gt;</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">});</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"soldier"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>chebyshev<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>  <span class="co">// duck</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> a <span class="op">=</span> dest<span class="op">-</span>pos<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>sqrDistance<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">13</span> <span class="kw">and</span> <span class="kw">not</span> pieces<span class="op">.</span>some<span class="op">([&amp;](</span><span class="kw">auto</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> b <span class="op">=</span> p<span class="op">.</span>pos<span class="op">-</span>pos<span class="op">;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">(</span>a<span class="op">*</span>b<span class="op">==</span><span class="dv">8</span> <span class="kw">and</span> b<span class="op">.</span>sqrAbs<span class="op">()==</span><span class="dv">5</span><span class="op">)</span> <span class="kw">or</span> <span class="op">(</span>a<span class="op">*</span>b<span class="op">==</span><span class="dv">3</span> <span class="kw">and</span> b<span class="op">.</span>sqrAbs<span class="op">()==</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">});</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> reachable<span class="op">(</span>Vec2d dest<span class="op">)</span> <span class="op">{</span>  <span class="co">// 能否到达目标地点</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">&lt;=</span>dest<span class="op">.</span>x <span class="kw">and</span> dest<span class="op">.</span>x<span class="op">&lt;</span>_X <span class="kw">and</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>            <span class="dv">0</span><span class="op">&lt;=</span>dest<span class="op">.</span>y <span class="kw">and</span> dest<span class="op">.</span>y<span class="op">&lt;</span>_Y <span class="kw">and</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>            reachable_pos<span class="op">(</span>dest<span class="op">)</span> <span class="kw">and</span> </span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>            <span class="kw">not</span> pieces<span class="op">.</span>some<span class="op">(</span>lambda<span class="op">(</span>p<span class="op">,</span> p<span class="op">.</span>pos<span class="op">==</span>dest <span class="kw">and</span> p<span class="op">.</span>team<span class="op">==</span>team<span class="op">));</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>这里为了方便，我继承了 <code>std::vector</code>，即代码中的
<code>vector</code>，并添加了 <code>some(func)</code>
方法，用于判断是否存在任意一个元素 <code>i</code>，使得
<code>func(i)</code> 返回真。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> vector<span class="op">:</span> <span class="kw">public</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> Func<span class="op">&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> some<span class="op">(</span><span class="at">const</span> Func<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> i<span class="op">:</span> <span class="op">*</span><span class="kw">this</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>f<span class="op">(</span>i<span class="op">))</span>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>而 <code>lambda</code> 是一个宏，定义如下：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define lambda</span><span class="op">(</span>arg<span class="op">,</span><span class="pp"> </span>expr<span class="op">)</span><span class="pp"> </span><span class="op">[&amp;](</span><span class="kw">auto</span><span class="pp"> </span>arg<span class="op">){</span><span class="cf">return</span><span class="pp"> </span>expr<span class="op">;}</span></span></code></pre></div>
<h3 id="其他流程">其他流程</h3>
<p>这里就不多加阐述了，可以见代码注释</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> solve<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    init<span class="op">();</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 双方的王</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    Piece<span class="op">&amp;</span> kingRed <span class="op">=</span> pieces<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    Piece<span class="op">&amp;</span> kingBlue <span class="op">=</span> pieces<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> round <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> gameOver <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    from<span class="op">(</span>_<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> Q<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>gameOver<span class="op">)</span> <span class="op">{</span>  <span class="co">// 游戏结束一定不合法</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            cout <span class="op">&lt;&lt;</span> <span class="st">"Invalid command</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x1<span class="op">,</span> y1<span class="op">,</span> x2<span class="op">,</span> y2<span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        cin <span class="op">&gt;&gt;</span> x1 <span class="op">&gt;&gt;</span> y1 <span class="op">&gt;&gt;</span> x2 <span class="op">&gt;&gt;</span> y2<span class="op">;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> src <span class="op">=</span> Vec2d<span class="op">{</span>x1<span class="op">,</span> y1<span class="op">};</span>  <span class="co">// 起点</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> dest <span class="op">=</span> Vec2d<span class="op">{</span>x2<span class="op">,</span> y2<span class="op">};</span>  <span class="co">// 终点</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> selected <span class="op">=</span> <span class="bu">std::</span>find_if<span class="op">(</span>pieces<span class="op">.</span>begin<span class="op">(),</span> pieces<span class="op">.</span>end<span class="op">(),</span> </span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>            lambda<span class="op">(</span>p<span class="op">,</span> p<span class="op">.</span>pos<span class="op">==</span>src <span class="kw">and</span> p<span class="op">.</span>team<span class="op">==</span>round<span class="op">));</span>  <span class="co">// 筛选，要求位置一致并且阵营正确</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>selected <span class="op">==</span> pieces<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span>  <span class="co">// 没找到</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>            cout <span class="op">&lt;&lt;</span> <span class="st">"Invalid command</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> available <span class="op">=</span> selected<span class="op">-&gt;</span>reachable<span class="op">(</span>dest<span class="op">);</span>  <span class="co">// 判断终点位置是否可达</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="kw">not</span> available<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>            cout <span class="op">&lt;&lt;</span> <span class="st">"Invalid command</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 主语</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> <span class="op">(</span>selected<span class="op">-&gt;</span>team<span class="op">==</span>Team<span class="op">::</span>Red<span class="op">?</span> <span class="st">"red "</span><span class="op">:</span> <span class="st">"blue "</span><span class="op">)</span> <span class="op">&lt;&lt;</span> selected<span class="op">-&gt;</span>name <span class="op">&lt;&lt;</span> <span class="ch">';'</span><span class="op">;</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 宾语</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> isKingKilled <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// 王被击杀，判断游戏结束</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> attackedIter <span class="op">=</span> <span class="bu">std::</span>find_if<span class="op">(</span>pieces<span class="op">.</span>begin<span class="op">(),</span> pieces<span class="op">.</span>end<span class="op">(),</span> lambda<span class="op">(</span>p<span class="op">,</span> p<span class="op">.</span>pos<span class="op">==</span>dest<span class="op">));</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>        selected<span class="op">-&gt;</span>pos <span class="op">=</span> dest<span class="op">;</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>attackedIter <span class="op">==</span> pieces<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>            cout <span class="op">&lt;&lt;</span> <span class="st">"NA;"</span><span class="op">;</span>  <span class="co">// 移到空格子</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>            isKingKilled <span class="op">=</span> <span class="op">(</span>attackedIter<span class="op">-&gt;</span>name<span class="op">==</span><span class="st">"captain"</span><span class="op">);</span>  <span class="co">// 游戏结束</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 输出宾语</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>            cout <span class="op">&lt;&lt;</span> <span class="op">(</span>attackedIter<span class="op">-&gt;</span>team<span class="op">==</span>Team<span class="op">::</span>Red<span class="op">?</span> <span class="st">"red "</span><span class="op">:</span> <span class="st">"blue "</span><span class="op">)</span> <span class="op">&lt;&lt;</span> attackedIter<span class="op">-&gt;</span>name <span class="op">&lt;&lt;</span> <span class="ch">';'</span><span class="op">;</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>            pieces<span class="op">.</span>erase<span class="op">(</span>attackedIter<span class="op">);</span>  <span class="co">// 移除被吃的子</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> isKingInDanger <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// 被将军</span></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>        isKingInDanger <span class="op">&amp;=</span> <span class="op">!</span>isKingKilled<span class="op">;</span>  <span class="co">// 特判，王已经死了</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>        isKingInDanger <span class="op">|=</span> pieces<span class="op">.</span>some<span class="op">(</span>lambda<span class="op">(</span>p<span class="op">,</span> p<span class="op">.</span>reachable<span class="op">(</span>kingRed<span class="op">.</span>pos<span class="op">)</span> <span class="kw">and</span> p<span class="op">.</span>team<span class="op">==</span>Team<span class="op">::</span>Blue<span class="op">));</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>        isKingInDanger <span class="op">|=</span> pieces<span class="op">.</span>some<span class="op">(</span>lambda<span class="op">(</span>p<span class="op">,</span> p<span class="op">.</span>reachable<span class="op">(</span>kingBlue<span class="op">.</span>pos<span class="op">)</span> <span class="kw">and</span> p<span class="op">.</span>team<span class="op">==</span>Team<span class="op">::</span>Red<span class="op">));</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> <span class="op">(</span>isKingInDanger<span class="op">?</span> <span class="st">"yes;"</span><span class="op">:</span> <span class="st">"no;"</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>isKingKilled<span class="op">?</span> <span class="st">"yes"</span><span class="op">:</span> <span class="st">"no"</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>        gameOver <span class="op">|=</span> isKingKilled<span class="op">;</span> </span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>        round <span class="op">^=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// 当且仅当操作合法，进行轮换</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="初始化">初始化</h3>
<p>初始化主要用于处理棋子的初始位置。</p>
<p>我采用了一些宏定义简化代码。宏定义有时可以减少枯燥乏味的代码，不过也要慎用，避免出现一些很难调的
bug。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> Q<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>ios::sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span> cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span> cout<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 添加一个子</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define add</span><span class="op">(</span>name<span class="op">,</span>px<span class="op">,</span>py<span class="op">,</span>team<span class="op">)</span><span class="pp"> </span>pieces<span class="op">.</span>push_back<span class="op">(</span>Piece<span class="op">{</span>name<span class="op">,</span><span class="pp"> </span><span class="op">{</span>px<span class="op">,</span><span class="pp"> </span>py<span class="op">},</span><span class="pp"> </span>Team<span class="op">::</span>team<span class="op">});</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 添加四个中心对称的子</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define four</span><span class="op">(</span>name<span class="op">,</span>dx<span class="op">,</span>dy<span class="op">)</span><span class="pp"> </span>add<span class="op">(</span>name<span class="op">,</span><span class="dv">4</span><span class="op">-</span>dx<span class="op">,</span><span class="dv">4</span><span class="op">+</span>dy<span class="op">,</span>Red<span class="op">)</span><span class="pp"> </span>add<span class="op">(</span>name<span class="op">,</span><span class="dv">4</span><span class="op">-</span>dx<span class="op">,</span><span class="dv">4</span><span class="op">-</span>dy<span class="op">,</span>Red<span class="op">)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="pp">        </span>add<span class="op">(</span>name<span class="op">,</span><span class="dv">5</span><span class="op">+</span>dx<span class="op">,</span><span class="dv">4</span><span class="op">-</span>dy<span class="op">,</span>Blue<span class="op">)</span><span class="pp"> </span>add<span class="op">(</span>name<span class="op">,</span><span class="dv">5</span><span class="op">+</span>dx<span class="op">,</span><span class="dv">4</span><span class="op">+</span>dy<span class="op">,</span>Blue<span class="op">)</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 添加底线上的一个子</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define bottom</span><span class="op">(</span>name<span class="op">,</span>dy<span class="op">)</span><span class="pp"> </span>four<span class="op">(</span>name<span class="op">,</span><span class="dv">4</span><span class="op">,</span>dy<span class="op">);</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    add<span class="op">(</span><span class="st">"captain"</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span>Red<span class="op">)</span> add<span class="op">(</span><span class="st">"captain"</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span>Blue<span class="op">)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    bottom<span class="op">(</span><span class="st">"car"</span><span class="op">,</span><span class="dv">4</span><span class="op">)</span>bottom<span class="op">(</span><span class="st">"horse"</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span>bottom<span class="op">(</span><span class="st">"elephant"</span><span class="op">,</span><span class="dv">2</span><span class="op">)</span>bottom<span class="op">(</span><span class="st">"guard"</span><span class="op">,</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    four<span class="op">(</span><span class="st">"duck"</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">4</span><span class="op">)</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    four<span class="op">(</span><span class="st">"soldier"</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">4</span><span class="op">)</span>four<span class="op">(</span><span class="st">"soldier"</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">)</span>add<span class="op">(</span><span class="st">"soldier"</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span>Red<span class="op">)</span>add<span class="op">(</span><span class="st">"soldier"</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span>Blue<span class="op">)</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> Q<span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>那么这个代码就完成了。</p>
<h3 id="警示后人">警示后人</h3>
<p>在写这个代码时，我被一个引用造成的 bug 卡了四个小时，原因是我在引用了
<code>vector</code>
上的一个元素之后，删除了另一个元素，导致内存上这个位置发生了变化，于是这个引用指向了其他元素。引用其实也是指向一个内存上的地址，和指针一样，所以不要掉以轻心，尤其是对可变容器中一个对象的引用，更要万分小心。（例如，<code>vector.push_back</code>
看上去人畜无害，但是如果触发了扩容，这个 <code>vector</code>
上的所有引用都会失效）</p>
<h2 id="总结">总结</h2>
<p>本文中，我们采用了一些数学方法转换和简化了检查棋子的过程，感觉思路比较新颖，希望管理能够通过。</p>
<p>模拟题最重要的是对于题意的理解和保持思路的清晰。不过，这么长的代码，如果出现
bug，调起来还是很头疼的，所以还是要细心一些，并且记录一些平时遇到的
bug，在以后的代码中也多注意这些问题。</p>
<p>在文化课中学习向量时，我有时想，“这么抽象的东西到底有什么用”，直到编写这份代码的时候，我鬼使神差地给两个位置做了减法——这就是向量。于是，那些尘封在课本中的知识涌入脑海，前文的那些步骤也很自然了。把这些冗长的规则，都转变成了一个个简短的式子，也许这就是数学的魅力吧。</p>
<p>不知不觉也写了不少了，感谢您的观看。</p>
<h2 id="完整代码">完整代码</h2>
<div class="sourceCode" id="cb9"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@link</span><span class="co"> </span><span class="cv">https://www.luogu.com.cn/problem/P5380</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define from</span><span class="op">(</span>i<span class="op">,</span>b<span class="op">,</span>e<span class="op">)</span><span class="pp"> </span><span class="cf">for</span><span class="op">(</span><span class="dt">int</span><span class="pp"> </span>i<span class="op">=(</span>b<span class="op">);</span>i<span class="op">&lt;=(</span>e<span class="op">);</span>i<span class="op">++)</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#define lambda</span><span class="op">(</span>arg<span class="op">,</span><span class="pp"> </span>expr<span class="op">)</span><span class="pp"> </span><span class="op">[&amp;](</span><span class="kw">auto</span><span class="pp"> </span>arg<span class="op">){</span><span class="cf">return</span><span class="pp"> </span>expr<span class="op">;}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="bu">std::</span>cin<span class="op">,</span> <span class="bu">std::</span>cout<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> vector<span class="op">:</span> <span class="kw">public</span> <span class="bu">std::</span>vector<span class="op">&lt;</span>T<span class="op">&gt;</span> <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> Func<span class="op">&gt;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> some<span class="op">(</span><span class="at">const</span> Func<span class="op">&amp;&amp;</span> f<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> i<span class="op">:</span> <span class="op">*</span><span class="kw">this</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>f<span class="op">(</span>i<span class="op">))</span>  <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> _X <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> _Y <span class="op">=</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Vec2d <span class="op">{</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    Vec2d <span class="kw">operator</span><span class="op">+(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span>x<span class="op">+</span>other<span class="op">.</span>x<span class="op">,</span> y<span class="op">+</span>other<span class="op">.</span>y<span class="op">};</span> <span class="op">}</span> <span class="co">// 加</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    Vec2d <span class="kw">operator</span><span class="op">-(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span>x<span class="op">-</span>other<span class="op">.</span>x<span class="op">,</span> y<span class="op">-</span>other<span class="op">.</span>y<span class="op">};</span> <span class="op">}</span> <span class="co">// 减</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    Vec2d <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> <span class="dt">int</span> other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span>x<span class="op">*</span>other<span class="op">,</span> y<span class="op">*</span>other<span class="op">};</span> <span class="op">}</span> <span class="co">// 数乘</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    Vec2d <span class="kw">operator</span><span class="op">/(</span><span class="at">const</span> <span class="dt">int</span> other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">{</span>x<span class="op">/</span>other<span class="op">,</span> y<span class="op">/</span>other<span class="op">};</span> <span class="op">}</span> <span class="co">// 乘以 1/other</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="kw">operator</span><span class="op">*(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">*</span>other<span class="op">.</span>x <span class="op">+</span> y<span class="op">*</span>other<span class="op">.</span>y<span class="op">;</span> <span class="op">}</span> <span class="co">// 数量积</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cross<span class="op">(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">*</span>other<span class="op">.</span>y <span class="op">-</span> y<span class="op">*</span>other<span class="op">.</span>x<span class="op">;</span> <span class="op">}</span> <span class="co">// 叉乘的模长</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">==(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">==</span>other<span class="op">.</span>x <span class="kw">and</span> y<span class="op">==</span>other<span class="op">.</span>y<span class="op">;</span> <span class="op">}</span> <span class="co">// 相等</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> <span class="kw">operator</span><span class="op">!=(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">!=</span>other<span class="op">.</span>x <span class="kw">or</span> y<span class="op">!=</span>other<span class="op">.</span>y<span class="op">;</span> <span class="op">}</span> <span class="co">// 不等</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sqrDistance<span class="op">(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="co">// 两点间欧几里得距离的平方</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>x<span class="op">-</span>other<span class="op">.</span>x<span class="op">)*(</span>x<span class="op">-</span>other<span class="op">.</span>x<span class="op">)+(</span>y<span class="op">-</span>other<span class="op">.</span>y<span class="op">)*(</span>y<span class="op">-</span>other<span class="op">.</span>y<span class="op">);</span> </span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> manhattan<span class="op">(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> abs<span class="op">(</span>x<span class="op">-</span>other<span class="op">.</span>x<span class="op">)+</span>abs<span class="op">(</span>y<span class="op">-</span>other<span class="op">.</span>y<span class="op">);</span> <span class="op">}</span> <span class="co">// 曼哈顿距离</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> chebyshev<span class="op">(</span><span class="at">const</span> Vec2d <span class="op">&amp;</span>other<span class="op">)</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> <span class="bu">std::</span>max<span class="op">(</span>abs<span class="op">(</span>x<span class="op">-</span>other<span class="op">.</span>x<span class="op">),</span> abs<span class="op">(</span>y<span class="op">-</span>other<span class="op">.</span>y<span class="op">));</span> <span class="op">}</span> <span class="co">// 切比雪夫距离</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sqrAbs<span class="op">()</span> <span class="at">const</span> <span class="op">{</span> <span class="cf">return</span> x<span class="op">*</span>x<span class="op">+</span>y<span class="op">*</span>y<span class="op">;</span> <span class="op">}</span> <span class="co">// 模长的平方</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> Team <span class="op">{</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>    Red<span class="op">,</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    Blue<span class="op">,</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Piece<span class="op">;</span>  <span class="co">// 预先声明，解决循环引用问题</span></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span>Piece<span class="op">&gt;</span> pieces<span class="op">;</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Piece <span class="op">{</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>    string  name<span class="op">;</span>   <span class="co">// 棋子类型，如 horse, elephant</span></span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a>    Vec2d   pos<span class="op">;</span>    <span class="co">// 棋子位置</span></span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a>    Team    team<span class="op">;</span>   <span class="co">// 棋子阵营</span></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>    <span class="co">// 检查是否可以到达目标位置，但是只对位置进行判断</span></span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> reachable_pos<span class="op">(</span>Vec2d dest<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"captain"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>sqrDistance<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"guard"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>manhattan<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">2</span> <span class="kw">and</span> pos<span class="op">.</span>chebyshev<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"elephant"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>manhattan<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">4</span> <span class="kw">and</span> pos<span class="op">.</span>chebyshev<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">2</span> <span class="kw">and</span> </span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a>                <span class="kw">not</span> pieces<span class="op">.</span>some<span class="op">(</span>lambda<span class="op">(</span>p<span class="op">,</span> <span class="op">(</span>p<span class="op">.</span>pos<span class="op">-</span>pos<span class="op">)*</span><span class="dv">2</span><span class="op">==(</span>dest<span class="op">-</span>pos<span class="op">)));</span> </span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"horse"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>sqrDistance<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">5</span> <span class="kw">and</span> </span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a>                <span class="kw">not</span> pieces<span class="op">.</span>some<span class="op">(</span>lambda<span class="op">(</span>p<span class="op">,</span> </span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a>                    p<span class="op">.</span>pos<span class="op">.</span>sqrDistance<span class="op">(</span>pos<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span> <span class="kw">and</span> <span class="op">(</span>p<span class="op">.</span>pos<span class="op">-</span>pos<span class="op">)*(</span>dest<span class="op">-</span>pos<span class="op">)==</span><span class="dv">2</span><span class="op">));</span></span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"car"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> a <span class="op">=</span> dest<span class="op">-</span>pos<span class="op">;</span></span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>chebyshev<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> pos<span class="op">.</span>manhattan<span class="op">(</span>dest<span class="op">)</span> <span class="kw">and</span> <span class="kw">not</span> pieces<span class="op">.</span>some<span class="op">([&amp;](</span><span class="kw">auto</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> b <span class="op">=</span> p<span class="op">.</span>pos<span class="op">-</span>pos<span class="op">;</span></span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> b<span class="op">.</span>cross<span class="op">(</span>a<span class="op">)==</span><span class="dv">0</span> <span class="kw">and</span> b<span class="op">.</span>sqrAbs<span class="op">()&lt;</span>a<span class="op">.</span>sqrAbs<span class="op">()</span> <span class="kw">and</span> b<span class="op">*</span>a<span class="op">&gt;</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a>            <span class="op">});</span></span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>name <span class="op">==</span> <span class="st">"soldier"</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>chebyshev<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>  <span class="co">// duck</span></span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> a <span class="op">=</span> dest<span class="op">-</span>pos<span class="op">;</span></span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> pos<span class="op">.</span>sqrDistance<span class="op">(</span>dest<span class="op">)</span> <span class="op">==</span> <span class="dv">13</span> <span class="kw">and</span> <span class="kw">not</span> pieces<span class="op">.</span>some<span class="op">([&amp;](</span><span class="kw">auto</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a>                <span class="kw">auto</span> b <span class="op">=</span> p<span class="op">.</span>pos<span class="op">-</span>pos<span class="op">;</span></span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="op">(</span>a<span class="op">*</span>b<span class="op">==</span><span class="dv">8</span> <span class="kw">and</span> b<span class="op">.</span>sqrAbs<span class="op">()==</span><span class="dv">5</span><span class="op">)</span> <span class="kw">or</span> <span class="op">(</span>a<span class="op">*</span>b<span class="op">==</span><span class="dv">3</span> <span class="kw">and</span> b<span class="op">.</span>sqrAbs<span class="op">()==</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a>            <span class="op">});</span></span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> reachable<span class="op">(</span>Vec2d dest<span class="op">)</span> <span class="op">{</span>  <span class="co">// 能否到达目标地点</span></span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">&lt;=</span>dest<span class="op">.</span>x <span class="kw">and</span> dest<span class="op">.</span>x<span class="op">&lt;</span>_X <span class="kw">and</span></span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span><span class="op">&lt;=</span>dest<span class="op">.</span>y <span class="kw">and</span> dest<span class="op">.</span>y<span class="op">&lt;</span>_Y <span class="kw">and</span></span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a>        reachable_pos<span class="op">(</span>dest<span class="op">)</span> <span class="kw">and</span> </span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a>        <span class="kw">not</span> pieces<span class="op">.</span>some<span class="op">(</span>lambda<span class="op">(</span>p<span class="op">,</span> p<span class="op">.</span>pos<span class="op">==</span>dest <span class="kw">and</span> p<span class="op">.</span>team<span class="op">==</span>team<span class="op">));</span></span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-95"><a href="#cb9-95" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Solution <span class="op">{</span></span>
<span id="cb9-96"><a href="#cb9-96" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> Q<span class="op">;</span></span>
<span id="cb9-97"><a href="#cb9-97" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-98"><a href="#cb9-98" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>ios::sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span> cin<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span> cout<span class="op">.</span>tie<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb9-99"><a href="#cb9-99" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 添加一个子</span></span>
<span id="cb9-100"><a href="#cb9-100" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#define add</span><span class="op">(</span>name<span class="op">,</span>px<span class="op">,</span>py<span class="op">,</span>team<span class="op">)</span><span class="pp"> </span>pieces<span class="op">.</span>push_back<span class="op">(</span>Piece<span class="op">{</span>name<span class="op">,</span><span class="pp"> </span><span class="op">{</span>px<span class="op">,</span><span class="pp"> </span>py<span class="op">},</span><span class="pp"> </span>Team<span class="op">::</span>team<span class="op">});</span></span>
<span id="cb9-101"><a href="#cb9-101" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 添加四个中心对称的子</span></span>
<span id="cb9-102"><a href="#cb9-102" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#define four</span><span class="op">(</span>name<span class="op">,</span>dx<span class="op">,</span>dy<span class="op">)</span><span class="pp"> </span>add<span class="op">(</span>name<span class="op">,</span><span class="dv">4</span><span class="op">-</span>dx<span class="op">,</span><span class="dv">4</span><span class="op">+</span>dy<span class="op">,</span>Red<span class="op">)</span><span class="pp"> </span>add<span class="op">(</span>name<span class="op">,</span><span class="dv">4</span><span class="op">-</span>dx<span class="op">,</span><span class="dv">4</span><span class="op">-</span>dy<span class="op">,</span>Red<span class="op">)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb9-103"><a href="#cb9-103" aria-hidden="true" tabindex="-1"></a><span class="pp">            </span>add<span class="op">(</span>name<span class="op">,</span><span class="dv">5</span><span class="op">+</span>dx<span class="op">,</span><span class="dv">4</span><span class="op">-</span>dy<span class="op">,</span>Blue<span class="op">)</span><span class="pp"> </span>add<span class="op">(</span>name<span class="op">,</span><span class="dv">5</span><span class="op">+</span>dx<span class="op">,</span><span class="dv">4</span><span class="op">+</span>dy<span class="op">,</span>Blue<span class="op">)</span></span>
<span id="cb9-104"><a href="#cb9-104" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 添加底线上的一个子</span></span>
<span id="cb9-105"><a href="#cb9-105" aria-hidden="true" tabindex="-1"></a>        <span class="pp">#define bottom</span><span class="op">(</span>name<span class="op">,</span>dy<span class="op">)</span><span class="pp"> </span>four<span class="op">(</span>name<span class="op">,</span><span class="dv">4</span><span class="op">,</span>dy<span class="op">);</span></span>
<span id="cb9-106"><a href="#cb9-106" aria-hidden="true" tabindex="-1"></a>        add<span class="op">(</span><span class="st">"captain"</span><span class="op">,</span><span class="dv">0</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span>Red<span class="op">)</span> add<span class="op">(</span><span class="st">"captain"</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span>Blue<span class="op">)</span></span>
<span id="cb9-107"><a href="#cb9-107" aria-hidden="true" tabindex="-1"></a>        bottom<span class="op">(</span><span class="st">"car"</span><span class="op">,</span><span class="dv">4</span><span class="op">)</span>bottom<span class="op">(</span><span class="st">"horse"</span><span class="op">,</span><span class="dv">3</span><span class="op">)</span>bottom<span class="op">(</span><span class="st">"elephant"</span><span class="op">,</span><span class="dv">2</span><span class="op">)</span>bottom<span class="op">(</span><span class="st">"guard"</span><span class="op">,</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb9-108"><a href="#cb9-108" aria-hidden="true" tabindex="-1"></a>        four<span class="op">(</span><span class="st">"duck"</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">4</span><span class="op">)</span></span>
<span id="cb9-109"><a href="#cb9-109" aria-hidden="true" tabindex="-1"></a>        four<span class="op">(</span><span class="st">"soldier"</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">4</span><span class="op">)</span>four<span class="op">(</span><span class="st">"soldier"</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">)</span>add<span class="op">(</span><span class="st">"soldier"</span><span class="op">,</span><span class="dv">3</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span>Red<span class="op">)</span>add<span class="op">(</span><span class="st">"soldier"</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">4</span><span class="op">,</span>Blue<span class="op">)</span></span>
<span id="cb9-110"><a href="#cb9-110" aria-hidden="true" tabindex="-1"></a>        cin <span class="op">&gt;&gt;</span> Q<span class="op">;</span></span>
<span id="cb9-111"><a href="#cb9-111" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-112"><a href="#cb9-112" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-113"><a href="#cb9-113" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> solve<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-114"><a href="#cb9-114" aria-hidden="true" tabindex="-1"></a>        init<span class="op">();</span></span>
<span id="cb9-115"><a href="#cb9-115" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 双方的王</span></span>
<span id="cb9-116"><a href="#cb9-116" aria-hidden="true" tabindex="-1"></a>        Piece<span class="op">&amp;</span> kingRed <span class="op">=</span> pieces<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb9-117"><a href="#cb9-117" aria-hidden="true" tabindex="-1"></a>        Piece<span class="op">&amp;</span> kingBlue <span class="op">=</span> pieces<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-118"><a href="#cb9-118" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-119"><a href="#cb9-119" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> round <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-120"><a href="#cb9-120" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> gameOver <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb9-121"><a href="#cb9-121" aria-hidden="true" tabindex="-1"></a>        from<span class="op">(</span>_<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> Q<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-122"><a href="#cb9-122" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>gameOver<span class="op">)</span> <span class="op">{</span>  <span class="co">// 游戏结束一定不合法</span></span>
<span id="cb9-123"><a href="#cb9-123" aria-hidden="true" tabindex="-1"></a>                cout <span class="op">&lt;&lt;</span> <span class="st">"Invalid command</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb9-124"><a href="#cb9-124" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb9-125"><a href="#cb9-125" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-126"><a href="#cb9-126" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> x1<span class="op">,</span> y1<span class="op">,</span> x2<span class="op">,</span> y2<span class="op">;</span></span>
<span id="cb9-127"><a href="#cb9-127" aria-hidden="true" tabindex="-1"></a>            cin <span class="op">&gt;&gt;</span> x1 <span class="op">&gt;&gt;</span> y1 <span class="op">&gt;&gt;</span> x2 <span class="op">&gt;&gt;</span> y2<span class="op">;</span></span>
<span id="cb9-128"><a href="#cb9-128" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> src <span class="op">=</span> Vec2d<span class="op">{</span>x1<span class="op">,</span> y1<span class="op">};</span>  <span class="co">// 起点</span></span>
<span id="cb9-129"><a href="#cb9-129" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> dest <span class="op">=</span> Vec2d<span class="op">{</span>x2<span class="op">,</span> y2<span class="op">};</span>  <span class="co">// 终点</span></span>
<span id="cb9-130"><a href="#cb9-130" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-131"><a href="#cb9-131" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> selected <span class="op">=</span> <span class="bu">std::</span>find_if<span class="op">(</span>pieces<span class="op">.</span>begin<span class="op">(),</span> pieces<span class="op">.</span>end<span class="op">(),</span> </span>
<span id="cb9-132"><a href="#cb9-132" aria-hidden="true" tabindex="-1"></a>                lambda<span class="op">(</span>p<span class="op">,</span> p<span class="op">.</span>pos<span class="op">==</span>src <span class="kw">and</span> p<span class="op">.</span>team<span class="op">==</span>round<span class="op">));</span>  <span class="co">// 筛选，要求位置一致并且阵营正确</span></span>
<span id="cb9-133"><a href="#cb9-133" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>selected <span class="op">==</span> pieces<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span>  <span class="co">// 没找到</span></span>
<span id="cb9-134"><a href="#cb9-134" aria-hidden="true" tabindex="-1"></a>                cout <span class="op">&lt;&lt;</span> <span class="st">"Invalid command</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span></span>
<span id="cb9-135"><a href="#cb9-135" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb9-136"><a href="#cb9-136" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-137"><a href="#cb9-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-138"><a href="#cb9-138" aria-hidden="true" tabindex="-1"></a>            <span class="dt">bool</span> available <span class="op">=</span> selected<span class="op">-&gt;</span>reachable<span class="op">(</span>dest<span class="op">);</span>  <span class="co">// 判断终点位置是否可达</span></span>
<span id="cb9-139"><a href="#cb9-139" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="kw">not</span> available<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-140"><a href="#cb9-140" aria-hidden="true" tabindex="-1"></a>                cout <span class="op">&lt;&lt;</span> <span class="st">"Invalid command</span><span class="sc">\n</span><span class="st">"</span><span class="op">;</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb9-141"><a href="#cb9-141" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-142"><a href="#cb9-142" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 主语</span></span>
<span id="cb9-143"><a href="#cb9-143" aria-hidden="true" tabindex="-1"></a>            cout <span class="op">&lt;&lt;</span> <span class="op">(</span>selected<span class="op">-&gt;</span>team<span class="op">==</span>Team<span class="op">::</span>Red<span class="op">?</span> <span class="st">"red "</span><span class="op">:</span> <span class="st">"blue "</span><span class="op">)</span> <span class="op">&lt;&lt;</span> selected<span class="op">-&gt;</span>name <span class="op">&lt;&lt;</span> <span class="ch">';'</span><span class="op">;</span></span>
<span id="cb9-144"><a href="#cb9-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-145"><a href="#cb9-145" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 宾语</span></span>
<span id="cb9-146"><a href="#cb9-146" aria-hidden="true" tabindex="-1"></a>            <span class="dt">bool</span> isKingKilled <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// 王被击杀，判断游戏结束</span></span>
<span id="cb9-147"><a href="#cb9-147" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> attackedIter <span class="op">=</span> <span class="bu">std::</span>find_if<span class="op">(</span>pieces<span class="op">.</span>begin<span class="op">(),</span> pieces<span class="op">.</span>end<span class="op">(),</span> lambda<span class="op">(</span>p<span class="op">,</span> p<span class="op">.</span>pos<span class="op">==</span>dest<span class="op">));</span></span>
<span id="cb9-148"><a href="#cb9-148" aria-hidden="true" tabindex="-1"></a>            selected<span class="op">-&gt;</span>pos <span class="op">=</span> dest<span class="op">;</span></span>
<span id="cb9-149"><a href="#cb9-149" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>attackedIter <span class="op">==</span> pieces<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb9-150"><a href="#cb9-150" aria-hidden="true" tabindex="-1"></a>                cout <span class="op">&lt;&lt;</span> <span class="st">"NA;"</span><span class="op">;</span>  <span class="co">// 移到空格子</span></span>
<span id="cb9-151"><a href="#cb9-151" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-152"><a href="#cb9-152" aria-hidden="true" tabindex="-1"></a>                isKingKilled <span class="op">=</span> <span class="op">(</span>attackedIter<span class="op">-&gt;</span>name<span class="op">==</span><span class="st">"captain"</span><span class="op">);</span>  <span class="co">// 游戏结束</span></span>
<span id="cb9-153"><a href="#cb9-153" aria-hidden="true" tabindex="-1"></a>                <span class="co">// 输出宾语</span></span>
<span id="cb9-154"><a href="#cb9-154" aria-hidden="true" tabindex="-1"></a>                cout <span class="op">&lt;&lt;</span> <span class="op">(</span>attackedIter<span class="op">-&gt;</span>team<span class="op">==</span>Team<span class="op">::</span>Red<span class="op">?</span> <span class="st">"red "</span><span class="op">:</span> <span class="st">"blue "</span><span class="op">)</span> <span class="op">&lt;&lt;</span> attackedIter<span class="op">-&gt;</span>name <span class="op">&lt;&lt;</span> <span class="ch">';'</span><span class="op">;</span></span>
<span id="cb9-155"><a href="#cb9-155" aria-hidden="true" tabindex="-1"></a>                pieces<span class="op">.</span>erase<span class="op">(</span>attackedIter<span class="op">);</span>  <span class="co">// 移除被吃的子</span></span>
<span id="cb9-156"><a href="#cb9-156" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-157"><a href="#cb9-157" aria-hidden="true" tabindex="-1"></a>            <span class="dt">bool</span> isKingInDanger <span class="op">=</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// 被将军</span></span>
<span id="cb9-158"><a href="#cb9-158" aria-hidden="true" tabindex="-1"></a>            isKingInDanger <span class="op">&amp;=</span> <span class="op">!</span>isKingKilled<span class="op">;</span>  <span class="co">// 特判，王已经死了</span></span>
<span id="cb9-159"><a href="#cb9-159" aria-hidden="true" tabindex="-1"></a>            isKingInDanger <span class="op">|=</span> pieces<span class="op">.</span>some<span class="op">(</span>lambda<span class="op">(</span>p<span class="op">,</span> p<span class="op">.</span>reachable<span class="op">(</span>kingRed<span class="op">.</span>pos<span class="op">)</span> <span class="kw">and</span> p<span class="op">.</span>team<span class="op">==</span>Team<span class="op">::</span>Blue<span class="op">));</span></span>
<span id="cb9-160"><a href="#cb9-160" aria-hidden="true" tabindex="-1"></a>            isKingInDanger <span class="op">|=</span> pieces<span class="op">.</span>some<span class="op">(</span>lambda<span class="op">(</span>p<span class="op">,</span> p<span class="op">.</span>reachable<span class="op">(</span>kingBlue<span class="op">.</span>pos<span class="op">)</span> <span class="kw">and</span> p<span class="op">.</span>team<span class="op">==</span>Team<span class="op">::</span>Red<span class="op">));</span></span>
<span id="cb9-161"><a href="#cb9-161" aria-hidden="true" tabindex="-1"></a>            cout <span class="op">&lt;&lt;</span> <span class="op">(</span>isKingInDanger<span class="op">?</span> <span class="st">"yes;"</span><span class="op">:</span> <span class="st">"no;"</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="op">(</span>isKingKilled<span class="op">?</span> <span class="st">"yes"</span><span class="op">:</span> <span class="st">"no"</span><span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="ch">'</span><span class="sc">\n</span><span class="ch">'</span><span class="op">;</span></span>
<span id="cb9-162"><a href="#cb9-162" aria-hidden="true" tabindex="-1"></a>            gameOver <span class="op">|=</span> isKingKilled<span class="op">;</span> </span>
<span id="cb9-163"><a href="#cb9-163" aria-hidden="true" tabindex="-1"></a>            round <span class="op">^=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// 当且仅当操作合法，进行轮换</span></span>
<span id="cb9-164"><a href="#cb9-164" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-165"><a href="#cb9-165" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-166"><a href="#cb9-166" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-167"><a href="#cb9-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-168"><a href="#cb9-168" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-169"><a href="#cb9-169" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-170"><a href="#cb9-170" aria-hidden="true" tabindex="-1"></a>    Solution<span class="op">::</span>solve<span class="op">();</span></span>
<span id="cb9-171"><a href="#cb9-171" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-172"><a href="#cb9-172" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/blogs/Solution/2024/10/e82fba70d93a/" class="go-post">阅读全文</a>
</div>

<div class="post">
    <a href="/blogs/Solution/2024/10/0fbcfeb56d0b/">
        <h2 class="post-title">P11206 「Cfz Round 9」Dove 题解</h2>
    </a>
    <div class="category-and-date">
        
        <span class="category">
            <a href="/blogs/categories/Solution/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                Solution
            </a>
        </span>
        
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/10/21
        </span>
        
        
    </div>
    <div class="description">
        <div class="content" v-pre>
            
            <h2 id="题意简述">题意简述</h2>
<p>给定一棵树，希望给其上的所有点编号，使得所有边的两端端点编号之和均不超过
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.906ex" height="1.731ex" role="img" focusable="false" viewBox="0 -683 2610.4 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1110.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2110.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>。</p>
<h2 id="分析">分析</h2>
<p>可以使用如下的贪心策略进行编号：</p>
<ul>
<li>按照从深到浅的顺序排序所有点。</li>
<li>按照顺序，将一个点编上尽可能大的号码，同时，如果它的父节点没有被编号，则将其父节点编上尽可能小的号码。</li>
</ul>
<p>接下来，我们对这个策略的正确性进行一个简要的证明。</p>
<p>使用数学归纳法。我们称在一个拥有 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.009ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 888 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g></svg></mjx-container></span> 个节点的子树上，使用 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.522ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2440.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"></path></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(959,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1403.7,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(2162.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"></path></g></g></g></g></svg></mjx-container></span>
区间中的整数进行编号为一次操作 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.894ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4815 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="46" d="M128 619Q121 626 117 628T101 631T58 634H25V680H582V676Q584 670 596 560T610 444V440H570V444Q563 493 561 501Q555 538 543 563T516 601T477 622T431 631T374 633H334H286Q252 633 244 631T233 621Q232 619 232 490V363H284Q287 363 303 363T327 364T349 367T372 373T389 385Q407 403 410 459V480H450V200H410V221Q407 276 389 296Q381 303 371 307T348 313T327 316T303 317T284 317H232V189L233 61Q240 54 245 52T270 48T333 46H360V0H348Q324 3 182 3Q51 3 36 0H25V46H58Q100 47 109 49T128 61V619Z"></path></g><g data-mml-node="mrow" transform="translate(819.7,0)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1277,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1721.7,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(2402.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2847.3,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(3606.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></span>。这个操作的结果合法，当且仅当所有边两端端点的编号之和不超过
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.024ex" height="1.731ex" role="img" focusable="false" viewBox="0 -683 2662.4 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(903.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1903.4,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g></g></svg></mjx-container></span>。为了方便，我们称这个编号之和为这个边的“值”，并记点
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.74ex" height="1.595ex" role="img" focusable="false" viewBox="0 -683 769 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g></g></g></svg></mjx-container></span> 的编号为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="3.375ex" height="1.945ex" role="img" focusable="false" viewBox="0 -694 1491.8 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="msub" transform="translate(345,0)"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(553,-150) scale(0.707)"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"></path></g></g></g></g></svg></mjx-container></span>。接下来我们证明这个操作的结果合法。</p>
<p>对于 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.157ex" height="1.731ex" role="img" focusable="false" viewBox="0 -683 2721.6 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2221.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span> 和 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.157ex" height="1.731ex" role="img" focusable="false" viewBox="0 -683 2721.6 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mn" transform="translate(2221.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></svg></mjx-container></span> 的情况，这种操作的结果必然合法。</p>
<p>假设 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.205ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2742.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2221.6,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g></g></svg></mjx-container></span> 和 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.102ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 4465 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2221.6,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(2964.8,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3965,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span> 时，<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.063ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4448 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="46" d="M128 619Q121 626 117 628T101 631T58 634H25V680H582V676Q584 670 596 560T610 444V440H570V444Q563 493 561 501Q555 538 543 563T516 601T477 622T431 631T374 633H334H286Q252 633 244 631T233 621Q232 619 232 490V363H284Q287 363 303 363T327 364T349 367T372 373T389 385Q407 403 410 459V480H450V200H410V221Q407 276 389 296Q381 303 371 307T348 313T327 316T303 317T284 317H232V189L233 61Q240 54 245 52T270 48T333 46H360V0H348Q324 3 182 3Q51 3 36 0H25V46H58Q100 47 109 49T128 61V619Z"></path></g><g data-mml-node="mrow" transform="translate(819.7,0)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(910,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1354.7,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(2035.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2480.3,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(3239.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></span>
的结果合法，不妨再令 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.102ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 4465 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(2221.6,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(2964.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(3965,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>。在此时进行操作 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="13.96ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6170.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="46" d="M128 619Q121 626 117 628T101 631T58 634H25V680H582V676Q584 670 596 560T610 444V440H570V444Q563 493 561 501Q555 538 543 563T516 601T477 622T431 631T374 633H334H286Q252 633 244 631T233 621Q232 619 232 490V363H284Q287 363 303 363T327 364T349 367T372 373T389 385Q407 403 410 459V480H450V200H410V221Q407 276 389 296Q381 303 371 307T348 313T327 316T303 317T284 317H232V189L233 61Q240 54 245 52T270 48T333 46H360V0H348Q324 3 182 3Q51 3 36 0H25V46H58Q100 47 109 49T128 61V619Z"></path></g><g data-mml-node="mrow" transform="translate(819.7,0)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(1132.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(2132.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2632.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3077.1,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(3758.1,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(4202.8,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(4961.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></span></p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/aukq73hf.png" alt="AQPCDBE">
<figcaption aria-hidden="true">AQPCDBE</figcaption>
</figure>
<p>我们设要编号为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.048ex;" xmlns="http://www.w3.org/2000/svg" width="1.717ex" height="1.593ex" role="img" focusable="false" viewBox="0 -683 759 704"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g></g></svg></mjx-container></span> 的点为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.699ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 751 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g></g></g></svg></mjx-container></span>，它的父节点为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.79ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 791 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container></span>。不妨考虑将 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="4.495ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 1986.7 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(751,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1195.7,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container></span>
两点去掉，此时原图会分裂成若干个子树（对于上图，三个子树为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.719ex" height="1.645ex" role="img" focusable="false" viewBox="0 -705 760 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g></g></g></svg></mjx-container></span>, <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.873ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 828 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g></g></g></svg></mjx-container></span>
和 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="5.143ex" height="1.62ex" role="img" focusable="false" viewBox="0 -716 2273 716"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g><g data-mml-node="mi" transform="translate(1509,0)"><path data-c="1D438" d="M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z"></path></g></g></g></svg></mjx-container></span>）。将这三个子树以任意方式连接，则是一个包含
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.076ex" height="1.756ex" role="img" focusable="false" viewBox="0 -694 2243.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(743.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(1743.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span> 节点的树。</p>
<figure>
<img src="https://cdn.luogu.com.cn/upload/image_hosting/ar1k1zyd.png" alt="ACDBE">
<figcaption aria-hidden="true">ACDBE</figcaption>
</figure>
<p>如图，我们把 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="4.495ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 1986.7 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(751,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1195.7,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container></span>
去掉，并分别编上号码 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.048ex;" xmlns="http://www.w3.org/2000/svg" width="1.717ex" height="1.593ex" role="img" focusable="false" viewBox="0 -683 759 704"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g></g></svg></mjx-container></span> 和 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.541ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 681 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g></g></g></svg></mjx-container></span>，然后添上两条新的边（<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="7.992ex" height="2.059ex" role="img" focusable="false" viewBox="0 -716 3532.7 910"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(750,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mo" transform="translate(1510,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1954.7,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"></path></g><g data-mml-node="mi" transform="translate(2704.7,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g></g></g></svg></mjx-container></span>），这样就是一棵树。对这棵树执行操作 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="21.754ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 9615.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="46" d="M128 619Q121 626 117 628T101 631T58 634H25V680H582V676Q584 670 596 560T610 444V440H570V444Q563 493 561 501Q555 538 543 563T516 601T477 622T431 631T374 633H334H286Q252 633 244 631T233 621Q232 619 232 490V363H284Q287 363 303 363T327 364T349 367T372 373T389 385Q407 403 410 459V480H450V200H410V221Q407 276 389 296Q381 303 371 307T348 313T327 316T303 317T284 317H232V189L233 61Q240 54 245 52T270 48T333 46H360V0H348Q324 3 182 3Q51 3 36 0H25V46H58Q100 47 109 49T128 61V619Z"></path></g><g data-mml-node="mrow" transform="translate(819.7,0)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(1132.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(2132.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2632.4,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3077.1,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(3980.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(4980.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(5480.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(5925.2,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(6906.4,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(7906.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(8406.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></span>
即可。那么，剩余的几条边和蓝边都能够保证它们的值不超过 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.024ex" height="1.731ex" role="img" focusable="false" viewBox="0 -683 2662.4 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(903.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1903.4,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g></g></svg></mjx-container></span>。</p>
<p>接下来，考虑这个过程中去掉的边（<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="12.673ex" height="2.034ex" role="img" focusable="false" viewBox="0 -705 5601.3 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mi" transform="translate(791,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g><g data-mml-node="mo" transform="translate(1542,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1986.7,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mi" transform="translate(2777.7,0)"><path data-c="1D436" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"></path></g><g data-mml-node="mo" transform="translate(3537.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(3982.3,0)"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mi" transform="translate(4773.3,0)"><path data-c="1D437" d="M287 628Q287 635 230 637Q207 637 200 638T193 647Q193 655 197 667T204 682Q206 683 403 683Q570 682 590 682T630 676Q702 659 752 597T803 431Q803 275 696 151T444 3L430 1L236 0H125H72Q48 0 41 2T33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM703 469Q703 507 692 537T666 584T629 613T590 629T555 636Q553 636 541 636T512 636T479 637H436Q392 637 386 627Q384 623 313 339T242 52Q242 48 253 48T330 47Q335 47 349 47T373 46Q499 46 581 128Q617 164 640 212T683 339T703 469Z"></path></g></g></g></svg></mjx-container></span>），对于 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="3.489ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 1542 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mi" transform="translate(791,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g></g></g></svg></mjx-container></span>，它的值为
<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.024ex" height="1.731ex" role="img" focusable="false" viewBox="0 -683 2662.4 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(903.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1903.4,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g></g></svg></mjx-container></span>，是合法的。对于 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.79ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 791 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container></span> 和它的一个子节点 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.459ex" height="1.645ex" role="img" focusable="false" viewBox="0 -705 645 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g></g></g></svg></mjx-container></span> 的连线，必然有 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="20.263ex" height="1.945ex" role="img" focusable="false" viewBox="0 -694 8956.1 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(903.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mn" transform="translate(1903.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2681.2,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(3737,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="msub" transform="translate(4082,0)"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(553,-150) scale(0.707)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g></g><g data-mml-node="mo" transform="translate(5418.9,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(6474.6,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(7455.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(8456.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>，这个边的值 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="24.535ex" height="1.945ex" role="img" focusable="false" viewBox="0 -694 10844.5 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(762.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mi" transform="translate(1818.6,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(2721.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(3722,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="msub" transform="translate(4067,0)"><g data-mml-node="mi"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mi" transform="translate(553,-150) scale(0.707)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"></path></g></g><g data-mml-node="mo" transform="translate(5403.9,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(6459.6,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(7362.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(8363.1,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(9344.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(10344.5,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>，也是合法的。故此次操作的结果是合法的。</p>
<p>特别地，考虑 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="1.79ex" height="2.032ex" role="img" focusable="false" viewBox="0 -704 791 898"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g></g></g></svg></mjx-container></span>
已经有编码的情况。事实上，这种情况更加简单，对于去掉点 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.699ex" height="1.545ex" role="img" focusable="false" viewBox="0 -683 751 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"></path></g></g></g></svg></mjx-container></span> 的子树，我们可以执行操作 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="13.96ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 6170.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="46" d="M128 619Q121 626 117 628T101 631T58 634H25V680H582V676Q584 670 596 560T610 444V440H570V444Q563 493 561 501Q555 538 543 563T516 601T477 622T431 631T374 633H334H286Q252 633 244 631T233 621Q232 619 232 490V363H284Q287 363 303 363T327 364T349 367T372 373T389 385Q407 403 410 459V480H450V200H410V221Q407 276 389 296Q381 303 371 307T348 313T327 316T303 317T284 317H232V189L233 61Q240 54 245 52T270 48T333 46H360V0H348Q324 3 182 3Q51 3 36 0H25V46H58Q100 47 109 49T128 61V619Z"></path></g><g data-mml-node="mrow" transform="translate(819.7,0)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mo" transform="translate(910,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(1354.7,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(2035.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2480.3,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(3461.6,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4461.8,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(4961.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></span>，那么所有边的值都能保证 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="14.035ex" height="1.857ex" role="img" focusable="false" viewBox="0 -683 6203.4 821"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"></path></g><g data-mml-node="mo" transform="translate(762.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"></path></g><g data-mml-node="mi" transform="translate(1818.6,0)"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(2721.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(3722,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mo" transform="translate(4703.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(5703.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>，而新连的边值为 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.024ex" height="1.731ex" role="img" focusable="false" viewBox="0 -683 2662.4 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path></g><g data-mml-node="mo" transform="translate(903.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(1903.4,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g></g></g></svg></mjx-container></span>，依旧合法。</p>
<p>故由数学归纳法，原命题成立。操作 <span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.776ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4763 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="46" d="M128 619Q121 626 117 628T101 631T58 634H25V680H582V676Q584 670 596 560T610 444V440H570V444Q563 493 561 501Q555 538 543 563T516 601T477 622T431 631T374 633H334H286Q252 633 244 631T233 621Q232 619 232 490V363H284Q287 363 303 363T327 364T349 367T372 373T389 385Q407 403 410 459V480H450V200H410V221Q407 276 389 296Q381 303 371 307T348 313T327 316T303 317T284 317H232V189L233 61Q240 54 245 52T270 48T333 46H360V0H348Q324 3 182 3Q51 3 36 0H25V46H58Q100 47 109 49T128 61V619Z"></path></g><g data-mml-node="mrow" transform="translate(819.7,0)"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(1277,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mn" transform="translate(1721.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(2221.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mi" transform="translate(2666.3,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(3554.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></g></svg></mjx-container></span>
的结果即为本题答案。</p>
<h2 id="代码">代码</h2>
<p>这里不多加阐述，可以参考下方的代码和注释。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">/**</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co"> * </span><span class="an">@link</span><span class="co"> </span><span class="cv">https://www.luogu.com.cn/problem/P11206</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"> */</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;bits/stdc++.h&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define upto</span><span class="op">(</span>i<span class="op">,</span>n<span class="op">)</span><span class="pp"> </span><span class="cf">for</span><span class="op">(</span><span class="dt">int</span><span class="pp"> </span>i<span class="op">=</span><span class="dv">1</span><span class="op">;</span>i<span class="op">&lt;=(</span>n<span class="op">);</span>i<span class="op">++)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> T<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> Solution <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> N<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="dt">int</span> _N <span class="op">=</span> <span class="fl">1e5</span><span class="op">+</span><span class="dv">5</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> depth<span class="op">[</span>_N<span class="op">];</span>  <span class="co">// 到根节点（1）的距离</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> conn<span class="op">[</span>_N<span class="op">];</span>  <span class="co">// i 和 conn[i][j] 互相连接</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> parent<span class="op">[</span>_N<span class="op">];</span>  <span class="co">// 记录父亲节点</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> filling_queue_arr<span class="op">[</span>_N<span class="op">];</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> filled<span class="op">[</span>_N<span class="op">];</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>queue<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> filling_queue<span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> init<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 重设，防止多测数据互相污染</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>memset<span class="op">(</span>depth<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>depth<span class="op">));</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        upto<span class="op">(</span>i<span class="op">,</span> _N<span class="op">)</span>  conn<span class="op">[</span>i<span class="op">].</span>clear<span class="op">();</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>memset<span class="op">(</span>parent<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>parent<span class="op">));</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>memset<span class="op">(</span>filling_queue_arr<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>filling_queue_arr<span class="op">));</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>memset<span class="op">(</span>filled<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>filled<span class="op">));</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>N<span class="op">);</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">=</span><span class="dv">0</span><span class="op">,</span> y<span class="op">=</span><span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        upto<span class="op">(</span>_<span class="op">,</span> N<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>x<span class="op">,</span> <span class="op">&amp;</span>y<span class="op">);</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>            conn<span class="op">[</span>x<span class="op">].</span>push_back<span class="op">(</span>y<span class="op">);</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>            conn<span class="op">[</span>y<span class="op">].</span>push_back<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> dfs_depth<span class="op">(</span><span class="dt">int</span> p<span class="op">,</span> <span class="dt">int</span> prev<span class="op">)</span> <span class="op">{</span>  <span class="co">// 计算深度</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        parent<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> prev<span class="op">;</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        depth<span class="op">[</span>p<span class="op">]</span> <span class="op">=</span> depth<span class="op">[</span>prev<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>dest<span class="op">:</span> conn<span class="op">[</span>p<span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dest <span class="op">==</span> prev<span class="op">)</span>  <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>            dfs_depth<span class="op">(</span>dest<span class="op">,</span> p<span class="op">);</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> check<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        upto<span class="op">(</span>i<span class="op">,</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> <span class="op">&amp;</span>dest<span class="op">:</span> conn<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>filled<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> filled<span class="op">[</span>dest<span class="op">]</span> <span class="op">&gt;</span> N<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> solve<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        init<span class="op">();</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>        dfs_depth<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span>  <span class="co">// 以 1 为根节点</span></span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 按照深度排序填充顺序</span></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>        upto<span class="op">(</span>i<span class="op">,</span> N<span class="op">)</span>  filling_queue_arr<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> i<span class="op">;</span></span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>sort<span class="op">(</span>filling_queue_arr<span class="op">+</span><span class="dv">1</span><span class="op">,</span> filling_queue_arr<span class="op">+</span><span class="dv">1</span><span class="op">+</span>N<span class="op">,</span> <span class="op">[](</span><span class="kw">auto</span> a<span class="op">,</span> <span class="kw">auto</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> depth<span class="op">[</span>a<span class="op">]</span> <span class="op">&gt;</span> depth<span class="op">[</span>b<span class="op">];</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        upto<span class="op">(</span>i<span class="op">,</span> N<span class="op">)</span>  filling_queue<span class="op">.</span>push<span class="op">(</span>filling_queue_arr<span class="op">[</span>i<span class="op">]);</span>  <span class="co">// 压入队列</span></span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> L<span class="op">=</span><span class="dv">1</span><span class="op">,</span> R<span class="op">=</span>N<span class="op">;</span>  <span class="co">// 区间最小值和最大值</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 依次填充</span></span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span><span class="kw">not</span> filling_queue<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> cur <span class="op">=</span> filling_queue<span class="op">.</span>front<span class="op">();</span>  filling_queue<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>filled<span class="op">[</span>cur<span class="op">])</span>  <span class="cf">continue</span><span class="op">;</span>  <span class="co">// 填过的就忽略</span></span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 尝试在该点填充一个最大的数</span></span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>            filled<span class="op">[</span>cur<span class="op">]</span> <span class="op">=</span> R<span class="op">;</span> R<span class="op">--;</span>  <span class="co">// set 的末指针用星号取值即为最大值</span></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>            <span class="co">// 在父节点填充一个最小的数</span></span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>parent<span class="op">[</span>cur<span class="op">]</span> <span class="op">!=</span> <span class="dv">0</span> <span class="co">/* 特判，根节点不做处理 */</span> <span class="op">&amp;&amp;</span> <span class="kw">not</span> filled<span class="op">[</span> parent<span class="op">[</span>cur<span class="op">]</span> <span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>                filled<span class="op">[</span> parent<span class="op">[</span>cur<span class="op">]</span> <span class="op">]</span> <span class="op">=</span> L<span class="op">;</span> L<span class="op">++;</span></span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 全部填充完毕</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>        upto<span class="op">(</span>i<span class="op">,</span> N<span class="op">)</span>  printf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st"> "</span><span class="op">,</span> filled<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>        <span class="ot">assert</span><span class="op">(</span>check<span class="op">());</span>  <span class="co">// 结果正确</span></span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">"</span><span class="sc">\n</span><span class="st">"</span><span class="op">);</span></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>    scanf<span class="op">(</span><span class="st">"</span><span class="sc">%d</span><span class="st">"</span><span class="op">,</span> <span class="op">&amp;</span>T<span class="op">);</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>T <span class="op">--&gt;</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>        Solution<span class="op">::</span>solve<span class="op">();</span></span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>这里的 <code>check()</code>
函数事实上是无用的，不过可以方便调试。</p>
<p>此外，还是要提醒一下，对于多测的题目，要注意完全清空所有可能用到的数组和容器。</p>

            
        </div>
    </div>
    <div class="post-tags">
        
        
        
    </div>
    <a href="/blogs/Solution/2024/10/0fbcfeb56d0b/" class="go-post">阅读全文</a>
</div>


        <div class="page-current">
    
    <span class="current">1</span>
    
    
    
    
</div>

    </div>
    
    <div id="home-card">
        <div id="card-style">
    <div id="card-div">
        <div class="avatar">
            <img src="/blogs/images/avatar.jpg" alt="avatar" />
        </div>
        <div class="name">normal-pcer</div>
        <div class="description">
            <p>Description …</p>

        </div>
        
        
    </div>
</div>

    </div>
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2025 normal-pcer&#39;s blog
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;normal-pcer
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/blogs/js/main.js"></script>
    
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
